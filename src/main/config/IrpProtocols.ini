The format of this file is as follows:

The protocols are defined in [protocol] sections.
Every protocol has a unique name, declared as name=.
By setting usable=no, the current protocol is ignored.
The IRP form of the protocol are declared as irp=... which has to be
on exactly one line, possibly continued with backslashes at the end of the
physical lines.

The [documentation] section contains an XHTML fragment, describing the current protocol.

The version of the file is declared in a [version] section.

As is probably already clear, content before the first section is ignored.

[version]
2016-08-03
[protocol]
name=48-NEC
usable=no
[documentation]
If you get a decode whose protocol name is
simply "48-NEC" that indicates the learned signal is not complete (usually caused by
not holding the original remote's button long enough during learning).  Enough of
the signal is present to accurately determining the device, subdevice and OBC numbers.
But not enough is present to determine whether the protocol is 48-NEC1 or 48-NEC2.

[protocol]
name=48-NEC1
irp={38.4k,564}<1,-1|1,-3>(16,-8,D:8,S:8,F:8,~F:8,E:8,~E:8,1,^108m,(16,-4,1,^108m)*)\
[D:0..255,S:0..255=255-D,F:0..255,E:0..255]
EFC_translation=LSB comp
[documentation]
This protocol signals repeats by the use of <A href="#repeat">dittos</A>.

[protocol]
name=48-NEC2
irp={38.4k,564}<1,-1|1,-3>(16,-8,D:8,S:8,F:8,~F:8,E:8,~E:8,1,^108m)* \
[D:0..255,S:0..255=255-D,F:0..255,E:0..255]
EFC_translation=LSB comp
[documentation]
This protocol signals repeats by the use of <A href="#repeat">dittos</A>.

[protocol]
name=AdNotam
irp={35.7k,895,msb}<1,-1|-1,1>(1,-2,1,D:6,F:6,^114m)*[D:0..63,F:0..63]
[documentation]
Very similar to RC5, except AdNotam uses two start bits, and no toggle bit.

[protocol]
name=AirAsync
usable=no
#irp={37.7k,840}<1|-1>( 1,B:8,-2 ... )
irp={37.7k,840}<1|-1>(N=0,(1,B:8:N,-2,N=N+8)+) [B:0..99999]
# This is the version from Graham's document
[documentation]
This protocol uses asynchronous data transmission that sends an 8-bit
byte with 1 start bit, 8 data bits and 2 stop bits.  The minimum
signal is one byte.  The protocol is reported as
AirAsync<i>n</i>-xx.yy. ...  where <i>n</i> is the number of bytes and
xx, yy, ... are the byte values in hexadecimal notation.

[protocol]
name=AirB?-????
[documentation]
This is not a robust protocol, so <A href="#spurious">spurious decodes</A> are likely.
If you see this decode from something other than an IR keyboard, you should probably ignore it.

[protocol]
name=Aiwa
UEI_protocol=005E or 009E
irp={38k,550}<1,-1|1,-3>(16,-8,D:8,S:5,~D:8,~S:5,F:8,~F:8,1,-42,(16,-8,1,-165)*) [D:0..255,S:0..31,F:0..255]
EFC_translation=LSB
[documentation]
This protocol signals repeats by the use of <A href="#repeat">dittos</A>.

The EFC numbering varies among the KM and RM versions of Aiwa.  Using OBC numbers is less confusing.

When using a non-combo version of Aiwa in KM, you must combine the
device and subdevice numbers as device+256*subdevice to get the number
KM calls "Device Code".  (Since subdevice is usually zero, that
combination is trivial).  In Aiwa combo in KM you use the subdevice as
"parameter" (on the setup sheet) and put the device in the byte2
column on the functions sheet.  RM follows DecodeIr's naming of Device
and Subdevice.

[protocol]
name=AK

[protocol]
name=Akai
UEI_protocol=000D
irp={38k,289}<1,-2.6|1,-6.3>(D:3,F:7,1,^25.3m)*[D:0..7,F:0..127]
EFC_translation=LSB comp prefixed with last device bit
[documentation]
This is not a robust protocol, so <A href="#spurious">spurious decodes</A> are likely.

As of version 8.31, KM does not translate device to fixed data, nor
OBC to EFC according to the same rules used by DecodeIr.  RM does
translate consistently with DecodeIr, so you may find it easier to use
RM.  If you use KM, you must change the device number as follows:

<ul>
<li>Decoded device 0 or 4 --> KM device 3</li>
<li>Decoded device 1 or 5 --> KM device 2</li>
<li>Decoded device 2 or 6 --> KM device 1</li>
<li>Decoded device 3 or 7 --> KM device 0</li>
</ul>

Also (in KM) you should use the EFC number from the decode not the OBC
number.  Akai protocol uses the same EFC numbering across all JP1
remotes, so use of EFC is safe.  KM uses different OBC numbering than
RM and DecodeIr, so use of OBCs isn't safe.

[protocol]
name=Amino-56
UEI_protocol=000D
irp={56.0k,268,msb}<-1,1|1,-1>(T=1,(7,-6,3,D:4,1:1,T:1,1:2,0:8,F:8,15:4,C:4,-79m,T=0)+){C =(D:4+4*T+9+F:4+F:4:4+15)&15} [D:0..15,F:0..255]
EFC_translation=MSB
[protocol]
name=Amino
UEI_protocol=000D
irp={37.3k,268,msb}<-1,1|1,-1>(T=1,(7,-6,3,D:4,1:1,T:1,1:2,0:8,F:8,15:4,C:4,-79m,T=0)+){C =(D:4+4*T+9+F:4+F:4:4+15)&15} [D:0..15,F:0..255]
EFC_translation=MSB
[documentation]
IRP notation: {56.0k,268,msb}&lt;-1,1|1,-1&gt;(T=1,(7,-6,3,D:4,1:1,T:1,1:2,0:8,F:8,15:4,C:4,-79m,T=0)+)
Variant:      {37.3k,268,msb}&lt;-1,1|1,-1&gt;(T=1,(7,-6,3,D:4,1:1,T:1,1:2,0:8,F:8,15:4,C:4,-79m,T=0)+)
<br>{C =(D:4+4*T+9+F:4+F:4:4+15)&15}  [the arithmetic sum of the first 7 nibbles mod 15]
<br>T=1 for the first frame and T=0 for all repeat frames.
<br>DecodeIR v2.43 checks T and will report in the Misc field if the start or end frame is missing.
Amino equipment use both 37 and 56KHz, but the duration of the half-bit is
always 268.  Zaptor is a closely related protocol which for which the half-bit duration is 330.
IRDecode v2.43 distinguishes between Amino and Zaptor in order of priority by 1)the position of the toggle bit,
2)the value of the next to last nibble, and 3)the measured duration of a half-bit.
# In the IRP notation, T is an 8-bit toggle variable such that T is 0
# for the start frame and takes a common nonzero value M for all repeat
# frames.  C is a checksum given by

#   C = (D^T^S^F^FF^(((F^FF)&(T^M))<<1))|$F0 with FF = F:1:4*((F<<1)&(F<<2)&(F<<3))

# where X<<n means X shifted left n places, with 1's filling the empty
# places to the right and | means bitwise-OR. DecodeIR v2.37 checks T
# and will report in the Misc field if the start frame is missing.

# This protocol has been identified from one example, the Aminet110 STB,
# which has M=4. If the calculated and actual checksums differ, then the
# XOR of the two is given in the Misc field as a parameter N.  A nonzero
# N is an indication that the checksum formula is probably wrong for
# data more general than that in the known example.

[protocol]
name=Anthem
UEI_protocol=0123
irp={38.0k,605}<1,-1|1,-3>((8000u,-4000u,D:8,S:8,F:8,C:8,1,-25m)3, -75m)* { C=~(D+S+F+255):8} [D:0..255,S:0..255,F:0..255]
[documentation]
Anthem framing is very similar to NEC, and also uses 32 bits of data. However, the leadout is much shorter. The signal is sent at least 3 times. Anthem usually splits F into a 2 bit unit number, and a 6 bit function number.

[protocol]
name=Apple
UEI_protocol=01E0
irp={38.4k,564}<1,-1|1,-3>(16,-8,D:8,S:8,C:1,F:7,PairID:8,1,^108m,(16,-4,1,^108m)*)\
{C=1-(#F+#PairID)%2,S=135}\
[D:0..255=238,F:0..127,PairID:0..255]
[documentation]
C=1 if the number of 1 bits in the fields F and I is even.  I is the remote ID.
Apple uses the same framing as NEC1, with D=238 in normal use, 224 while pairing.  S=135


[protocol]
name=Archer
irp={0k,12}<1,-3.3m|1,-4.7m>(F:5,1,-9.7m)* [F:0..31]
EFC_translation=5-bit LSB
[documentation]
This is not a robust protocol, so <A href="#spurious">spurious decodes</A> are likely.

[protocol]
name=Async
[documentation]
This protocol uses asynchronous data transmission that sends an 8-bit
byte with 1 start bit, 8 data bits and 1 stop bit.  The minimum signal
is four bytes.  The protocol is reported as
Async<i>n</i>:min-max:aa.bb...yy.zz where <i>n</i> is the number of
bytes, min-max is the range of durations in microseconds that was
taken as a single bit and aa.bb...yy.zz are the first two and last two
byte values in hexadecimal notation.

[protocol]
name=Barco
UEI_protocol=002A
irp={0k,10}<1,-5|1,-15>(1,-25, D:5,F:6, 1,-25,1,-120m)*[D:0..31,F:0..63]
EFC_translation=6-bit LSB comp
[documentation]
This is a moderately robust protocol, but <A href="#spurious">spurious decodes</A> are still possible.

[protocol]
name=Blaupunkt
irp={30.3k,528}<-1,1|1,-1>(1,-5,1023:10,-39,1,-5,1:1,F:6,D:3,-230) [F:0..63,D:0..7]
[documentation]
Was F:7,D:2 until DecodeIr version 2.45.


[protocol]
name=Bose
UEI_protocol=010C
irp={38.0k,500,msb}<1,-1|1,-3>(2,-3,F:8,~F:8,1,-100m)* [F:0..255]
EFC_translation=MSB

[protocol]
name=Bryston
irp={38.0k,315}<1,-6|6,-1>(D:10,F:8,-18m)* [D:0..1023,F:0..255]

[protocol]
name=CanalSat
UEI_protocol=018C
irp={55.5k,250,msb}<-1,1|1,-1>(T=0,(1,-1,D:7,S:6,T:1,0:1,F:7,-89m,T=1)+)[D:0..127,S:0..63,F:0..127]
#irp={55.5k,250,msb}<-1,1|1,-1>(T=0,1:1,D:7,S:6,T:1,0:1,F:7,-89m,(T=1,1:1,D:7,S:6,T:1,0:1,F:7,-89m)+)[D:0..127,S:0..63,F:0..127]
EFC_translation=7-bit MSB.
[documentation]
The <A href="#repeat">repeat frames</A> are not all identical.  T
toggles within a single signal, with T=0 for the start frame and T=1
for all repeats.  DecodeIR v2.37 and later check T and will report in
the Misc field if the start frame is missing.

[protocol]
name=CanalSatLD
irp={56k,320,msb}<-1,1|1,-1>(T=0,(1,-1,D:7,S:6,T:1,0:1,F:6,~F:1,-85m,T=1)+)[D:0..127,S:0..63,F:0..63]

[protocol]
name=Denon
alt_name=Denon{1}
alt_name=Denon{2}
irp={38k,264}<1,-3|1,-7>(D:5,F:8,0:2,1,-165,D:5,~F:8,3:2,1,-165)* [D:0..31,F:0..255]
EFC_translation=LSB
[documentation]
A Denon signal has two halves, either one of which is enough to fully decode
the information. A significant fraction of Denon learned signals contain just
one half or have the halves separated so that DecodeIr can't process them
together. When one half is seen separate from the other, DecodeIr will name
the protocol Denon{1} or Denon{2} depending on which half is decoded. Denon,
Denon{1} and Denon{2} all represent the same protocol when they are correct.
But only Denon is robust. A Denon{1} or Denon{2} decode might be <A href="#spurious">spurious</A>.

[protocol]
name=Denon-K
UEI_protocol=00CD
usable=yes
irp={37k,432}<1,-1|1,-3>(8,-4,84:8,50:8,0:4,D:4,S:4,F:12,((D*16)^S^(F*16)^(F:8:4)):8,1,-173)* [D:0..15,S:0..15,F:0..4095]

EFC_translation=LSB comp
[documentation]
Denon-K is the member of the Kaseikyo family with OEM_code1=84 and OEM_code2=50.
[documentation]
Denon-K uses the same check byte rules as Panasonic protocol, but uses the data bits differently.
The Panasonic Combo protocol in KM can be used with some difficulty to produce Denon-K signals.
The Denon-K choice in RM uses the same protocol executor as Panasonic combo, but computes the hex commands
based on Denon's use of the Kaseikyo data bits.

[protocol]
name=Dgtec
UEI_protocol=016A
irp={38k,560}<1,-1|1,-3>(16,-8,D:8,F:8,~F:8,1,^108m,(16,-4,1,^108m)+) [D:0..255,F:0..255]
EFC_translation=LSB comp
[documentation]
This protocol signals repeats by the use of <A href="#repeat">dittos</A>.

[protocol]
name=DirecTV
#usable=no
#irp={38k,600,msb}<1,-1|1,-2|2,-1|2,-2>(5,(5,-2,D:4,F:8,C:4,1,-50)+){C=7*(F:2:6)+5*(F:2:4)+3*(F:2:2)+(F:2)}[D:0..15,F:0..255]
#irp={38k,600,msb}<1,-1|1,-2|2,-1|2,-2>(10,-2,D:4,F:8,C:4,1,-50,(5,-2,D:4,F:8,C:4,1,-50)*){C=7*(F:2:6)+5*(F:2:4)+3*(F:2:2)+(F:2)}[D:0..15,F:0..255]
irp={38k,600,msb}<1,-1|1,-2|2,-1|2,-2>([10][5],-2,D:4,F:8,C:4,1,-50){C=7*(F:2:6)+5*(F:2:4)+3*(F:2:2)+(F:2)}[D:0..15,F:0..255]
#irp={38k,600,msb}<1,-1|1,-2|2,-1|2,-2>(5,(5,-2,D:4,F:8,C:4,1,-50),(5,-2,D:4,F:8,C:4,1,-50)+){C=7*(F:2:6)+5*(F:2:4)+3*(F:2:2)+(F:2)}[D:0..15,F:0..255]
EFC_translation=MSB
[documentation]
There are six variants of the DirecTV protocol, distinguished in
RemoteMaster by the parameter "Parm" on the Setup page.  The Parm
value is shown in the Misc field of DecodeIR.  The IRP notation above
corresponds to the default Parm=3.  The various Parm values correspond
to three different frequencies (the 38k in the above) and two
different lead-out times (the -50 in the above).  The corresponding
values are:

<ul>
<li>Parm=0 : 40k, -15
<li>Parm=1 : 40k, -50
<li>Parm=2 : 38k, -15
<li>Parm=3 : 38k, -50
<li>Parm=4 : 57k, -15
<li>Parm=5 : 57k, -50
</ul>

Portions of a dirty learn of a Sony signal may look like a DirecTV
signal.  So, if you get a DirecTV decode together with a plausible
Sony decode, believe the Sony decode and ignore the DirecTV.  If you
get a DirecTV decode without a Sony decode for some functions of a
Sony device, try relearning them; a DirecTV decode for a signal meant
for a Sony device is not likely to be correct.
[documentation]
This protocol was called Russound in versions of DecodeIR earlier than 2.40.

[protocol]
name=Dishplayer
UEI_protocol=010F

irp={38.4k,535,msb}<1,-5|1,-3>(1,-11,(F:6,S:5,D:2,1,-11)+) [F:0..63,S:0..31,D:0..3]
# Renamed U -> S
EFC_translation=Not available in this version of DecodeIr
[documentation]
This is not a robust protocol, so <A href="#spurious">spurious decodes</A> are likely.

[protocol]
name=Dish_Network
UEI_protocol=0002
irp={57.6k,406}<1,-7|1,-4>(1,-15,(F:-6,S:5,D:5,1,-15)+) [F:0..63,S:0..31,D:0..31]
# Renamed U -> S
# Updated time base, see http://www.hifi-remote.com/forums/viewtopic.php?t=13923&start=7
EFC_translation=MSB comp 6 function bits followed by LSB comp low 2 unit bits.
[documentation]
This is not a robust protocol, so <A href="#spurious">spurious decodes</A> are likely.

The unit number shows up in the Subdevice field of DecodeIr's output.
In KM, the "unit code" is one greater than the unit number.  So you
must take the Subdevice from the decode and add one to it and use that
as the "unit code" in KM.

There are two variants of the protocol executor for DishNetwork with different
but compatible EFC numbering. The decoded EFC should work for both. But the
results may be less confusing if you use OBC numbers in KM or RM.

[protocol]
name=Elan
UEI_protocol=Unknown
irp={40.2k,398,msb}<1,-1|1,-2>(3,-2,D:8,~D:8,2,-2,F:8,~F:8,1,^50m)* [D:0..255,F:0..255]
[documentation]
See the <A href="http://www.hifi-remote.com/forums/viewtopic.php?p=87473">JP1-forum</A> for the executor


[protocol]
name=Emerson
UEI_protocol=0065
irp={36.7k,872}<1,-1|1,-3>(4,-4,D:6,F:6,~D:6,~F:6,1,-39)* [D:0..63,F:0..63]
EFC_translation=6-bit LSB comp with 2-bit mini-combo
[documentation]
Lists three different EFCs because this protocol is a <A href="#mini combo">mini combo</A>.

[protocol]
name=F12
irp={37.9k,422}<1,-3|3,-1>((D:3,S:1,F:8,-80)2,-128)*  [D:0..7,S:0..1,F:0..255]
EFC_translation=Not available in this version of DecodeIr.
[documentation]
The F12 specification isn't representable in IRP notation.  The Toshiba specification is
{37.9k,422}<1,-3|3,-1>(D:3,H:1,A:1,B:1,-80)2 for A=1 or B=1
{37.9k,422}<1,-3|3,-1>((D:3,H:1,A:1,B:1,-80)2,-128)+  for H=1.
Exactly one of H, A, or B can have a value of 1.  If H=1 the signal may be sent repeatedly, and F can take any 6 bit value.
If A or B=1, the signal is sent once only per button press, and only a single bit of F can be non-zero. \
Spec sheet is at http://www.hifi-remote.com/forums/dload.php?action=file&file_id=9832

[protocol]
name=F32
irp={37.9k,422,msb}<1,-3|3,-1>(D:8,S:8,F:8,E:8,-100m)*  [D:0..255,S:0..255,F:0..255,E:0..255]
The meaning of the 32 bits of data is unknown, and the assignment to D, S, F, and E is arbitrary

[protocol]
name=Fujitsu
UEI_protocol=00F8
irp={37k,432}<1,-1|1,-3>(8,-4,20:8,99:8,0:4,E:4,D:8,S:8,F:8,1,-110)* [D:0..255,S:0..255=D,F:0..255,E:0..15=0]

EFC_translation=LSB comp
[documentation]
Fujitsu is the member of the Kaseikyo family with OEM_code1=20 and OEM_code2=99.
[documentation]
There is no check byte, so the risk of an incorrectly decoded OBC is much higher than in
other Kaseikyo protocols.

00F8 requires 2-byte hex commands, so the decoded EFC number is
generally not useful. Use OBC number in upgrades or to compute Hex
commands.

[protocol]
name=Fujitsu-56
irp={37k,432}<1,-1|1,-3>(8,-4,20:8,99:8,0:4,E:4,D:8,S:8,X:8,F:8,1,-110)* [D:0..255,S:0..255=D,F:0..255,E:0..15=0,X:0..255=0]

[protocol]
name=G.I.Cable
alt_name=G.I. Cable{1}
UEI_protocol=00C4

irp={38.7k,490}<1,-4.5|1,-9>(18,-9,F:8,D:4,C:4,1,-84,(18,-4.5,1,-178)*){C = -(D + F:4 + F:4:4)} [D:0..15,F:0..255]
EFC_translation=LSB
[documentation]
This protocol signals repeats by the use of <A href="#repeat">dittos</A>.

When the {1} is shown as part of the protocol name for G.I. Cable, it
just means that the repeat part of the signal is not present.  That
doesn't indicate any difference in the actual protocol nor even any
unreliability in the decode.  It may indicate that use of the learned
signal will be less reliable, so you have more than usual reason to
replace it with a <A HREF="#jp1">KeyMove, Upgrade</A> or cleaned up
version.

[protocol]
name=G.I.4DTV
UEI_protocol=00A4

irp={37.3k,992}<1,-1|1,-3>(5,-2,F:6,D:2,C:4,1,-60)*\
{C= ((#(F&25) + #(D&5))&1) + 2*((#(F&43) + #(D&7))&1) + 4*((#(F&22) + #(D&7))&1) + 8*((#(F&44) + #(D&6))&1)}\
[D:0..3, F:0..63]
EFC_translation=NONE
[documentation]
This is a moderately robust protocol, but <A href="#spurious">spurious decodes</A> are still possible.
Unit (device) numbers from 0 to 7 are supported.  The check sum C is a Hamming Code, which can correct single bit errors.
D:1:2 is encoded in the check sum. See http://www.hifi-remote.com/forums/viewtopic.php?p=103934#103934
The official (UEI) protocol executor for G.I.4DTV does not support EFC numbers.  If you are creating an
upgrade in KM or RM you should use OBC numbers, not EFC numbers.  If you need the Hex Cmd for a KeyMove,
you should use the functions sheet of KM or RM to compute it for you from the OBC and device number.

[protocol]
name=GI RG
UEI_protocol=unknown
irp={37.3k,1000, msb}<1,-1|1,-3>(5,-3,F:6,S:2,D:8,1,-60)*[D:0..255, S:0..3, F:0..63]
EFC translation:
This is a moderately robust protocol, but <A href="#spurious">spurious decodes</A> are still possible.
Typical usage is the GI/Next Level/Motorola RC2x00 series

[protocol]
name=Grundig16
UEI_protocol=0112
irp={35.7k,578,msb}<-4,2|-3,1,-1,1|-2,1,-2,1|-1,1,-3,1>(806u,-2960u,1346u,T:1,F:8,D:7,-100)*[D:0..127,F:0..255,T@:0..1=0]
EFC_translation=MSB but with bit pairs translated data->hex by 00->00, 01->11, 10->01, 11->10 and off by one position.
[documentation]
These are two variants of the same protocol, differing only in
frequency.  The IRP notation is corrected from previous versions of
this document, to bring it into line with what DecodeIR actually does.

Note (BM): These two entries was one in the original document; I split it into two separate.
[protocol]
name=Grundig16-30
UEI_protocol=00AB
irp={30.3k,578,msb}<-4,2|-3,1,-1,1|-2,1,-2,1|-1,1,-3,1>(806u,-2960u,1346u,T:1,F:8,D:7,-100)* [D:0..127,F:0..255,T:0..1]
EFC_translation= MSB but with bit pairs translated data->hex by 00->00, 01->11, 10->01, 11->10 and off by one position.
[documentation]
These are two variants of the same protocol, differing only in frequency.
The IRP notation is corrected from previous versions of this document, to bring it into line with what DecodeIR actually does.

Note (BM): These two entries was one in the original document; I split it into two separate.
[protocol]
name=GXB
#usable=no
irp={38.3k,520,msb}<1,-3|3,-1>(1,-1,D:4,F:8,P:1,1,^100m)*{P=1-#F%2}[D:0..15,F:0..255]
[documentation]
Decoder for a nonstandard Xbox remote.

[protocol]
name=Humax 4Phase
irp={56k,105, msb}<-2,2|-3,1|1,-3|2,-2>(T=0,(2,-2,D:6,S:6,T:2,F:7,~F:1,^95m,T=1)*)  [D:0..63, S:0..63, F:0..127]
[documentation]
See http://www.hifi-remote.com/forums/viewtopic.php?t=14219 .

[protocol]
name=IODATAn
alt_name=IODATAn-x-y
UEI_protocol=not known.
irp={38k,550}<1,-1|1,-3>(16,-8,x:7,D:7,S:7,y:7,F:8,C:4,1,^108m)* {n = F:4 ^ F:4:4 ^ C:4} [D:0..127,S:0..127,F:0..255,C:0..15=0,x:0..127=0,y:0..127=0]
EFC_translation=LSB
[documentation]
This is potentially a class of protocols distinguished by values of
<i>n</i>, <i>x</i> and <i>y</i> with <i>n</i> = 0..15 and <i>x</i>,
<i>y</i> = 0..127.  If <i>x</i> and <i>y</i> are both zero, they are
omitted.  The only known example is IODATA1.

[protocol]
name=Jerrold
UEI_protocol=0006
irp={0k,44}<1,-7.5m|1,-11.5m>(F:5,1,-23.5m)* [F:0..31]
[documentation]
This is not a robust protocol, so <A href="#spurious">spurious decodes</A> are likely.

[protocol]
name=JVC
alt_name=JVC{2}
UEI_protocol=0034
irp={38k,525}<1,-1|1,-3>(16,-8,(D:8,F:8,1,-45)+) [D:0..255,F:0..255]
EFC_translation=LSB comp
[documentation]
JVC{2} indicates a JVC signal from which the lead-in is missing.  The JVC protocol has
lead-in on only the first frame, so it is quite easy to have it missing from a learned
signal.  So when JVC{2} is correct, it means the same as JVC.  But JVC{2} is not robust,
so <A href="#spurious">spurious decodes</A> are likely.  It
is also very similar in structure and timing to <A href="#Mitsubishi">Mitsubishi</A> protocol, so that
DecodeIr has difficulty distinguishing one from the other.  The device number, OBC and EFC
are all encoded the same way between the two.  So if you have JVC{2}
decodes that you have reason to suspect should actually be Mitsubishi, you can try using
them as Mitsubishi without changing the numbers.  However, true Mitsubishi signals will not
misdecode as JVC, just as JVC{2}.  So if some of the signals for your device decode as JVC
and others as JVC{2}, you should trust all those decodes and not try Mitsubishi.

[protocol]
name=JVC-48
UEI_protocol=001F or 00C9 or 00CD
irp={37k,432}<1,-1|1,-3>(8,-4,3:8,1:8,D:8,S:8,F:8,(D^S^F):8,1,-173)* [D:0..255,S:0..255,F:0..255]
# wrong parametrization
#irp={37k,432}<1,-1|1,-3>(8,-4,3:8,1:8,H:4,D:4,S:8,F:8,(H^16*D^S^F):8,1,-173)+ {H=2}[D:0..15,S:0..255,F:0..255]
EFC_translation=LSB comp
[documentation]
JVC-48 is the member of the Kaseikyo family with OEM_code1=3 and OEM_code2=31.

Panasonic protocol uses the same check byte rules as JVC-48, so you
might want use the (more flexible) Panasonic entries in KM or RM to
produce a JVC-48 upgrade (by changing the OEM_code1 and OEM_code2
values).  For simple JVC-48 upgrades you get exactly the same results
by directly selecting the "JVC-48" protocol.

[protocol]
name=JVC-56
irp={37k,432}<1,-1|1,-3>(8,-4,3:8,1:8,D:8,S:8,X:8,F:8,(D^S^X^F):8,1,-173)*[D:0..255,S:0..255,F:0..255,X:0..255]

[protocol]
name=Kaseikyo
#[documentation]
#Kaseikyo is a family of protocols that includes Panasonic,
#Mitsubishi-K and Teac-K.  Each protocol in the Kaseikyo family is
#identified by two numbers, known as OEM_code1 and OEM_code2.
#
#Most members of the family have minor structural differences from the
#generic form. In those cases DecodeIR checks for the specific details
#(based on the OEM codes) and if they are correct reports the protocol
#by name (see Panasonic and Teak-K below).
#
#In the few cases where the structure exactly fits my understanding of
#the Kaseikyo spec, DecodeIR reports it as Kaseikyo-???-??? replacing
#the first ??? by the OEM_code1 and the second ??? by the OEM_code2.
#
#[protocol]
#name=Kaseikyo-???-???
#irp={37k,432}<1,-1|1,-3>(8,-4,M:8,N:8,X:4,D:4,S:8,F:8,E:4,C:4,1,-173)+ {X=((M^N)::4)^(M^N)}[D:0..15,S:0..255,F:0..255,X:0..15,M:0..255,N:0..255,E:0..15,C:0..15]
#irp={37k,432}<1,-1|1,-3>(8,-4,M:8,N:8,X:4,D:4,S:8,F:8,E:4,C:4,1,-173)+ {X=((M^N)::4)^(M^N), chksum=D^S^F^(E*16), C=chksum::4 ^ chksum}[D:0..15,S:0..255,F:0..255,E:0..15,M:0..255,N:0..255]
irp={37k,432}<1,-1|1,-3>(8,-4,M:8,N:8,X:4,D:4,S:8,F:8,G:8,1,-173)* {X=((M^N)::4)^(M^N), chksum=D^S^F^(E*16), C=chksum::4 ^ chksum}[D:0..15,S:0..255,F:0..255,M:0..255,N:0..255,G:0..255]
# Variable change X -> H
EFC_translation=LSB comp
[documentation]
This is the nominal form of the Kaseikyo.  It is most commonly seen
with OEM codes 170.90, which indicates "Sharp".  I assume (haven't
tested) that the SharpDVD protocol in KM generates these
Kaseikyo-170-90 signals.  We have also seen this protocol with OEM
codes 3.32.  I'm not sure what manufacturer that indicates.

The Kaseikyo protocol in KM seems to be designed to produce this
nominal form of Kaseikyo for any specified OEM codes and any constant
value of E.  That should be the way to reproduce any Kaseikyo-???-???
decode other than SharpDVD, and might be better than SharpDVD for the
Kaseikyo-170-90 signals.

[protocol]
name=Kaseikyo56
irp={37k,432}<1,-1|1,-3>(8,-4,M:8,N:8,H:4,D:4,S:8,E:8,F:8,G:8,1,-173)* {H=((M^N)::4)^(M^N), chksum=S^G^F^(E*16)^D, C=chksum::4 ^ chksum}\
[D:0..15,S:0..255,F:0..255,G:0..255,M:0..255,N:0..255,E:0..255]
[documentation]
Kaseikyo56 is a lengthened version of the Kaseikyo family of
protocols.  It has the same OEM codes indicating the same
manufacturers as Kaseikyo, and it has the same variation (by
manufacturer) in check byte and other details as Kaseikyo.

[protocol]
name=Kathrein
UEI_protocol=0066
irp={38k,540}<1,-1|1,-3>(16,-8,D:4,~D:4,F:8,~F:8,1,^105m,(16,-8,F:8,1,^105m)+) \
[D:0..15,F:0..255]
EFC_translation=LSB comp
[documentation]
This protocol signals repeats by the use of <A
href="#repeat">dittos</A>.  It is unusual in that the ditto frame
carries part of the signal data, specifically the function code (OBC)
but not the device code.

[protocol]
name=Konka
UEI_protocol=019B
irp={38k,500,msb}<1,-3|1,-5>(6,-6,D:8,F:8,1,-8,1,-46)* [D:0..255,F:0..255]
EFC_translation=MSB

[protocol]
name=Logitech
UEI_protocol=020B
irp={38k,127}<3,-4|3,-8>(31,-36,D:4,~D:4,F:8,~F:8,3,-50m)* \
[D:0..15,F:0..255]
EFC_translation=LSB comp
[documentation]
Logitech is used with their PS3 adapter.  The IR signal is similar to Kathrein.  If a Logitech signal is decoded
as Kathrein, the device number and OBC are still correct.

[protocol]
name=Lumagen
usable=yes
irp={38.4k,416,msb}<1,-6|1,-12>(D:4,C:1,F:7,1,-26)* {C = (#F+1)&1} [D:0..15,F:0..127]
EFC_translation=MSB prepended with C bit.

This is a moderately robust protocol, but <A href="#spurious">spurious decodes</A> are still possible.

Note(BM): "odd parity ..." needs extension to IRP(?)
[protocol]
name=Lutron
usable=no
irp={40k,2300,msb}<-1|1>(255:8,X:24,0:4)+
EFC_translation=MSB of decoded signal.
[documentation]
This is an unusual protocol in that an 8-bit device code and 8-bit OBC
are encoded in a 24-bit error-correcting code as the X of the IRP
notation.  This is constructed as follows.  First two parity bits are
appended to the 16 data bits to give even parity for the two sets of 9
bits taken alternately.  The resulting 18-bit sequence is then treated
as 6 octal digits (0-7) expressed in 3-bit binary code.  These are
then re-coded in the 3-bit Gray code (also called, more descriptively,
the reflected-binary code) with a parity bit to give odd parity, so
giving 6 4-bit groups treated as a single 24-bit sequence.  The whole
thing allows any single-bit error in transmission to be identified and
corrected.

[protocol]
name=Matsui
irp={38k,525}<1,-1|1,-3>(D:3,F:7,1,^30.5m)* [D:0..7,F:0..127]
EFC_translation=Not available in this version of DecodeIr
[documentation]
This is not a robust protocol, so <A href="#spurious">spurious decodes</A> are likely.

[protocol]
name=MCE
alt_name=RC6-6-32
usable=yes
irp={36k,444,msb}<-1,1|1,-1>((6,-2,1:1,6:3,-2,2,OEM1:8,S:8,T:1,D:7,F:8,^107m)*,T=1-T) {OEM1=128}[D:0..127,S:0..255,F:0..255,T@:0..1=0]
[documentation]
MCE is a member of the RC6 family.  Technically it is RC6-6-32 with
the standard toggle bit zero, with the OEM1 field equal to 128, and
with a nonstandard (for the RC6 family) toggle bit added. If all those
rules are met, DecodeIr will display the name as "MCE" and with the
OEM2 field moved to the subdevice position.  Otherwise it will display
RC6-6-32.

As of version 8.31, KM does not have built-in support for this
protocol, but there are KM format upgrade files available for Media
Center (built by an expert who isn't limited to KM's built-in
protocols).  Those upgrades should be adaptable to any RC6-6-32 code
set (by changing the fixed data), if the one you have doesn't already
match the upgrade.

RM version 1.16 has support for RC6-6-32, which can be used for MCE
upgrades.  Version 1.17 will also have direct support for MCE

[protocol]
name=Metz19
irp={37.9k,106,msb}<4,-9|4,-16>((8,-22,T:1,D:3,~D:3,F:6,~F:6,4,-125m)*,T=1-T)[D:0..7,F:0..63,T@:0..1=0]
[documentation]
The toggle bit T is inverted each time a new button press occurs.


[protocol]
name=Mitsubishi
UEI_protocol=0014
irp={32.6k,300}<1,-3|1,-7>(D:8,F:8,1,-80)* [D:0..127,F:0..255]
EFC_translation=LSB comp
[documentation]
This is not a robust protocol, so <A href="#spurious">spurious decodes</A> are likely.  It
is also very similar in structure and timing to <A href="#JVC">JVC{2}</A> protocol, so that
DecodeIr has difficulty distinguishing one from the other.  The device number, OBC and EFC
are all encoded the same way between the two.  So if you have Mitsubishi
decodes that you have reason to suspect should actually be JVC, you can try using
them as JVC without changing the numbers.

[protocol]
name=Mitsubishi-K
irp={37k,432}<1,-1|1,-3>(8,-4,35:8,203:8,X:4,D:8,S:8,F:8,T:4,1,-100)* {X=6,T=-S:4:0-S:4:4-F:4:0-F:4:4+15}[D:0..255,F:0..255, S:0..255]
EFC_translation=not available yet
[documentation]
Mitsubishi-K is the member of the Kaseikyo family with OEM_code1=35 and OEM_code2=203.

[protocol]
name=NEC
NEC is a family of similar protocols including NEC1, NEC2, Tivo,
Pioneer, NECx1 and NECx2.  If you get a decode whose protocol name is
simply "NEC" that indicates the learned signal is not complete
(usually caused by not holding the original remote's button long
enough during learning).  Enough of the signal is present to
accurately determine the device, subdevice and OBC numbers.  But not
enough is present to determine whether the protocol is NEC1 or NEC2.
<H3><A name="NEC12difference">Difference between NEC1 and
NEC2</A></H3> The difference between NEC1 and NEC2 only affects the
signal sent by a long keypress.  A short press sends the same signal
in NEC1 and NEC2.

[protocol]
name=NEC1
irp={38.4k,564}<1,-1|1,-3>(16,-8,D:8,S:8,F:8,~F:8,1,^108m,(16,-4,1,^108m)*) [D:0..255,S:0..255=255-D,F:0..255]
EFC_translation=LSB comp
[documentation]
A few devices use NEC1 protocol at 40Khz, rather than the typical
frequency.  When getting a decode of NEC1, if you notice that the
frequency is closer to 40Khz than to 38Khz, examine multiple learns
from the same device to estimate whether the 40Khz frequency is a
learning error or a true characteristic of the device. If the 40Khz is
correct, there are methods in JP1, or MakeHex (whichever you are
using) to reproduce NEC1 at 40Khz rather than the usual frequency.

[protocol]
name=NEC1-rnc
irp={38.4k,564}<1,-1|1,-3>(16,-8,D:8,S:8,F:8,~F:4:4,~F:4,1,^108m,(16,-4,1,^108m)*) [D:0..255,S:0..255=255-D,F:0..255]
EFC_translation=LSB comp

[protocol]
name=NEC1-f16
irp={38.4k,564}<1,-1|1,-3>(16,-8,D:8,S:8,F:16,1,^108m,(16,-4,1,^108m)*) [D:0..255,S:0..255=255-D,F:0..65535]
EFC_translation=LSB comp

[protocol]
name=NEC2
irp={38.4k,564}<1,-1|1,-3>(16,-8,D:8,S:8,F:8,~F:8,1,^108m)* [D:0..255,S:0..255=255-D,F:0..255]
EFC_translation=LSB comp
[documentation]
Pioneer is distinguished from NEC2 only by frequency.  So if your
learning system does not learn frequency accurately, it won't
accurately distinguish Pioneer from NEC2.  All Pioneer signals should
have a device number in the range 160 to 175 and no subdevice.  No
NEC2 signal should fit those rules.  So you usually can determine
whether the decision (by frequency) was wrong by checking the device
numbers.

[protocol]
name=NECx
[documentation]
If you get a decode whose protocol name is simply "NECx" that
indicates the learned signal is not complete (usually caused by not
holding the original remote's button long enough during learning).
Enough of the signal is present to accurately determining the device,
subdevice and OBC numbers.  But not enough is present to determine the
exact protocol, which is probably NECx1 or NECx2.  This incomplete
learn also makes it harder to distinguish NEC from NECx, so a decode
of "NECx" might be NEC1 or NEC2 or even Tivo or Pioneer.

[protocol]
name=NECx1
irp={38.4k,564}<1,-1|1,-3>(8,-8,D:8,S:8,F:8,~F:8,1,^108m,(8,-8,D:1,1,^108m)*) [D:0..255,S:0..255=255-D,F:0..255]
EFC_translation=LSB comp

[protocol]
name=NECx2
irp={38.4k,564}<1,-1|1,-3>(8,-8,D:8,S:8,F:8,~F:8,1,^108m)* [D:0..255,S:0..255=255-D,F:0..255]
EFC_translation=LSB comp

[protocol]
name=Nokia
irp={36k,1p,msb}<6,-10|6,-16|6,-22|6,-28>(15,-10,D:8,S:8,F:8,6,^100m)* [D:0..255,S:0..255,F:0..255]
EFC_translation=MSB

[protocol]
name=Nokia12
irp={36k,1p,msb}<6,-10|6,-16|6,-22|6,-28>(15,-10,D:4,F:8,6,^100m)*[D:0..15,F:0..255]
EFC_translation=MSB

[protocol]
name=Nokia32
irp={36k,1p,msb}<6,-10|6,-16|6,-22|6,-28>(15,-10,D:8,S:8,T:1,X:7,F:8,6,^100m,T=1-T)* [D:0..255,S:0..255,F:0..255,T@:0..1=0,X:0..127]
EFC_translation=MSB
[documentation]
The Nokia32 protocol is one variation of the RCMM 1.5 protocol developed by Philips.  RCMM refers to X as "System" and to D:2,S:4:4 as "Customer"
Parameters has been taken from http://www.sbprojects.com/knowledge/ir/rcmm.php.

[protocol]
name=NRC16

[protocol]
name=NRC17
UEI_protocol=00BD
irp={500,38k,25%}<-1,1|1,-1>(1,-5,1:1,254:8,255:8,-28, (1,-5,1:1,F:8,D:8,-220)+, 1,-5,1:1,254:8,255:8,-200)[D:0..255,F:0..255]
[documentation]
Taken from http://www.hifi-remote.com/forums/viewtopic.php?t=1044, John Fine's contribution (fixed), modified for the setup in http://www.sbprojects.com/knowledge/ir/nrc17.php

[protocol]
name=OrtekMCE
#usable=no
UEI_protocol=not known.
#irp={38.6k,480}<1,-1|-1,1>(4,-1,D:5,P:2,F:6,C:4,-48m)+
irp={38.6k,480}<1,-1|-1,1>([P=0][P=1][P=2],4,-1,D:5,P:2,F:6,C:4,-48m)+{C=3+#D+#P+#F}[D:0..31,F:0..63]
#irp={38.6k,480}<1,-1|-1,1>((P=0,4,-1,D:5,P:2,F:6,C:4,-48m), (P=1,4,-1,D:5,P:2,F:6,C:4,-48m)+, (P=2,4,-1,D:5,P:2,F:6,C:4,-48m)){C=3+D:1+D:1:1+D:1:2+D:1:3+D:1:4+P:1+P:1:1+ F:1+F:1:1+F:1:2+F:1:3+F:1:4+F:1:5} [D:0..31,F:0..63]
EFC_translation=6-bit LSB comp
[documentation]
The <A href="#repeat">repeat frames</A> are not all identical. P is a
position code: 0 for the start frame of a repeat sequence, 2 for the
end frame and 1 for all frames in between. C is a checksum, 3 more
than the number of 1 bits in D, P, F together.  DecodeIR v2.37 and
later check P and will report in the Misc field if either the start or
end frame, or both, is/are missing.

[protocol]
name=PaceMSS
irp={38k,630,msb}<1,-7|1,-11>(1,-5,1,-5,T:1,D:1,F:8,1,^120m)* [D:0..1,F:0..255,T:0..1]
EFC_translation=Not available in this version of DecodeIr
[documentation]
This is a moderately robust protocol, but <A href="#spurious">spurious decodes</A> are still possible.

[protocol]
name=Panasonic
UEI_protocol=001F or 00C9 or 00CD
irp={37k,432}<1,-1|1,-3>(8,-4,2:8,32:8,D:8,S:8,F:8,(D^S^F):8,1,-173)* [D:0..255,S:0..255,F:0..255]
EFC_translation=LSB comp
[documentation]
Panasonic protocol is the most commonly seen member of the Kaseikyo family

OEM_code1 is 2 and OEM_code2 is 32 (or DecodeIr won't display the name
as "Panasonic").  So those values in KM or RM can be changed from the
default 2 and 32 only when using the Panasonic entry in KM or RM to
produce some Kaseikyo variant OTHER THAN Panasonic. When creating a
Panasonic upgrade, don't change those from the default values.

[protocol]
name=Panasonic2
irp={37k,432}<1,-1|1,-3>(8,-4,2:8,32:8,D:8,S:8,X:8,F:8,(D^S^X^F):8,1,-173)* [D:0..255,S:0..255,F:0..255,X:0..255]

[protocol]
name=Panasonic_Old
#usable=no
UEI_protocol=0000 or 0087
irp={57.6k,833}<1,-1|1,-3>(4,-4,D:5,F:6,~D:5,~F:6,1,-44m)* [D:0..31,F:0..63]
EFC_translation=6-bit LSB comp with 2-bit mini-combo
[documentation]
Lists three different EFCs because this protocol is a <A href="#mini combo">mini combo</A>.

[protocol]
name=PCTV
#irp={38.4k,832}<0,-1|1,-0>(2,-8,1,D:8,F:8,2,-???) [D:0..255,F:0..255]
irp={38.4k,832}<-1|1>(2,-8,1,D:8,F:8,2,-100m) [D:0..255,F:0..255]

[protocol]
name=pid-0001
UEI_protocol=0001
irp= {0k,msb}<24,-9314|24,-13486>(24,-21148,(F:5,1,-28m)+)[F:0..31]
EFC_translation=5-bit MSB comp
[documentation]
As of version 8.31 KM has seriously wrong OBC translation for pid-0001, so use only EFC's with KM.

[protocol]
name=pid-0003
UEI_protocol=0003
irp= {40.2k,389}<2,-2|3,-1>(F:8,~F:8,^102m)*[F:0..255]
EFC_translation=LSB

[protocol]
name=pid-0004
UEI_protocol=0004
irp= {0k,msb}<12,-130|12,-372>(F:6,12,-27m)*[F:0..63]
EFC_translation=6-bit MSB comp

[protocol]
name=pid-0083
UEI_protocol=0083
EFC_translation=5-bit MSB comp
irp={42.3k, 3000}<1,-3,1,-7|1,-7,1,-3>(F:5,1,-27)*[F:0..31]
[documentation]
This protocol is a very limited design.  We have seen it used only in
the UEI setup code TV/0159, which is for some TVs brand named Fisher,
Sanyo and Sears.  It is not likely that any other code set uses this
protocol.  So if you get a correct decode of pid-0083 you probably
have a TV that can be controlled by the TV/0159 setup code.

As of version 8.31, KM does not translate OBC to EFC according to the
same rules used by DecodeIr.  RM does translate consistently with
DecodeIr, so you may find it easier to use RM.  If you use KM, you
should use the EFC number from the decode not the OBC number.
Pid-0083 protocol uses the same EFC numbering across all JP1 remotes,
so use of EFC is safe.  KM uses different OBC numbering than RM and
DecodeIr, so use of OBCs isn't safe.

[protocol]
name=Pioneer
irp={40k,564}<1,-1|1,-3>(16,-8,D:8,S:8,F:8,~F:8,1,^108m)* [D:0..255,S:0..255=255-D,F:0..255]
EFC_translation=LSB comp
[documentation]
Pioneer is distinguished from NEC2 only by frequency.  So if your
learning system does not learn frequency accurately, it won't
accurately distinguish Pioneer from NEC2.  All Pioneer signals should
have a device number in the range 160 to 175 and no subdevice.  No
NEC2 signal should fit those rules.  So you usually can determine
whether the decision (by frequency) was wrong by checking the device
numbers.

Many Pioneer commands are sent as combinations of two different
Pioneer signals.  This version of DecodeIr does not associate the two
signals together into one command. It decodes them separately. If you
get more than one of the same OBC from decoding a learned signal, that
just means the learning system failed to understand the repeat
pattern. It does not mean a two part signal. But if there are two
different OBCs (with the same or different device numbers) you have a
two part Pioneer signal.

Including a two part Pioneer signal in a KeyMove or upgrade is a
complex process that requires a good understanding of Pioneer signals
and of the Pioneer support in KM.  The signals don't vary much among
related Pioneer models.  So the best way to get an upgrade or hex cmd
including such signals is to look through existing Pioneer upgrades in
the JP1 group and find one that already includes the same (or nearly
same) signal.

[protocol]
name=Proton
UEI_protocol=005C
irp={38k,500}<1,-1|1,-3>(16,-8,D:8,1,-8,F:8,1,^63m)*[D:0..255,F:0..255]
EFC_translation=LSB comp
[documentation]
This is not a robust protocol, so <A href="#spurious">spurious decodes</A> are likely.

[protocol]
name=RC5
UEI_protocol=00E8
irp={36k,msb,889}<1,-1|-1,1>((1,~F:1:6,T:1,D:5,F:6,^114m)*,T=1-T)[D:0..31,F:0..127,T@:0..1=0]
EFC_translation=6-bit MSB comp with 2-bit mini-combo
[documentation]
Lists three different EFCs because this protocol is a <A href="#mini combo">mini combo</A>.

What we call "device" is really the "System" and what we call "OBC" is
really the "Command". If you are using ProntoEdit to create the RC5
signals directly, that GUI uses that correct (System and Command)
Philips terminology.

[protocol]
name=RC5-7F
UEI_protocol=0182
irp={36k,msb,889}<1,-1|-1,1>((1, ~D:1:5,T:1,D:5,F:7,^114m)*,T=1-T) [D:0..63,F:0..127,T@:0..1=0]
EFC_translation=7-bit MSB comp

[protocol]
name=RC5-7F-57
UEI_protocol=0182
irp={57k,msb,889}<1,-1|-1,1>(1, ~D:1:5,T:1,D:5,F:7,^114m)*[D:0..63,F:0..127,T@:0..1=0]
EFC_translation=7-bit MSB comp

[protocol]
name=RC5x
UEI_protocol=00F2
irp={36k,msb,889}<1,-1|-1,1>((1,~S:1:6,T:1,D:5,-4,S:6,F:6,^114m)*,T=1-T) [D:0..31,S:0..127,F:0..63,T@:0..1=0]
EFC_translation=NONE
[documentation]
The official (UEI) protocol executor for RC5x does not support EFC
numbers.  If you are creating an upgrade in KM or RM you should use
OBC numbers, not EFC numbers.  If you need the Hex Cmd for a KeyMove,
you should use the functions sheet of KM or RM to compute it for you
from the OBC and subdevice number.

In the functions sheet in KM you must put the subdevice number in the
byte2 column, which KM calls "unit code".

What we call "Device" is really the "System". What we call Subdevice
is really the "Command". What we call "OBC" is really the "Data". If
you are using ProntoEdit to create the RC5 signals directly, that GUI
uses that correct (System, Command and Data) Philips terminology.

[protocol]
name=RC5-?-??
[documentation]
Just ignore this decode.  It is almost certainly <A
href="#spurious">spurious</A>.  In case there is a new protocol I
don't know about yet in the family with RC5 and StreamZap, it will
decode in this form producing data to help me understand that
protocol.

[protocol]
name=RC6
UEI_protocol=0058
irp={36k,444,msb}<-1,1|1,-1>((6,-2,1:1,0:3,<-2,2|2,-2>(T:1),D:8,F:8,^107m)*,T=1-T) [D:0..255,F:0..255,T@:0..1=0]
EFC_translation=MSB
[documentation]
RC6 is the name used for the first member of the RC6 family of
protocols.  Technically this is RC6-0-16, but DecodeIr will always
display that as simply "RC6"

[protocol]
name=RC6-6-20
#usable=no
irp={36k,444,msb}<-1,1|1,-1>((6,-2,1:1,6:3,<-2,2|2,-2>(T:1),D:8,S:4,F:8,-100m)*,T=1-T)[D:0..255,S:0..15,F:0..255,T@:0..1=0]
EFC_translation=MSB
[documentation]
This protocol is commonly used in Sky and Sky+ remotes.  As of version
8.31, KM does not have built-in support for this protocol, but there
are KM format upgrade files available for Sky and Sky+ (built by an
expert who isn't limited to KM's built-in protocols). RM has built-in
support for RC6-M-20n protocol, which can be used to make Sky and Sky+
upgrades (or any other RC6-6-20 upgrades as long as the T bit is the
same for all learned signals, as it is with Sky).  To use RC6-M-20n
for RC6-6-20, you must leave the M field in RM's setup sheet with its
default value of 6, and you must set or leave the T field (if present)
to the value shown in all the decodes (which I assume will be 0).

[protocol]
name=RC6-?-??
usable=no
irp={36k,444,msb}<-1,1|1,-1>(6,-2,1:1,M:3,<-2,2|2,-2>(T:1),???:??)+
[documentation]
This is the generic form for a decode of protocols in the RC6
family. DecodeIr uses this form for all RC6 decodes, except RC6-0-16
which is displayed as simply "RC6", RC6-6-24 which is displayed as
"Replay" and some RC6-6-32 which display as MCE.

The first ? in the protocol name is the M value in the RC6 spec.  The
ending ?? represents the number of data bits in the signal.

[protocol]
name=RCA(Old)
UEI protocols: 002D(RCA(Old)) and 0114 (RCA Combo)
irp={58k,460,msb}<1,-2|1,-4>([40][8],-8,D:4,F:8,~D:4,~F:8,2,-16)[D:0..15,F:0..255]
EFC_translation=MSB
[documentation]
These are two very similar forms of RCA protocol which differ only in
that RCA(Old) has an extended lead-in and a double-length ON pulse
before the lead-out.  They are so similar that most RCA devices will
accept either.  But some RCA devices only accept the one that really
matches their own remote.  In versions of DecodeIR prior to v2.40,
RCA(Old) was decoded as a frame of RCA{1} followed usually by a frame
of RCA.  The second frame now no longer appears, so the protocol has
been renamed to correspond to that used in KM and RM.

Note (BM): One entry split into two.

[protocol]
name=RCA
UEI protocols: 00AF (RCA) and 0114 (RCA Combo)
irp={58k,460,msb}<1,-2|1,-4>(8,-8,D:4,F:8,~D:4,~F:8,1,-16)*[D:0..15,F:0..255]
EFC_translation=MSB
[documentation]
These are two very similar forms of RCA protocol which differ only in
that RCA(Old) has an extended lead-in and a double-length ON pulse
before the lead-out.  They are so similar that most RCA devices will
accept either.  But some RCA devices only accept the one that really
matches their own remote.  In versions of DecodeIR prior to v2.40,
RCA(Old) was decoded as a frame of RCA{1} followed usually by a frame
of RCA.  The second frame now no longer appears, so the protocol has
been renamed to correspond to that used in KM and RM.

Note (BM): One entry split into two.

[protocol]
name=RCA-38
UEI_protocol=not known
irp={38.7k,460,msb}<1,-2|1,-4>(8,-8,D:4,F:8,~D:4,~F:8,1,-16)*[D:0..15,F:0..255]
EFC_translation=MSB
[documentation]
These are recently discovered variants of the RCA protocol.  They
differ from RCA and RCA(Old) only in the frequency, which is 38.7kHz
instead of the standard 58kHz.

Note (BM): One entry split into two.

[protocol]
name=RCA-38(Old)
UEI_protocol=not known
irp={38.7k,460,msb}<1,-2|1,-4>([40][8],-8,D:4,F:8,~D:4,~F:8,2,-16)[D:0..15,F:0..255]
EFC_translation=MSB
[documentation]
These are recently discovered variants of the RCA protocol.  They
differ from RCA and RCA(Old) only in the frequency, which is 38.7kHz
instead of the standard 58kHz.

Note (BM): One entry split into two.

[protocol]
name=RECS80
irp=RECS80-0045{}[D:0..7,F:0..63, T@:0..1=0]

[protocol]
name=RECS80-0045
irp={38k,158,msb}<1,-31|1,-47>(1:1,T:1,D:3,F:6,1,-45m)* [D:0..7,F:0..63, T@:0..1=0]


[protocol]
name=RECS80-0068
irp={33.3k,180,msb}<1,-31|1,-47>(1:1,T:1,D:3,F:6,1,^138m)* [D:0..7,F:0..63, T@:0..1=0]

[protocol]
name=RECS80-0090
irp={0k,158,msb}<1,-31|1,-47>(1:1,T:1,D:3,F:6,1,^138m)* [D:0..7,F:0..63, T@:0..1=0]

[protocol]
name=RECS80
usable=no
UEI_protocol=0045, 0068, 0090 or ???
IRP notation for 0045: {38k,158,msb}<1,-31|1,-47>(1:1,T:1,D:3,F:6,1,-45m)+
IRP notation for 0068: {33.3k,180,msb}<1,-31|1,-47>(1:1,T:1,D:3,F:6,1,^138m)+
EFC_translation=6-bit MSB comp
[documentation]
RECS80 is a family of related protocols with the same structure, but
different timing.

These are moderately non robust protocols, so <A
href="#spurious">spurious decodes</A> are possible.

The timing differences are not definitive enough for DecodeIr to
identify which RECS80 version is which.  Instead it displays the
timing information in the "Misc" field of the output.  That will be
three numbers formatted as in this example: (157/5048/7572).

Using those three numbers and the frequency, you should be able to
determine whether the signals fit the 0045 version, the 0068 version,
the 0090 version or none of them.  You should look at all the learned
signals for your device together when doing that.  A single device
won't mix versions of RECS80, so any differences in frequency or
timing between learns is due to the IR learning process, not due to
any differences among the correct signals.  You should find one RECS80
version that is a good enough fit for all signals of the device.

For 0045,

<ul>
<li>frequency should be between 37000 and 39000</li>
<li>first timing number between 100 and 200</li>
<li>second timing number between 4500 and 5500</li>
<li>third timing number between 6800 and 8300</li>
</ul>

For 0068,
<ul>
<li>frequency should be between 32300 and 34300</li>
<li>first timing number between 130 and 250</li>
<li>second timing number between 5100 and 6300</li>
<li>third timing number between 7700 and 9500</li>
</ul>

For 0090,
<ul>
<li>frequency should be 0</li>
<li>first timing number between 0 and 40</li>
<li>second timing number between 4500 and 5500</li>
<li>third timing number between 6800 and 8300</li>
</ul>

You may find decodes that don't quite fit either.  If it almost fits,
it may be worth testing to see if it works, but it's most unlikely to
work if the second timing number is above the suggested max or the
third timing number is below the suggested min.  For example, I found
a decode with frequency 41879 and timing numbers (132,5092,7652).  The
three timing numbers are perfect for protocol 0045, but the frequency
is quite wrong.  I have no device to test with, but my guess is that
it would work anyway.  For protocol 0068, the third number 7652 is
below the minimum of 7700 making it quite unlikely to work.  I found a
different device with frequency 33333 and timing (450,5770,8656).  For
0068 all but the first number are perfect and I would be quite
surprised if it didn't work.  For 0045 the second number 5770 is too
high for the max of 5500, so it's unlikely to work.

The decodes for RECS80 all report EFCs for protocol 0045.  These are
not correct EFCs if you select a protocol other than 0045, so it is
better to use OBC numbers when creating a JP1 upgrade based on these
decodes.

[protocol]
name=Replay
#usable=no
UEI_protocol=0092
irp={36k,444,msb}<-1,1|1,-1>(6,-2,1:1,6:3,<-2,2|2,-2>(T:1),D:8,S:8,F:8,-100m/*???*/)*[D:0..255,S:0..255,F:0..255,T@:0..1=0]
EFC_translation=MSB
[documentation]
Replay is a member of the RC6 family.  Technically it is RC6-6-24, but
DecodeIr will always display the name as "Replay".  ProntoEdit calls
this protocol "RC6 mode 6A" and KM has it under the alternate name
"RC-6a" as well as its primary name "Replay".  RM has it under the
alternate name "RC6-M-24n" as well as its primary name "Replay".

DecodeIr's Subdevice field in  is called "unit" in KM

In ProntoEdit, DecodeIr's "Device" is called "Customer Code";
DecodeIr's "Subdevice" is called "System"; and DecodeIr's "OBC" is
called "Command".

[protocol]
name=Revox
irp={0k,15u}<1,-9|1,-19>(1,-29,0:1,D:4,F:6,1,-29,1,-100285u)*[D:0..15,F:0..63]
#irp={0k,15u}<1,-9|1,-19>(1:1,-10,0:1,D:4,F:6,1:1,-10,1:1,-100m)+[D:0..15,F:0..63]
#irp={67k,15u}<1,-9|1,-19>(1:1,-10,0:1,D:4,F:6,1:1,-10,1:1,-100m)+[D:0..15,F:0..63]

[documentation]
Revox uses no modulation, but many remotes will not accept the 0100 Pronto format.
Using 67KHz may provide a usable signal, since the period of 67KHz is 15uSec.
The IRP given here uses the 67KHz approximation.

[protocol]
name=Samsung20
#usable=no
irp={38.4k,564}<1,-1|1,-3>(8,-8,D:6,S:6,F:8,1,^100m)*[D:0..63,S:0..63,F:0..255]
EFC_translation=LSB
[documentation]
This is a moderately robust protocol, but <A href="#spurious">spurious decodes</A> are still possible.

[protocol]
name=Samsung36
UEI_protocol=01B5
irp={38k,500}<1,-1|1,-3>(9,-9,D:8,S:8,1,-9,E:4,F:8,-68u,~F:8,1,-118)*[D:0..255,S:0..255,F:0..255,E:0..15]
EFC_translation=LSB
TODO=the -68u gap is a bitch when recognizing.

[protocol]
name=Sampo
irp={38.4k, 833}<1,-1|1,-3>(4,-4,D:6,F:6,S:6,~F:6,1,-39)*[D:0..63,S:0..63,F:0..63]
EFC_translation=Not available in this version of DecodeIr
[documentation]
This is a moderately robust protocol, but <A href="#spurious">spurious decodes</A> are still possible.

[protocol]
name=ScAtl-6
UEI_protocol=0078
irp={57.6k,846}<1,-1|1,-3>(4,-4,D:6,F:6,~D:6,~F:6,1,-40)*[D:0..63,F:0..63]
EFC_translation=6-bit LSB comp
[documentation]
ScAtl-6 is distinguished from Emerson only by frequency. So if you are
using a learning system that doesn't record the frequency accurately,
then DecodeIr can't accurately select between Emerson and ScAtl-6.

In KM, this protocol is named "Scientific Atlanta".  Most Scientific
Atlanta cable tuners use Panasonic_Old protocol, not this protocol.

[protocol]
name=Sejin-M-38
alt_name=Sejin-M-56
usable=no
UEI_protocol=0161
[documentation]
IRP notation for Sejin-<i>M</i>-38: {38.8k,310,msb}<-1|1>(<8:4|4:4|2:4|1:4>(3,3:2,Dx:8,Fx:8,Fy:8,E:4,C:4,-L))+

IRP notation for Sejin-<i>M</i>-56: {56.3k,310,msb}<-1|1>(<8:4|4:4|2:4|1:4>(3,3:2,Dx:8,Fx:8,Fy:8,E:4,C:4,-L))+

In both cases E is a checksum seed (0 in all known examples) and C is
a checksum given by C = Dx:4 + Dx:4:4 + Fx:4 + Fx:4:4 + Fy:4 + Fy:4:4
+ E.  EFC_translation=For Sejin-1, MSB.  For Sejin-2, EFC translation
not available.

The parameter <i>M</i> is either 1 or 2. It distinguishes two styles
of this protocol that have different purposes and very different
lead-out times L.  The 8-bit parameter Dx is a signed integer.  If Dx
> 0 then the style is Sejin-1, used for normal buttons of a remote
control.  If Dx < 0 then the style is Sejin-2, used for signals of an
associated 2- or 3-button pointing device.  E is a checksum seed, E=0
in the only known examples.  The checksum formula reflects that in the
UEI executor, so is presumed correct.

The protocol parameters Dx, Fx, Fy translate into device parameters in
different ways corresponding to the different uses of the protocol.
In Sejin-1 the device parameters are a Device Code, a SubDevice code
and an OBC as is common for many protocols.  Sejin-2 has two
sub-styles. One corresponds to the displacement of a cursor or other
pointer with device parameters (X, Y) that give the horizontal and
vertical components of the displacement (and which can be positive or
negative).  The other signals Button Up or Button Down for any of the
three buttons of the pointing device.  The Misc field of the DecodeIR
output displays these device parameters for the Sejin-2 signals.  The
relationship between these and the protocol parameters is beyond the
scope of this document.  The Misc field also displays an RMOBC value
for Sejin-2 signals, which is an artificial OBC value that can be used
as input to RemoteMaster to create the signal concerned.

The protocol parameters for Sejin-1 include a bit that marks the end
frame of a <A href="#repeat">repeat sequence</A>.  DecodeIR v2.37 and
later check this and will report in the Misc field if the end frame is
missing.  This will normally be due to the key still being held when
the learning process ends, so that the end frame gets omitted from the
learned signal.  For Sejin-2 signals that represent button operations
the signal does not repeat.  A single frame is sent on button down, a
different frame is sent once on button up.  Both frames can be
detected and distinguished by DecodeIR v2.37 and later but the button
up frame will not normally be present in a learned signal.

[protocol]
name=Sharp
irp={38k,264}<1,-3|1,-7>(D:5,F:8,1:2,1,-165,D:5,~F:8,2:2,1,-165)*[D:0..31,F:0..255]
EFC_translation=LSB
[documentation]
A Sharp signal has two halves, either one of which is enough to fully
decode the information. A significant fraction of Sharp learned
signals contain just one half or have the halves separated so that
DecodeIr can't process them together. When one half is seen separate
from the other, DecodeIr will name the protocol Sharp{1} or Sharp{2}
depending on which half is decoded. Sharp, Sharp{1} and Sharp{2} all
represent the same protocol when they are correct.  But only Sharp is
robust. A Sharp{1} or Sharp{2} decode might be <A
href="#spurious">spurious</A>.

[protocol]
name=Sharp{1}
irp={38k,264}<1,-3|1,-7>(D:5,F:8,1:2,1,-165)*[D:0..31,F:0..255]
EFC_translation=LSB
[documentation]
A Sharp signal has two halves, either one of which is enough to fully
decode the information. A significant fraction of Sharp learned
signals contain just one half or have the halves separated so that
DecodeIr can't process them together. When one half is seen separate
from the other, DecodeIr will name the protocol Sharp{1} or Sharp{2}
depending on which half is decoded. Sharp, Sharp{1} and Sharp{2} all
represent the same protocol when they are correct.  But only Sharp is
robust. A Sharp{1} or Sharp{2} decode might be <A
href="#spurious">spurious</A>.

[protocol]
name=Sharp{2}
irp={38k,264}<1,-3|1,-7>(D:5,~F:8,2:2,1,-165)*[D:0..31,F:0..255]
EFC_translation=LSB
[documentation]
A Sharp signal has two halves, either one of which is enough to fully
decode the information. A significant fraction of Sharp learned
signals contain just one half or have the halves separated so that
DecodeIr can't process them together. When one half is seen separate
from the other, DecodeIr will name the protocol Sharp{1} or Sharp{2}
depending on which half is decoded. Sharp, Sharp{1} and Sharp{2} all
represent the same protocol when they are correct.  But only Sharp is
robust. A Sharp{1} or Sharp{2} decode might be <A
href="#spurious">spurious</A>.

[protocol]
name=SharpDVD
UEI_protocol=00F8
irp={38k,400}<1,-1|1,-3>(8,-4,170:8,90:8,15:4,D:4,S:8,F:8,E:4,C:4,1,-48)* \
{C = D ^ S:4:0 ^ S:4:4 ^ F:4:0 ^ F:4:4 ^ E:4} \
[D:0..15,S:0..255,F:0..255,E:0..15=1]
EFC_translation=LSB comp
[documentation]
SharpDVD is the member of the Kaseikyo family with OEM_code1=170 and OEM_code2=90.
E=1 in all instances seen so far.

[protocol]
name=SIM2
irp={38.8k,400}<3,-3|3,-7>(6,-7,D:8,F:8,3,-60m)[D:0..255,F:0..255]
# only D%2==0

[protocol]
name=Solidtek16
usable=yes
irp={38k}<-624,468|468,-624>(S=0,(1820,-590,0:1,D:4,F:7,S:1,C:4,1:1,-143m,S=1)3) {C= F:4:0 + F:3:4 + 8*S } [D:0..15, F:0..127]
[documentation]
This is a keyboard protocol.  The make/break bit is decoded into the subdevice field.

[protocol]
name=Solidtek20
usable=no
irp={38k}<-624,468|468-624>(1820,-590,0:1,D:4,S:6,F:6,C:4,1:1,-???)
[documentation]
This is a mouse protocol.  The button press info is included in the
Device field.  The horizontal motion is in the Subdevice field, and
the vertical motion is in the OBC field.

The decode interface does not support returning negative Subdevice or
OBC.  So negative motions are represented by adding 64 to them.  The
numbers 1 to 31 represent positive motion.  The numbers 32 to 63 are
each 64 larger than the true negative motion, so 63 represents -1 and
32 represents -32.

[protocol]
name=Somfy
#irp={35.7k}<308,-881|669,-520>(2072,-484,F:2,D:3,C:4,-2300)+
irp={35.7k}<308,-881|669,-520>(2072,-484,F:2,D:3,C:4,-2300)*{C = F*4 + D + 3}[F:0..3,D:0..7]
[documentation]
C is reported as SubDevice.  It is probably a check nibble {C = F*4 + D + 3}.
F = 1 for UP or 2 for DOWN.
D = 1, 2 or 3 for the three observed devices, or D = 0 to control all devices together.

[protocol]
name=Sony8
irp={40k,600}<1,-1|2,-1>(4,-1,F:8,^45m)[F:0..255]
EFC_translation=LSB

[protocol]
name=Sony12
UEI_protocol=00CA
irp={40k,600}<1,-1|2,-1>(4,-1,F:7,D:5,^45m)*[D:0..31,F:0..127]
EFC_translation=LSB

[protocol]
name=Sony15
UEI_protocol=00CA
irp={40k,600}<1,-1|2,-1>(4,-1,F:7,D:8,^45m)*[D:0..255,F:0..127]
EFC_translation=LSB

[protocol]
name=Sony20
UEI_protocol=00DE
irp={40k,600}<1,-1|2,-1>(4,-1,F:7,D:5,S:8,^45m)*[D:0..31,S:0..255,F:0..127]
EFC_translation=LSB

[protocol]
name=StreamZap
irp={36k,msb,889}<1,-1|-1,1>(1,~F:1:6,T:1,D:6,F:6,^114m)*[D:0..63,F:0..63,T:0..1]
EFC_translation=6-bit MSB comp
[documentation]
DecodeIR V2.43 decodes this as RC5-7F
# tested skipped for exactly this reason

[protocol]
name=StreamZap-57
irp={57k,msb,889}<1,-1|-1,1>(1,~F:1:6,T:1,D:6,F:6,^114m)*[D:0..63,F:0..63,T:0..1]
EFC_translation=6-bit MSB comp
[documentation]
DecodeIR V2.43 decodes this as RC5-7F-57
# tested skipped for exactly this reason

[protocol]
name=Sunfire
irp={38k,560,msb}<1,-1|3,-1>(16,-8, D:4,F:8,~D:4,~F:8, -32)*[D:0..15,F:0..255]
EFC_translation=Not available in this version of DecodeIr

[protocol]
name=TDC-38
irp={38k,315,msb}<-1,1|1,-1>(1:1,D:5,S:5,F:7,-89m)*[D:0..31,S:0..31,F:0..127]
EFC_translation=7-bit MSB.
[documentation]
There are two variants of this protocol, with different frequencies
but with the same number of carrier cycles in each burst, which makes
the duration of a burst also differ.  TDC-38 has a 38kHz carrier and
is used by Danish TDC IPTV.  TDC-56 has a 56.3kHz carrier and is used
by Italian ALICE Home TV box.  These implementations effectively use a
6-bit OBC as bit 0 of F is always the complement of bit 1, but there
are other implementations which do not follow that pattern.

[protocol]
name=TDC-56
irp={56.3k,213,msb}<-1,1|1,-1>(1:1,D:5,S:5,F:7,-89m)*[D:0..31,S:0..31,F:0..127]
EFC_translation=7-bit MSB.
[documentation]
There are two variants of this protocol, with different frequencies
but with the same number of carrier cycles in each burst, which makes
the duration of a burst also differ.  TDC-38 has a 38kHz carrier and
is used by Danish TDC IPTV.  TDC-56 has a 56.3kHz carrier and is used
by Italian ALICE Home TV box.  These implementations effectively use a
6-bit OBC as bit 0 of F is always the complement of bit 1, but there
are other implementations which do not follow that pattern.

[protocol]
name=Teac-K
UEI_protocol=00BB

irp={37k,432}<1,-1|1,-3>(8,-4,67:8,83:8,X:4,D:4,S:8,F:8,T:8,1,-100,(8,-8,1,-100)+) {T=D+S:4:0+S:4:4+F:4:0+F:4:4} [D:0..15,S:0..255,F:0..255,X:0..15=1]
EFC_translation=LSB comp, two parts
[documentation]
Teac-K is the member of the Kaseikyo family with OEM_code1=67 and OEM_code2=83.

Teac-K uses different repeat rules and a different check byte than
other Kaseikyo protocols.

00BB requires 2-byte hex commands.  DecodeIr returns both hex cmd
bytes through the interface that usually means one or the other (for
mini combos) but in this case it means both.

This protocol signals repeats by the use of <A href="#repeat">dittos</A>.

[protocol]
name=Thomson
UEI_protocol=004B
irp={33k,500}<1,-4|1,-9>((D:4,T:1,D:1:5,F:6,1,^80m)+,T=1-T)[D:0..63,F:0..63,T@:0..1=0]
irp={33k,500}<1,-4|1,-9>((D:4,T:1,D:1:4,F:6,1,^80m)*,T=1-T)[D:0..31,F:0..63,T@:0..1=0]
# FIXME: BM: Bit 5 in D is ignored!!!???
EFC_translation=6-bit LSB comp, or that prepended with extra device bit.
[documentation]
This is not a robust protocol, so <A href="#spurious">spurious decodes</A> are likely.

DecodeIR2.42 deprecates Thompson (5 bits of device, and 6 bits of
function) and reports these signals as Thompson7 (4 bits of device and
7 bits of function).

Thomson includes a <A HREF="#toggle">toggle bit</A> so using learned
signals will have operational problems.  You should use <A
HREF="#jp1">KeyMoves or Upgrades</A> based on the decoded values,
rather than continue to use the learned signals.

There are two different variants of UEI protocol 004B which have
different EFC numbering. The decode lists both possible EFCs so you
could experiment to discover which is right for your model. But, if
you are creating an upgrade (rather than just KeyMoves) it is better
to use RM and use the OBC numbers from the decode (which are stable
across models of JP1 remote). As of version 8.31, KM does not have
support for Thomson protocol, so if you must make an upgrade in KM you
need to use pid:004B. For the URC-8040 and 8060 the second decoded EFC
should be right and the OBC values in KM should be wrong. For most
(maybe all) other models, the first decoded EFC should be right and
KM's default EFC to OBC translation should also be right.

[protocol]
name=Thomson7
UEI_protocol=004B
irp={33k,500}<1,-4|1,-9>((D:4,T:1,F:7,1,^80m)*,T=1-T) [D:0..15,F:0..127,T@:0..1=0]
EFC_translation=7-bit LSB comp
[documentation]
DecodeIR2.42 deprecates Thompson (5 bits of device, and 6 bits of
function) and reports these signals as Thompson7 (4 bits of device and
7 bits of function).

[protocol]
name=Tivo
#irp={38.4k,564}<1,-1|1,-3>(16,-8,133:8,48:8,F:8,U:4,~F:4:4,1,-78,(16,-4,1,-173)*) [F:0..255,U:0..15]
irp={38.4k,564}<1,-1|1,-3>(16,-8,D:8,S:8,F:8,U:4,~F:4:4,1,-78,(16,-4,1,-173)*) [D:133..133=133,S:48..48=48,F:0..255,U:0..15]
EFC_translation=LSB comp

[protocol]
name=Velleman
irp={38k,msb}<700,-5060|700,-7590>(1:1,T:1,D:3,F:6,1,-55m)* [D:0..7,F:0..31,T@:0..1=0]
EFC_translation=6-bit MSB comp
[documentation]
Very similar to RECS80-0045, except on duration is longer

[protocol]
name=Velodyne
irp={38k,136,msb}<210u,-760u>\
(<0:1|0:1,-1|0:1,-2|0:1,-3|0:1,-4|0:1,-5|0:1,-6|0:1,-7|0:1,-8|0:1,-9|0:1,-10|0:1,-11|0:1,-12|0:1,-13|0:1,-14|0:1,-15>(T=0,(S:4:4,~C:4,S:4,15:4,D:4,T:4,F:8,210u,-79m,T=8)+)) \
{C=(8+S:4+S:4:4+15+D+T+F:4+F:4:4)&15} \
[D:0..15,S:0..255,F:0..255]
[documentation]
Velodyne is a close relative of XMP.

[protocol]
name=Viewstar
UEI_protocol=0021
#irp={50.5k,337}<1,-8|1,-5>(F:5,1,-17)+[F:0..31]
irp={50.5k,337}<1,-8|1,-5>(~F:5,1,-17)*[F:0..31]
EFC_translation=5-bit LSB comp
[documentation]
This is not a robust protocol, so <A href="#spurious">spurious decodes</A> are likely.

[protocol]
name=X10
UEI_protocol=01DF
irp={40.8k,565}<2,-12|7,-7>(7,-7,F:5,~F:5,21,-7)*[F:0..31]
EFC_translation=LSB of 2*OBC+1
[documentation]
These are two variants of the same Home Automation protocol.  They
differ in that X10.<i>n</i> has a distinctive start frame that carries
a sequence number, the <i>n</i> of the protocol name, in addition to
the OBC.  The repeat frames, and all frames of the X10 version, only
carry the OBC.  The value of <i>n</i> runs from 0 to 15 (or some lower
value) and then restarts again at 0.  It is incremented on each
successive keypress.  A valid X10.<i>n</i> signal must have at least
one repeat frame.  If this is missing then the Misc column shows
"invalid signal".

RemoteMaster has a single protocol, named X10 with PID 003F, that
sends X10.<i>n</i> signals.  This is the same as the UEI protocol with
that PID.  There is no control over the value of <i>n</i>, this is
handled automatically by the remote.  The newer UEI protocol, with PID
01DF, sends X10 signals.

[protocol]
name=X10.n
UEI_protocol=003F
irp={40.8k,565}<2,-12|7,-7>(F:5,N:-4,21,-7,(7,-7,F:5,~F:5,21,-7)+)[F:0..31,N:0..15]
EFC_translation=LSB of 2*OBC+1
[documentation]
These are two variants of the same Home Automation protocol.  They
differ in that X10.<i>n</i> has a distinctive start frame that carries
a sequence number, the <i>n</i> of the protocol name, in addition to
the OBC.  The repeat frames, and all frames of the X10 version, only
carry the OBC.  The value of <i>n</i> runs from 0 to 15 (or some lower
value) and then restarts again at 0.  It is incremented on each
successive keypress.  A valid X10.<i>n</i> signal must have at least
one repeat frame.  If this is missing then the Misc column shows
"invalid signal".

RemoteMaster has a single protocol, named X10 with PID 003F, that
sends X10.<i>n</i> signals.  This is the same as the UEI protocol with
that PID.  There is no control over the value of <i>n</i>, this is
handled automatically by the remote.  The newer UEI protocol, with PID
01DF, sends X10 signals.

[protocol]
name=XMPMeta
irp={38k,136,msb}<210u,-760u> \
( \
<0:1|0:1,-1|0:1,-2|0:1,-3|0:1,-4|0:1,-5|0:1,-6|0:1,-7|0:1,-8|0:1,-9|0:1,-10|0:1,-11|0:1,-12|0:1,-13|0:1,-14|0:1,-15> \
  (T=0, \
     (S:4:4,C1:4,S:4,15:4,OEM:8,D:8,210u,-13.8m,S:4:4,C2:4,T:4,S:4,FF:16,210u,-80.4m,T=8)+ \
  ) \
) \
{ C1=-(S+S::4+15+OEM+OEM::4+D+D::4), \
  C2=-(S+S::4+T+FF+FF::4+FF::8+FF::12) \
} \
[FF:0..65535,D:0..255,S:0..255,OEM:0..255=68]

[protocol]
name=XMP
irp=XMPMeta{FF=F}[F:0..65535,D:0..255,S:0..255,OEM:0..255=68]
UEI_protocol=016C
[documentation]
IRP notation (without final frame): {38k,136,msb}<210,-760>(<0:1|0:1,-1|0:1,-2|0:1,-3|0:1,-4|0:1,-5|0:1,-6|0:1,-7|0:1,-8|0:1,-9|0:1,-10|0:1,-11|0:1,-12|0:1,-13|0:1,-14|0:1,-15>(T=0,(S:4:4,C1:4,S:4,15:4,OEM:8,D:8,210u,-13.8m,S:4:4,C2:4,T:4,S:4,F:16,210u,-80.4m,T=8)+)){C1=-(S+S::4+15+OEM+OEM::4+D+D::4),C2=-(S+S:4+T+F+F::4+F::8+F::12)}
IRP notation (with final frame):{38k,136,msb}<210,-760>(<0:1|0:1,-1|0:1,-2|0:1,-3|0:1,-4|0:1,-5|0:1,-6|0:1,-7|0:1,-8|0:1,-9|0:1,-10|0:1,-11|0:1,-12|0:1,-13|0:1,-14|0:1,-15>(T=0,((S:4:4,C1:4,S:4,15:4,OEM:8,D:8,210u,-13.8m,S:4:4,C2:4,T:4,S:4,F:16,210u,[-80.4m][-80.4m][-13.8m],T=8)+,T=9)2)){C1=-(S+S::4+15+OEM+OEM::4+D+D::4),C2=-(S+S:4+T+F+F::4+F::8+F::12)}

The Device code is D, the SubDevice code is S and there are two OBC
values.  OBC1 is the high byte of F, OBC2 is the low byte of F. The
OEM code is normally 0x44 and is reported in the Misc field only if it
has a different value. The XMP-1 protocol is XMP with OBC2 = 0.  The
OBC field in DecodeIR then shows OBC1. The XMP-2 protocol is XMP with
OBC1 = 0.  The OBC field in DecodeIR then shows OBC2.

This protocol has a 4-bit toggle T that is 0 for the first frame and
normally 8 for all repeat frames.  There is, however, a variant in
which a further frame with T=9 is sent after the button is released,
separated from the preceding frame by the short leadout of 13.8m that
is used between two half-frames rather than the long lead-out of 80.4m
used at the end of all other frames.  When this frame is detected then
the Misc field displays "With Final Frame".  For this to be shown in a
learned signal, the button must be released before the learning
process times out, so a short button press is needed.

These are problem decodes because JP1 remotes don't typically learn
these signals accurately enough for a correct decode.  NG Prontos also
do a rotten job of learning these signals.  Older Prontos seem to do
fairly well.  DecodeIR v2.40 includes algorithms that attempt to
reconstruct a valid XMP signal from a corrupt learn, but it is
impossible to correct all learning errors and there can be no
certainty that a reconstruction is actually correct.

In a correctly learned or fully reconstructed signal there will be an
"XMP", "XMP-1" or "XMP-2" decode with device, subdevice and OBC values
that can be used with RemoteMaster or any similar program to
regenerate a clean signal.  The Misc field shows which algorithms, if
any, have been applied, as a list in brackets after any decode data in
this field.  There are notes below on the reliability of the various
algorithms.  When the protocol shows as (unqualified) XMP, both OBC
values are non-zero.  The OBC and Hex fields show OBC1.  The
corresponding values for OBC2 are shown in the Misc field.

The learned signal itself will certainly not be valid if any
reconstruction algorithms have been applied and it may not be so even
if it has been decoded without reconstruction.  The possible algorithm
indicators in the Misc field are as follows:

<ul>
<li>End (= Endpoint):  The lead-out burst is missing and has been inserted.  This is almost certainly correct.
<li>Rec (= Recovery):  Look-ahead has been used to recover a missing burst from the following repeat frame.  This is very likely to be correct.
<li>Cor (= Correction): Two bursts have been coalesced in the learning process, e.g. those for hex digits C and D, causing a C to appear as D or vice versa.
The error has been identified and corrected.  This is probably correct.
<li>Cal (= Calculated): A missing digit has been calculated from a checksum.  The digit is probably correct but it may be in the wrong place.  The most likely error in the reconstruction is that the two digits of the OBC are the wrong way round.
<li>Cal2 (= Calculated 2)  Two consecutive missing zero digits have been identified, corresponding to a zero OBC.  When this happens, the signal will always be shown as XMP-1.  The most likely error in the reconstruction is that it should actually be XMP-2.
</ul>

If a learned signal is good enough to be recognised as XMP but not
good enough to be fully reconstructed, the protocol will display with
a name of the form XMP:136.218-0F0F441A0A800F00

In IR.exe you'll need to widen the Protocol column to see the whole
thing. This represents intermediate data from an unsuccessful attempt
to decode a XMP signal.

The number in the position where the 136 is in this example represents
the time scale.  A number (like this example) that is near 137 is
reasonable.  A number much further from 137 indicates a more serious
learning or decoding problem.  The number in the position where the
.218 is in this example (it is not part of the 136) represents the
level of inconsistency in the individual hex digit decodes.  A value
greater than .100 means the hex digits aren't very reliable.

The hex string, where the 0F0F441A0A800F00 is, is the decoded data.
At least one digit is almost certainly wrong or the whole decode
wouldn't be displayed in this form.  With a JP1 learning remote, the
most common errors are that a digit is actually missing, in which case
the string will have fewer than 16 hex digits, or that two or more
digits which are decoded the same are actually different, so some of
them are correct and some are one value higher or lower.  Although the
reconstruction algorithms attempt to correct these types of errors, it
is not always possible.  In this example I happen to know the correct
signal.  One of the three F's is really an E and one of the two A's is
really a 9.  The correct string is 0E0F441A09800F00.

Almost all examples we've seen start with "0E0F441A0" or "060F44120".
But we've also seen upgrades from UEI for "0D1F441A0" and "0C2F441A0"
and "0B3F441A0".  The last 4 digits of the whole 16 digit string (if
they are correct) represent the Hex command needed to reproduce the
signal in a JP1 upgrade or KeyMove.  DecodeIR shows them as two 8-bit
OBC values, as described with the IRP notation above.


[protocol]
name=XMP-1
irp=XMPMeta{FF=F*256}[D:0..255, S:0..255, F:0..255, OEM:0..255=68]

[protocol]
name=XMP-2
irp=XMPMeta{FF=F:8}[D:0..255, S:0..255, F:0..255, OEM:0..255=68]

[protocol]
name=XMPFinalFrameMeta
irp={38k,136,msb}<210u,-760u> \
( \
<0:1|0:1,-1|0:1,-2|0:1,-3|0:1,-4|0:1,-5|0:1,-6|0:1,-7|0:1,-8|0:1,-9|0:1,-10|0:1,-11|0:1,-12|0:1,-13|0:1,-14|0:1,-15> \
  (T=0, \
     ((S:4:4,C1:4,S:4,15:4,OEM:8,D:8,210u,-13.8m,S:4:4,C2:4,T:4,S:4,FF:16,210u,[-80.4m][-80.4m][-13.8m],T=8)+,T=9) \
  ) \
) \
{ C1=-(S+S::4+15+OEM+OEM::4+D+D::4), \
  C2=-(S+S::4+T+FF+FF::4+FF::8+FF::12) \
} \
[FF:0..65535,D:0..255,S:0..255,OEM:0..255=68]

[protocol]
name=XMPff
irp=XMPFinalFrameMeta{FF=F}[F:0..65535,D:0..255,S:0..255,OEM:0..255=68]
UEI_protocol=016C

[protocol]
name=XMPff-1
irp=XMPFinalFrameMeta{FF=F*256}[D:0..255, S:0..255, F:0..255, OEM:0..255=68]

[protocol]
name=XMPff-2
irp=XMPMeta{FF=F:8}[D:0..255, S:0..255, F:0..255, OEM:0..255=68]


[protocol]
name=XX

[protocol]
name=Zaptor-36
irp={36k,330,msb}<-1,1|1,-1>([T=0][T=0][T=1],8,-6,2,D:8,T:1,S:7,F:8,E:4,C:4,-74m){C = (D:4+D:4:4+S:4+S:3:4+8*T+F:4+F:4:4+E)&15}[D:0..255,S:0..127,F:0..127,E:0..15]
EFC_translation=MSB
[documentation]
where T=0 for all frames except the last, T=1 for last frame, E is a checksum seed.
A protocol so far seen only in the Motorola Zaptor.

[protocol]
name=Zaptor-56
irp={56k,330,msb}<-1,1|1,-1>([T=0][T=0][T=1],8,-6,2,D:8,T:1,S:7,F:8,E:4,C:4,-74m){C = (D:4+D:4:4+S:4+S:3:4+8*T+F:4+F:4:4+E)&15}[D:0..255,S:0..127,F:0..127,E:0..15]
EFC_translation=MSB
[documentation]
where T=0 for all frames except the last, T=1 for last frame, E is a checksum seed.
A protocol so far seen only in the Motorola Zaptor.

[protocol]
name=Zenith
UEI_protocol=0022
irp={40k,520,msb} \
<1,-10|1,-1,1,-8>(S:1, \
    <1:2|2:2>(F:D), \
    -90m)* \
[S:0..1,F:0..255,D:5..8]
EFC_translation=MSB
[documentation]

An unusual protocol, in that the number of bits in the function code
is variable.  It is represented in DecodeIR as the device code.  There
are also two lead-in styles, decoded as subdevice values 0 and 1.
Style 1 aka "double-start" is usually used in TV's, other appliances
use 0 aka "single start".  If the device code is >8 then the bytes
given in the Misc field as E = ... follow the OBC in the function code
value.

[protocol]
name=?1-??-??-??
[documentation]
An experimental decode I added based on the thread at
<A href="http://www.hifi-remote.com/forums/viewtopic.php?p=19168#19168">JP1-forum"Unknown Protocol"</A>

[protocol]
name=canon
irp={33k,1}<16p,-240p|16p,-175p>(F:1)2[F:0..1]
[documentation]
IR protocol for many Canon cameras. With F=0 it triggers immediately,
F=1 it triggers after a delay of approximately two seconds.

[protocol]
name=arctech
irp={0k,388}<1,-3|3,-1> \
(<0:2|2:2>((D-1):4,(S-1):4),40:7,F:1,0:1,-10.2m)* \
[D:1..16,S:1..16,F:0..1]
[documentation]
Protocol used by several manufacturers of 433MHz RF controlled
switches, like Intertechno, Duewi, ELRO, and the URC light control
kit, and many other. Appears to be introduced by the Taiwanese firm ARC
Technology, www.arctech.com.tw.  These codes correspond to switches
with code wheels, having an "House number" ranging from "A" to "P", in the
IRP above corresponding to D=1 up to 16 for "P". They also have an "Address",
ranging from 1 to 16, corresponding to the parameter "S" in the IRP. Note that
e.g. Intertechno makes switches "with" and "without" code wheels, the
latter having a much larger addressing space, and unfortunately cannot
be controlled by the present protocol. F=0 is the power off command,
F=1 the power on command. The power on command is also used for
dimming, both up and down.

In the URC-7781 the setup codes 2200,2201, up to 2215 correspond to
this protocol, 2200 for house A etc. up to 2215 for house "P".

[protocol]
name=arctech-38
irp={38k,388}<1,-3|3,-1> \
(<0:2|2:2>((D-1):4,(S-1):4),40:7,F:1,0:1,-10.2m)* \
[D:1..16,S:1..16,F:0..1]
[documentation]
Protocol used by several manufacturers of 433MHz RF controlled
switches, like Intertechno, Duewi, ELRO, and the URC light control
kit, and may other. Appears to be introduced by the Taiwanese firm ARC
Technology, www.arctech.com.tw.  These codes correspond to switches
with code wheels, having an "House number" ranging from "A" to "P", in the
IRP above corresponding to D=1 up to 16 for "P". They also have an "Address",
ranging from 1 to 16, corresponding to the parameter "S" in the IRP. Note that
e.g. Intertechno makes switches "with" and "without" code wheels, the
latter having a much larger addressing space, and unfortunately cannot
be controlled by the present protocol. F=0 is the power off command,
F=1 the power on command. The power on command is also used for
dimming, both up and down.

In the URC-7781 the setup codes 2200,2201, up to 2215 correspond to
this protocol, 2200 for house A etc. up to 2215 for house "P".

#[protocol]
#name=arctech1
#irp={36.0k,388}<1,-3|3,-1> \
#(<0:2|2:2>((D+15):4,(S+15):4),40:7,F:1,0:1,-10.2m)+ \
#[D:1..16,S:1..16,F:0..1]
#[documentation]
#Alternate version of the archtech protocol: The real one triggers a bug in
#IrpMaster 0.2.2 and earlier, this coding circumvents that bug.
#("(D-1):4" triggers the bug, the functionally equivalent "(D+15):4" does not.)

[protocol]
name=rs200
#irp={35.7k,msb}<50p,-120p|21p,-120p>( \
#d = D-1, \
#h1 = H1-1, h2 = H2-1, h3 = H3-1, h4 = H4-1, \
#P=~(#d+#F):1, \
#sum=9+(h4*4+h3) + (h2*4+h1) + (P*8+d) + F*4, \
#25:6,h4:2,h3:2,h2:2,h1:2,P:1,d:3,F:2,0:2,sum:4,-1160p)* \
#[H1:1..4, H2:1..4, H3:1..4, H4:1..4, D:1..6, F:0..2]
irp={35.7k,msb}<50p,-120p|21p,-120p>( \
    25:6,(H4-1):2,(H3-1):2,(H2-1):2,(H1-1):2,P:1,(D-1):3,F:2,0:2,sum:4,-1160p)* \
{   P=~(#(D-1)+#F):1, \
    sum=9+((H4-1)*4+(H3-1)) + ((H2-1)*4+(H1-1)) + (P*8+(D-1)) + F*4} \
[H1:1..4, H2:1..4, H3:1..4, H4:1..4, D:1..6, F:0..2]
[documentation]
This protocol is/was used by the so-called RS-200 RF (433MHz)
controlled switches, that was sold by Conrad Electronics. There is a
"house number" consisting of for digits, each in the range 1 to
4. These are called H1, H2, H3, and H4 in the IRP. There is also a
"device address". Officially, it ranges from 1 to 4, however, at least
on the hardware I tried, 5 can also be used and assigned to a
receiver. Also, 6 was working, and in fact controlled the "group"
consisting of all devices with address 1,...,5. For 7 and 8, no
function has been verified. F=0 is the power on command, F=1 the power
off command, and F=2 the power toggle command.

[protocol]
name=GwtS
irp={38.005k,417,lsb}<1|-1>(0:1,D:8,1:2,F:8,1:2,CRC:8,1:1)[D:0..255=144,F:0..255,CRC:0..255]
[documentation]
Protocol for Disney's Glow with the Show Hat/Ears, see http://www.hifi-remote.com/forums/viewtopic.php?t=14541. Unfortunately, the IRP engine cannot compute the CRC, but the user has to enter it manually.

The known commands are, together with their F and CRC values, as follows:

off 0x60 166
blue 0x61 248
green 0x62 26
cyan 0x63 68
red 0x64 199
magenta 0x65 153
yellow 0x66 123
white 0x67 37
off_r 0x68 100
blue_r 0x69 58
green_r 0x6A 216
cyan_r 0x6B 134
red_r 0x6C 5
magenta_r 0x6D 91
yellow_r 0x6E 185
white_r 0x6F 231

[protocol]
name=RC6-M-56
usable=yes
irp={36k,444,msb}<-1,1|1,-1>(6,-2,1:1,M:3,<-2,2|2,-2>(T:1),C:56,-131.0m)*[M:0..7,T@:0..1=0,C:0..72057594037927935]
[documentation]
This is the "RC6-?-?? protocol" made useable for the case of ??=56.

[protocol]
name=entone
irp=RC6-M-56{M=6, C=64743191718391808|2**4*F}[F:0..255,T:0..1=0]
[documentation]
A special case of the RC6-M-56 protocol, used in the Entone Amulet,
see http://wwvv.hifi-remote.com/forums/viewtopic.php?t=12561

[protocol]
name=Pioneer-Mix
irp={40k,564}<1,-1|1,-3>(16,-8,D0:8,~D0:8,F0:8,~F0:8,1,^108m,(16,-8,D:8,~D:8,F:8,~F:8,1,^108m)+) [D0:0..255,F0:0..255,D:0..255=D0,F:0..255=F0]
EFC_translation=LSB comp
[documentation]
Two-signal version of the Pioneer protocol; first sends the "normal" signal (parameters D0 and F0), then, as repeat, the one determined by D and F.

[protocol]
name=Fujitsu_Aircon
irp={38.4k,413}<1,-1|1,-3>(8,-4,20:8,99:8,0:8,16:8,16:8,254:8,9:8,48:8,H:8,J:8, K:8, L:8, M:8,N:8,32:8,Z:8,1,-104.3m)* \
{H=16*A + wOn, J=16*C + B, K=16*E:4 + D:4, L=tOff:8, M=tOff:3:8+fOff*8+16*tOn:4, N=tOn:7:8+128*fOn,Z=256-(H+J+K+L+M+N+80)%256} \
[A:0..15,wOn:0..1,B:0..15, C:0..15,D:0..15,E:0..15,tOff:0..1024,tOn:0..1024,fOff:0..1,fOn:0..1]
[documentation]
Protocol for Fujitsu inverter air conditioning. See http://www.remotecentral.com/cgi-bin/mboard/rc-discrete/thread.cgi?4894

[protocol]
name=Serial
irp={,83.3}<1|-1>(1:1,data:8,0:1) [B:0..255]
[documentation]

[protocol]
name=Roku-Official
irp={38.0k,564}<1,-1|1,-3>(16,-8,D:8,S:8,F:7,0:1,~F:7,1:1,1,^108m, (16,-8,D:8,S:8,F:7,1:1,~F:7,0:1,1,^108m)+) \
[D:0..255,S:0..255=255-D,F:0..127]
[documentation]
This IR protocol is very similar to NEC2, except the repeat behavior is different.
The second and additional frames of a repeating signal send the OBC + 128.

See http://www.hifi-remote.com/forums/viewtopic.php?p=115990#115990.

# http://www.hifi-remote.com/forums/viewtopic.php?t=16928&start=18
[protocol]
name=supersony
usable=no
#irp={40.0k,600}<1,-1|2,-1>(                                             \
#                       X:1:7 ?          (4,-1,X:7,Y:8,^45000u)      \
#                             : (y:1:7 ? (4,-1,X:7,Y:5,N1:8,^45000u) \
#                                      : (4,-1,X:7,Y:5,^45000u)      \
#				)                                   \
#		       )3+                                          \
#{A=fixed:-8:24, B=fixed:-8:16, C=fixed:-8:8, D=fixed:-8,            \
#X=variable:-8:8, Y=variable:-8,                                     \
#N1 =  Y:-2:5==0 ? A                                                 \
#    : Y:-2:5==1 ? B                                                 \
#    : Y:-2:5==2 ? C                                                 \
#    : Y:-2:5==3 ? D }
irp={40.0k,600}<1,-1|2,-1>(                                             \
                       X:1:7 ?          (4,-1,X:7,Y:8,^45000u)      \
                             : (y:1:7 ? (4,-1,X:7,Y:5,N1:8,^45000u) \
                                      : (4,-1,X:7,Y:5,^45000u)      \
				)                                   \
		       )3+                                          \
{A=fixed:-8:24, B=fixed:-8:16, C=fixed:-8:8, D=fixed:-8,            \
X=variable:-8:8, Y=variable:-8,                                     \
N1 =  Y:-2:5==0 ? A                                                 \
    : Y:-2:5==1 ? B                                                 \
    : Y:-2:5==2 ? C                                                 \
    : D } [ fixed:0..UINT32_MAX,variable:0..UINT16_MAX]
[documentation]
See http://www.hifi-remote.com/forums/viewtopic.php?t=16928&start=18
