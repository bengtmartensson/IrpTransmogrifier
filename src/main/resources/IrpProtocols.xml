<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<?xml-stylesheet type="text/xsl" href="IrpProtocols2html.xsl"?>
<irp:protocols xmlns="http://www.w3.org/1999/xhtml"
               xmlns:xi="http://www.w3.org/2001/XInclude"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               version="2017-10-15"
               xsi:schemaLocation="http://www.harctoolbox.org/irp-protocols file:///home/bengt/harctoolbox/IrpTransmogrifier/src/main/schemas/irp-protocols.xsd"
               xmlns:irp="http://www.harctoolbox.org/irp-protocols">
    <irp:protocol c-name="X48NEC1" name="48-NEC1">
        <irp:irp><![CDATA[{38.4k,564}<1,-1|1,-3>(16,-8,D:8,S:8,F:8,~F:8,E:8,~E:8,1,^108m,(16,-4,1,^108m)*)[D:0..255,S:0..255=255-D,F:0..255,E:0..255]]]></irp:irp>
        <irp:documentation>This protocol signals repeats by the use of <a href="#repeat">dittos</a>.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="X48NEC2" name="48-NEC2">
        <irp:irp><![CDATA[{38.4k,564}<1,-1|1,-3>(16,-8,D:8,S:8,F:8,~F:8,E:8,~E:8,1,^108m)*[D:0..255,S:0..255=255-D,F:0..255,E:0..255]]]></irp:irp>
        <irp:documentation>This protocol signals repeats by the use of <a href="#repeat">dittos</a>.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="AdNotam" name="AdNotam">
        <irp:irp><![CDATA[{35.7k,895,msb}<1,-1|-1,1>(1,-2,1,D:6,F:6,^114m)*[D:0..63,F:0..63]]]></irp:irp>
        <irp:documentation>Very similar to <a href="#RC5">RC5</a>, except AdNotam uses two start bits, and no toggle bit.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Aiwa" name="Aiwa">
        <irp:parameter name="uei-executor">005E</irp:parameter>
        <irp:parameter name="uei-executor">009E</irp:parameter>
        <irp:irp><![CDATA[{38.123k,550}<1,-1|1,-3>(16,-8,D:8,S:5,~D:8,~S:5,F:8,~F:8,1,-42,(16,-8,1,-165)*)[D:0..255,S:0..31,F:0..255]]]></irp:irp>
        <!--irp:documentation/--> <!-- Leave it out, to get this case tested -->
    </irp:protocol>
    <irp:protocol c-name="Aiwa2" name="Aiwa2">
        <irp:irp><![CDATA[
{38k,550}<1,-1|1,-3>(16,-8,D:8,S:5,~D:8,~S:5,F:8,~F:8,1,-42)* [D:0..255,S:0..31,F:0..255]
]]></irp:irp>
        <irp:documentation>From 3FG's teaser.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Akai" name="Akai">
        <irp:parameter name="uei-executor">000D</irp:parameter>
        <irp:irp><![CDATA[{38k,289}<1,-2.6|1,-6.3>(D:3,F:7,1,^25.3m)*[D:0..7,F:0..127]]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol c-name="Amino" name="Amino">
        <irp:parameter name="uei-executor">000D</irp:parameter>
        <irp:parameter name="prefer-over">Amino-56</irp:parameter>
        <irp:irp><![CDATA[{37.3k,268,msb}<-1,1|1,-1>(T=1,(7,-6,3,D:4,1:1,T:1,1:2,0:8,F:8,15:4,C:4,-79m,T=0)+){C =(D:4+4*T+9+F:4+F:4:4+15)&15} [D:0..15,F:0..255]]]></irp:irp>
        <irp:documentation>DecodeIR v2.43 checks T and will report in the Misc field if the start or end frame is missing. Amino equipment use both 37 and 56KHz, but the duration of the half-bit is always 268.  <a href="#Zaptor-36">Zaptor</a> is a closely related protocol which for which the half-bit duration is 330. IRDecode v2.43 distinguishes between Amino and Zaptor in order of priority by 1) the position of the toggle bit, 2) the value of the next to last nibble, and 3)the measured duration of a half-bit.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Amino56" name="Amino-56">
        <irp:parameter name="uei-executor">000D</irp:parameter>
        <irp:irp><![CDATA[{56.0k,268,msb}<-1,1|1,-1>(T=1,(7,-6,3,D:4,1:1,T:1,1:2,0:8,F:8,15:4,C:4,-79m,T=0)+){C =(D:4+4*T+9+F:4+F:4:4+15)&15} [D:0..15,F:0..255]]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol c-name="Anthem" name="Anthem">
        <irp:parameter name="uei-executor">0123</irp:parameter>
        <irp:parameter name="prefer-over">Anthem_relaxed</irp:parameter>
        <irp:irp><![CDATA[{38.0k,605}<1,-1|1,-3>((8000u,-4000u,D:8,S:8,F:8,C:8,1,-25m)2, 8000u,-4000u,D:8,S:8,F:8,C:8,1,-100)* { C=~(D+S+F+255):8} [D:0..255,S:0..255,F:0..255]]]></irp:irp>
        <irp:documentation>Anthem framing is very similar to <a href="#NEC1">NEC</a>, and also uses 32 bits of data. However, the leadout is much shorter. The signal is sent at least 3 times. Anthem usually splits F into a 2 bit unit number, and a 6 bit function number.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Anthem_relaxed" name="Anthem_relaxed">
        <irp:parameter name="uei-executor">0123</irp:parameter>
        <irp:parameter name="decode-only">true</irp:parameter>
        <irp:irp><![CDATA[{38.0k,605}<1,-1|1,-3>(8000u,-4000u,D:8,S:8,F:8,C:8,1,-25m)* { C=~(D+S+F+255):8} [D:0..255,S:0..255,F:0..255]]]></irp:irp>
        <irp:documentation>Relaxed version of the Anthem protocol.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Apple" name="Apple">
        <irp:parameter name="uei-executor">01E0</irp:parameter>
        <irp:parameter name="prefer-over">NEC1-f16</irp:parameter>
        <irp:parameter name="prefer-over">NEC1</irp:parameter>
        <irp:parameter name="prefer-over">NEC-Shirriff-32</irp:parameter>
        <irp:irp><![CDATA[{38.4k,564}<1,-1|1,-3>(16,-8,D:8,S:8,C:1,F:7,PairID:8,1,^108m,(16,-4,1,^108m)*){C=1-(#F+#PairID)%2,S=135}[D:0..255=238,F:0..127,PairID:0..255]]]></irp:irp>
        <irp:documentation>C=1 if the number of 1 bits in the fields F and I is even.  I is the remote ID. Apple uses the same framing as <a href="#NEC1">NEC1</a>, with D=238 in normal use, 224 while pairing.  S=135</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Archer" name="Archer">
        <irp:irp><![CDATA[{0k,12}<1,-3.3m|1,-4.7m>(F:5,1,-9.7m)* [F:0..31]]]></irp:irp>
        <irp:documentation>This is not a robust protocol, so <A href="#spurious">spurious decodes</A> are likely.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="arctech" name="arctech">
        <irp:irp><![CDATA[{0k,388}<1,-3|3,-1>(<0:2|2:2>((D-1):4,(S-1):4),40:7,F:1,0:1,-10.2m)*[D:1..16,S:1..16,F:0..1]]]></irp:irp>
        <irp:documentation><p>Protocol used by several manufacturers of 433MHz RF controlled switches, like
            <a href="http://www.intertechno.at">Intertechno</a>, Duewi, ELRO, and the URC light control kit, and many other.
            Appears to be introduced by the Taiwanese firm <a href="http://www.arctech.com.tw">ARC Technology</a>.
            These codes correspond to switches with code wheels, having an "House number" ranging from "A" to "P",
            in the IRP above corresponding to D=1 up to 16 for "P".
            They also have an "Address", ranging from 1 to 16, corresponding to the parameter "S" in the IRP.
            Note that e.g. Intertechno makes switches "with" and "without" code wheels,
            the latter having a much larger addressing space, and unfortunately cannot be controlled by the present protocol.
            F=0 is the power off command, F=1 the power on command.
            The power on command is also used for dimming, both up and down.</p>

                <p>In some One for All remotes, for example the URC-7781,
                    the setup codes 2200,2201, up to 2215 correspond to this protocol, 2200 for house "A", up to 2215 for house "P".</p>
        </irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="arctech38" name="arctech-38">
        <irp:irp><![CDATA[{38k,388}<1,-3|3,-1>(<0:2|2:2>((D-1):4,(S-1):4),40:7,F:1,0:1,-10.2m)*[D:1..16,S:1..16,F:0..1]]]></irp:irp>
        <irp:documentation>Same as <a href="#arctech">arctech</a>, but with an IR-typical modulation.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Audiovox" name="Audiovox">
        <irp:parameter name="uei_protoocol">005D</irp:parameter>
        <irp:irp><![CDATA[{40k,500}<1,-1|1,-3>(16,-8,D:8,1,-8,F:8,1,-40)*[D:0..255,F:0..255]]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol name="B&amp;O" c-name="BO">
        <irp:irp><![CDATA[
{455k,3125,msb}<200u,-zeroGap,zeroGap=2,oneGap=3 | 200u,-oneGap,zeroGap=1,oneGap=2>
(200u,-1,200u,-1,200u,-5,D:9,F:8,200u,-4,200u,-100m)
{zeroGap=1, oneGap=3}
[D:0..511,F:0..255]
]]></irp:irp>
        <irp:documentation>
            <a href="http://www.hifi-remote.com/forums/viewtopic.php?t=12486">Forum thread.</a>
        </irp:documentation>
    </irp:protocol>
    <irp:protocol name="B&amp;O repeat" c-name="BO">
        <irp:irp><![CDATA[
{455k,3125,msb}<200u,-zeroGap,zeroGap=2,oneGap=3 | 200u,-oneGap,zeroGap=1,oneGap=2>
(200u,-1,200u,-1,200u,-5,D:9,F:8,200u,-4)
{zeroGap=1, oneGap=3}
[D:0..511,F:0..255]
]]></irp:irp>
    <irp:documentation>From 3FG's teaser.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Barco" name="Barco">
        <irp:parameter name="absolute-tolerance">60</irp:parameter>
        <irp:parameter name="uei-executor">002A</irp:parameter>
        <irp:irp><![CDATA[{0k,10}<1,-5|1,-15>(1,-25, D:5,F:6, 1,-25,1,-120m)*[D:0..31,F:0..63]]]></irp:irp>
        <irp:documentation>This protocol uses no modulation of the signal.

This is a moderately robust protocol, but <A href="#spurious">spurious decodes</A> are still possible.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Blaupunkt" name="Blaupunkt">
        <irp:parameter name="uei-executor">00A5</irp:parameter>
        <irp:irp><![CDATA[
{30.3k,512}<-1,1|1,-1>(1,-5,1023:10, -44, (1,-5,1:1,F:6,D:3,-236)+ ,1,-5,1023:10,-44)[F:0..63,D:0..7]
]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol name="Blaupunkt_relaxed">
        <irp:parameter name="decode-only">true</irp:parameter>
        <irp:irp><![CDATA[
{30.3k,512}<-1,1|1,-1>(1,-5,1023:10, -44, (1,-5,1:1,F:6,D:3,-236)* ,1,-5,1023:10,-44)[F:0..63,D:0..7]
]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol c-name="Bose" name="Bose">
        <irp:parameter name="uei-executor">010C</irp:parameter>
        <irp:irp><![CDATA[{38.0k,500,msb}<1,-1|1,-3>(2,-3,F:8,~F:8,1,-50m)* [F:0..255]]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol c-name="Bryston" name="Bryston">
        <irp:irp><![CDATA[{38.0k,315}<1,-6|6,-1>(D:10,F:8,-18m)* [D:0..1023,F:0..255]]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol c-name="CanalSat" name="CanalSat">
        <irp:parameter name="uei-executor">018C</irp:parameter>
        <irp:irp><![CDATA[{55.5k,250,msb}<-1,1|1,-1>(T=0,(1,-1,D:7,S:6,T:1,0:1,F:7,-89m,T=1)+)[D:0..127,S:0..63,F:0..127]]]></irp:irp>
        <irp:documentation>The <A href="#repeat">repeat frames</A> are not all identical.  T toggles within a single signal, with T=0 for the start frame and T=1 for all repeats.  DecodeIR v2.37 and later check T and will report in the Misc field if the start frame is missing. The official name for CanalSat is "ruwido r-step".</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="CanalSatLD" name="CanalSatLD">
        <irp:irp><![CDATA[{56k,320,msb}<-1,1|1,-1>(T=0,(1,-1,D:7,S:6,T:1,0:1,F:6,~F:1,-85m,T=1)+)[D:0..127,S:0..63,F:0..63]]]></irp:irp>
        <irp:documentation>The official name for CanalSatLD is "ruwido r-step"</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Canon" name="Canon">
        <irp:irp><![CDATA[{33k,1}<16p,-240p|16p,-175p>(F:1)2[F:0..1]]]></irp:irp>
        <irp:documentation>IR protocol for many Canon cameras. With F=0 it triggers immediately, F=1 it triggers after a delay of approximately two seconds.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Denon" name="Denon">
        <irp:parameter name="prefer-over">Denon{1}</irp:parameter>
        <irp:parameter name="prefer-over">Denon{2}</irp:parameter>
        <irp:parameter name="uei-executor">001C</irp:parameter>
        <irp:irp><![CDATA[{38k,264}<1,-3|1,-7>(D:5,F:8,0:2,1,-165,D:5,~F:8,3:2,1,-165)* [D:0..31,F:0..255]]]></irp:irp>
        <irp:documentation>A Denon signal has two halves, either one of which is enough to fully decode the information. A significant fraction of Denon learned signals contain just one half or have the halves separated so that DecodeIr can't process them together. When one half is seen separate from the other, DecodeIr will name the protocol Denon{1} or Denon{2} depending on which half is decoded. Denon, Denon{1} and Denon{2} all represent the same protocol when they are correct. But only Denon is robust. A Denon{1} or Denon{2} decode might be <A href="#spurious">spurious</A>.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="DenonK" name="Denon-K" usable="true">
        <irp:parameter name="uei-executor">00CD</irp:parameter>
        <irp:parameter name="prefer-over">Kaseikyo</irp:parameter>
        <irp:irp><![CDATA[{37k,432}<1,-1|1,-3>(8,-4,84:8,50:8,0:4,D:4,S:4,F:12,((D*16)^S^(F*16)^(F:8:4)):8,1,-173)* [D:0..15,S:0..15,F:0..4095]]]></irp:irp>
        <irp:documentation>Denon-K is the member of the <a href="#Kaseikyo">Kaseikyo</a> family with OEM_code1=84 and OEM_code2=50.
        Denon-K uses the same check byte rules as <a href="#Panasonic">Panasonic</a> protocol, but uses the data bits differently. The Denon-K choice in RemoteMaster uses the same protocol executor as Panasonic combo, but computes the hex commands based on Denon's use of the Kaseikyo data bits.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Denon_1_" name="Denon{1}">
    <irp:parameter name="decode-only">true</irp:parameter>
        <irp:irp><![CDATA[{38k,264}<1,-3|1,-7>(D:5,F:8,0:2,1,-165)* [D:0..31,F:0..255]]]></irp:irp>
        <irp:documentation>A Denon signal has two halves, either one of which is enough to fully decode the information. A significant fraction of Denon learned signals contain just one half or have the halves separated so that DecodeIr can't process them together. When one half is seen separate from the other, DecodeIr will name the protocol Denon{1} or Denon{2} depending on which half is decoded. Denon, Denon{1} and Denon{2} all represent the same protocol when they are correct. But only Denon is robust. A Denon{1} or Denon{2} decode might be <A href="#spurious">spurious</A>.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Denon_2_" name="Denon{2}">
        <irp:parameter name="decode-only">true</irp:parameter>
        <irp:irp><![CDATA[{38k,264}<1,-3|1,-7>(D:5,~F:8,3:2,1,-165)* [D:0..31,F:0..255]]]></irp:irp>
        <irp:documentation>A Denon signal has two halves, either one of which is enough to fully decode the information. A significant fraction of Denon learned signals contain just one half or have the halves separated so that DecodeIr can't process them together. When one half is seen separate from the other, DecodeIr will name the protocol Denon{1} or Denon{2} depending on which half is decoded. Denon, Denon{1} and Denon{2} all represent the same protocol when they are correct. But only Denon is robust. A Denon{1} or Denon{2} decode might be <A href="#spurious">spurious</A>.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Dgtec" name="Dgtec">
        <irp:parameter name="uei-executor">016A</irp:parameter>
        <irp:irp><![CDATA[{38k,560}<1,-1|1,-3>(16,-8,D:8,F:8,~F:8,1,^108m,(16,-4,1,^108m)+) [D:0..255,F:0..255]]]></irp:irp>
        <irp:documentation>This protocol signals repeats by the use of <A href="#repeat">dittos</A>.</irp:documentation>
    </irp:protocol>
    <irp:protocol name="Digivision">
        <irp:irp><![CDATA[
{38.0k,182}<3,-3|3,-6>(20,-10,D:8,Dev2:8,Dev3:8,20,-10,F:8,~F:8,3,^108m,(20,-20,3,^108m)*)
[D:0..255,Dev2:0..255,Dev3:0..255,F:0..255]
            ]]></irp:irp>
            <irp:documentation>See <a href="#GuangZhou">GuangZhou</a>, which has identical framing but with different bit definitions.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="DirecTV" name="DirecTV">
        <irp:irp><![CDATA[{38k,600,msb}<1,-1|1,-2|2,-1|2,-2>([10][5],-2,D:4,F:8,C:4,1,-50){C=7*(F:2:6)+5*(F:2:4)+3*(F:2:2)+(F:2)}[D:0..15,F:0..255]]]></irp:irp>
        <irp:documentation>There are six variants of the DirecTV protocol, distinguished in RemoteMaster by the parameter "Parm" on the Setup page.
            The Parm value is shown in the Misc field of DecodeIR.  The IRP notation above corresponds to the default Parm=3.
            The various Parm values correspond to three different frequencies (the 38k in the above) and two different lead-out times (the -50 in the above).
            The corresponding values are:

            <ul>
                <li>Parm=0 : 40k, -15</li>
                <li>Parm=1 : 40k, -50</li>
                <li>Parm=2 : 38k, -15</li>
                <li>Parm=3 : 38k, -50</li>
                <li>Parm=4 : 57k, -15</li>
                <li>Parm=5 : 57k, -50</li>
            </ul>
        </irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="DirecTV_3FG" name="DirecTV_3_FG">
        <irp:irp><![CDATA[{38k,600,msb}<1,-1|1,-2|2,-1|2,-2>(10,-2,(D:4,F:8,C:4,1,-30m,5,-2)*){C=7*(F:2:6)+5*(F:2:4)+3*(F:2:2)+(F:2)}[D:0..15,F:0..255]]]></irp:irp>
        <irp:documentation>There are six variants of the DirecTV protocol, distinguished in RemoteMaster by the parameter "Parm" on the Setup page.  The Parm value is shown in the Misc field of DecodeIR.  The IRP notation above corresponds to the default Parm=3.  The various Parm values correspond to three different frequencies (the 38k in the above) and two different lead-out times (the -50 in the above).  The corresponding values are:

<ul> <li>Parm=0 : 40k, -15</li> <li>Parm=1 : 40k, -50</li> <li>Parm=2 : 38k, -15</li> <li>Parm=3 : 38k, -50</li> <li>Parm=4 : 57k, -15</li> <li>Parm=5 : 57k, -50</li> </ul>
        </irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Dish_Network" name="Dish_Network">
        <irp:parameter name="uei-executor">0002</irp:parameter>
        <irp:irp><![CDATA[{57.6k,406}<1,-7|1,-4>(1,-15,(F:-6,S:5,D:5,1,-15)+) [F:0..63,S:0..31,D:0..31]]]></irp:irp>
        <irp:documentation>This is not a robust protocol, so <A href="#spurious">spurious decodes</A> are likely.
        See <a href="http://www.hifi-remote.com/forums/viewtopic.php?t=13923">this thread</a> for a discussion.
        </irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Dishplayer" name="Dishplayer">
        <irp:parameter name="uei-executor">010F</irp:parameter>
        <irp:irp><![CDATA[{38.4k,535,msb}<1,-5|1,-3>(1,-11,(F:6,S:5,D:2,1,-11)+) [F:0..63,S:0..31,D:0..3]]]></irp:irp>
        <irp:documentation>This is not a robust protocol, so <A href="#spurious">spurious decodes</A> are likely.</irp:documentation>
    </irp:protocol>
    <irp:protocol name="Dysan">
        <irp:irp><![CDATA[
    {780,38k}<1,-1|1,-2>(3,-1,D:7,F:8,1,-104m)*
            [D:0..127,F:0..255]
            ]]></irp:irp>
    </irp:protocol>
    <irp:protocol c-name="Elan" name="Elan">
        <!--irp:parameter name="uei-executor">Unknown</irp:parameter-->
        <irp:irp><![CDATA[{40.2k,398,msb}<1,-1|1,-2>(3,-2,D:8,~D:8,2,-2,F:8,~F:8,1,^50m)* [D:0..255,F:0..255]]]></irp:irp>
        <irp:documentation>See the <A href="http://www.hifi-remote.com/forums/viewtopic.php?p=87473">JP1-forum</A> for the executor.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Emerson" name="Emerson">
        <irp:parameter name="uei-executor">0065</irp:parameter>
        <irp:parameter name="prefer-over">Sampo</irp:parameter>
        <irp:parameter name="prefer-over">ScAtl-6</irp:parameter>
        <irp:irp><![CDATA[{36.7k,872}<1,-1|1,-3>(4,-4,D:6,F:6,~D:6,~F:6,1,-39)* [D:0..63,F:0..63]]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol c-name="entone" name="entone">
        <irp:parameter name="prefer-over">RC6-M-56</irp:parameter>
        <irp:irp><![CDATA[
{36k,444,msb}<-1,1|1,-1>(6,-2,1:1,M:3,<-2,2|2,-2>(T:1),0xE60396FFFFF:44,F:8,0:4,-131.0m)*{M=6,T=0}[F:0..255]
]]></irp:irp>
        <irp:documentation>A special case of the <a href="#RC6-M-56">RC6-M-56</a> protocol, used in the Entone Amulet, see <a href="http://www.hifi-remote.com/forums/viewtopic.php?t=12561">this forum thread</a>.</irp:documentation>
    </irp:protocol>
    <irp:protocol name="Epson">
        <irp:irp><![CDATA[
            {38.4k,577}<2,-1|1,-2|1,-1|2,-2>((4,-1,D:8,T1:2,OBC:6,T2:2,S:8,1,-75m)*,(4,-1,D:8,~F1:2,OBC:6,~F2:2,S:8,1,-250m))
               [D:0..255,S:0..255,OBC:0..63,T1:0..3,T2:0..3,F1:0..3,F2:0..3]
            ]]></irp:irp>
        <irp:documentation>
            <a href="http://www.hifi-remote.com/forums/viewtopic.php?t=17051">Forum thread</a>
        </irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="F12" name="F12">
        <irp:parameter name="uei-executor">001A</irp:parameter>
        <irp:irp><![CDATA[{37.9k,422}<1,-3|3,-1>((D:3,S:1,F:8,-80)2,-128)*  [D:0..7,S:0..1,F:0..255]]]></irp:irp>
        <irp:documentation>Old version of the F12 specification. See <a href="http://www.hifi-remote.com/wiki/index.php?title=DecodeIR#F12">DecodeIR</a>.
        </irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="F120" name="F12-0">
        <irp:irp><![CDATA[
{37.9k,422}<1,-3|3,-1>(D:3,H:1,F:8,-34,D:3,H:1,F:8) {H=0} [D:0..7,F:0..0xFF]
]]></irp:irp>
        <irp:documentation>Taken from <a href="http://www.hifi-remote.com/wiki/index.php?title=DecodeIR#F12">DecodeIR</a>, case H=0.
        </irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="F121" name="F12-1">
        <irp:irp><![CDATA[
{37.9k,422}<1,-3|3,-1>(D:3,H:1,F:8,-34,D:3,H:1,F:8,-88,D:3,H:1,F:8,-34,D:3,H:1,F:8)* {H=1} [D:0..7,F:0..0xFF]
]]></irp:irp>
        <irp:documentation>Taken from <a href="http://www.hifi-remote.com/wiki/index.php?title=DecodeIR#F12">DecodeIR</a>, case H=1.
        </irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="F32" name="F32">
        <irp:irp><![CDATA[{37.9k,422,msb}<1,-3|3,-1>(D:8,S:8,F:8,E:8,-100m)*  [D:0..255,S:0..255,F:0..255,E:0..255]]]></irp:irp>
        <irp:documentation>The meaning of the 32 bits of data is unknown, and the assignment to D, S, F, and E is arbitrary.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Fujitsu" name="Fujitsu">
        <irp:parameter name="uei-executor">00F8</irp:parameter>
        <irp:irp><![CDATA[{37k,432}<1,-1|1,-3>(8,-4,20:8,99:8,0:4,E:4,D:8,S:8,F:8,1,-110)* [D:0..255,S:0..255=D,F:0..255,E:0..15=0]]]></irp:irp>
        <irp:documentation>Fujitsu is the member of the <a href="#Kaseikyo">Kaseikyo</a> family with OEM_code1=20 and OEM_code2=99. There is no check byte, so the risk of an incorrectly decoded OBC is much higher than in other Kaseikyo protocols.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Fujitsu_128" name="Fujitsu-128">
        <irp:irp><![CDATA[{38.4k,413}<1,-1|1,-3>(8, -4, A0:8, A1:8, A2:8, A3:8, A4:8, A5:8, A6:8, A7:8, A8:8, A9:8, A10:8, A11:8, A12:8, A13:8, A14:8, A15:8, 1, -104.3m)*
                    [A0:0..255, A1:0..255, A2:0..255,  A3:0..255,  A4:0..255,  A5:0..255,  A6:0..255,  A7:0..255,
                     A8:0..255, A9:0..255, A10:0..255, A11:0..255, A12:0..255, A13:0..255, A14:0..255, A15:0..255]]]></irp:irp>
    </irp:protocol>
    <irp:protocol c-name="Fujitsu56" name="Fujitsu-56">
        <irp:irp><![CDATA[{37k,432}<1,-1|1,-3>(8,-4,20:8,99:8,0:4,E:4,D:8,S:8,X:8,F:8,1,-110)* [D:0..255,S:0..255=D,F:0..255,E:0..15=0,X:0..255=0]]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol c-name="Fujitsu_Aircon" name="Fujitsu_Aircon">
        <irp:parameter name="decodable">false</irp:parameter>
        <irp:irp><![CDATA[Fujitsu-128
                   {A0=20, A1=99, A2=0, A3=16, A4=16, A5=254, A6=9, A7=48,
                    A8=16*A + wOn, A9=16*C + B, A10=16*E:4 + D:4, A11=tOff:8, A12=tOff:3:8+fOff*8+16*tOn:4,
                    A13=tOn:7:8+128*fOn, A14=32, A15=256 -(A8+A9+A10+A11+A12+A13+80)%256}
           [A:0..15, wOn:0..1, B:0..15, C:0..15, D:0..15, E:0..15, tOff:0..1024, tOn:0..1024, fOff:0..1, fOn:0..1]]]></irp:irp>
        <irp:documentation>Protocol for Fujitsu inverter air conditioning. <a href="http://www.remotecentral.com/cgi-bin/mboard/rc-discrete/thread.cgi?4894">Reference</a>.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="GI4DTV" name="G.I.4DTV">
        <irp:parameter name="uei-executor">00A4</irp:parameter>
        <irp:irp><![CDATA[{37.3k,992}<1,-1|1,-3>(5,-2,F:6,D:2,C:4,1,-60)*{C= ((#(F&25) + #(D&5))&1) + 2*((#(F&43) + #(D&7))&1) + 4*((#(F&22) + #(D&7))&1) + 8*((#(F&44) + #(D&6))&1)}[D:0..3, F:0..63]]]></irp:irp>
        <irp:documentation>This is a moderately robust protocol, but <A href="#spurious">spurious decodes</A> are still possible. Unit (device) numbers from 0 to 7 are supported.  The check sum C is a Hamming Code, which can correct single bit errors. D:1:2 is encoded in the check sum. See <a href="http://www.hifi-remote.com/forums/viewtopic.php?p=103934#103934">forum thread</a>.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="GI4DTVnoCheck" name="G.I.4DTVnoCheck">
        <irp:parameter name="uei-executor">00A4</irp:parameter>
        <irp:irp><![CDATA[{37.3k,992}<1,-1|1,-3>(5,-2,F:6,D:2,C:4,1,-60)*[D:0..3, F:0..63, C:0..15]]]></irp:irp>
        <irp:documentation>This is a moderately robust protocol, but <A href="#spurious">spurious decodes</A> are still possible. Unit (device) numbers from 0 to 7 are supported. See <a href="http://www.hifi-remote.com/forums/viewtopic.php?p=103934#103934">forum thread</a>.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="GICable" name="G.I.Cable">
        <irp:parameter name="alt_name">GI Cable</irp:parameter>
        <irp:parameter name="uei-executor">00C4</irp:parameter>
        <irp:irp><![CDATA[{38.7k,490}<1,-4.5|1,-9>(18,-9,F:8,D:4,C:4,1,-84,(18,-4.5,1,-178)*){C = -(D + F:4 + F:4:4)} [D:0..15,F:0..255]]]></irp:irp>
        <irp:documentation>This protocol signals repeats by the use of <A href="#repeat">dittos</A>.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="GIRG" name="GI RG">
        <irp:irp><![CDATA[{37.3k,1000, msb}<1,-1|1,-3>(5,-3,F:6,S:2,D:8,1,-60)*[D:0..255, S:0..3, F:0..63]]]></irp:irp>
        <irp:documentation>This is a moderately robust protocol, but <A href="#spurious">spurious decodes</A> are still possible. Typical usage is the GI/Next Level/Motorola RC2x00 series.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Grundig16" name="Grundig16">
        <irp:parameter name="uei-executor">0112</irp:parameter>
        <irp:irp><![CDATA[{35.7k,578,msb}<-4,2|-3,1,-1,1|-2,1,-2,1|-1,1,-3,1>(806u,-2960u,1346u,T:1,F:8,D:7,-100)*[D:0..127,F:0..255,T@:0..1=0]]]></irp:irp>
        <irp:documentation>These are two variants of the same protocol, differing only in frequency.  The IRP notation is corrected from previous versions of this document, to bring it into line with what DecodeIR actually does.

Note (BM): These two entries was one in the original document; I split it into two separate.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Grundig1630" name="Grundig16-30">
        <irp:parameter name="uei-executor">00AB</irp:parameter>
        <irp:irp><![CDATA[{30.3k,578,msb}<-4,2|-3,1,-1,1|-2,1,-2,1|-1,1,-3,1>(806u,-2960u,1346u,T:1,F:8,D:7,-100)* [D:0..127,F:0..255,T:0..1]]]></irp:irp>
        <irp:documentation>These are two variants of the same protocol, differing only in frequency.  The IRP notation is corrected from previous versions of this document, to bring it into line with what DecodeIR actually does.

Note (BM): These two entries was one in the original document; I split it into two separate.</irp:documentation>
    </irp:protocol>
    <irp:protocol name="GuangZhou">
        <irp:irp><![CDATA[
 {38.0k,182}<3,-3|3,-6>(20,-10,T:2,D:6,F:8,S:8,20,-10,~T:2,D:6,~F:8,3,^108m,(20,-20,3,^108m)*){T=3}
            [D:0..63,F:0..255,S:0..255]
            ]]></irp:irp>
            <irp:documentation>
                <a href="http://www.hifi-remote.com/forums/viewtopic.php?t=14600">Forum thread.</a>
            </irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="GwtS" name="GwtS">
        <irp:irp><![CDATA[{38.005k,417,lsb}<1|-1>(0:1,D:8,1:2,F:8,1:2,CRC:8,1:1)[D:0..255=144,F:0..255,CRC:0..255]]]></irp:irp>
        <irp:documentation>
            <p>Protocol for Disney's Glow with the Show Hat/Ears, see <a href="http://www.hifi-remote.com/forums/viewtopic.php?t=14541">this</a>. Unfortunately, the IRP engine cannot compute the CRC, but the user has to enter it manually.</p>

<p>The known commands are, together with their F and CRC values, as follows:</p>

<table border="1"> <tr>
                    <td>off</td>
                    <td>0x60</td>
                    <td>166</td>
                </tr> <tr>
                    <td>blue</td>
                    <td>0x61</td>
                    <td>248</td>
                </tr> <tr>
                    <td>green</td>
                    <td>0x62</td>
                    <td>26</td>
                </tr> <tr>
                    <td>cyan</td>
                    <td>0x63</td>
                    <td>68</td>
                </tr> <tr>
                    <td>red</td>
                    <td>0x64</td>
                    <td>199</td>
                </tr> <tr>
                    <td>magenta</td>
                    <td>0x65</td>
                    <td>153</td>
                </tr> <tr>
                    <td>yellow</td>
                    <td>0x66</td>
                    <td>123</td>
                </tr> <tr>
                    <td>white</td>
                    <td>0x67</td>
                    <td>37</td>
                </tr> <tr>
                    <td>off_r</td>
                    <td>0x68</td>
                    <td>100</td>
                </tr> <tr>
                    <td>blue_r</td>
                    <td>0x69</td>
                    <td>58</td>
                </tr> <tr>
                    <td>green_r</td>
                    <td>0x6A</td>
                    <td>216</td>
                </tr> <tr>
                    <td>cyan_r</td>
                    <td>0x6B</td>
                    <td>134</td>
                </tr> <tr>
                    <td>red_r</td>
                    <td>0x6C</td>
                    <td>5</td>
                </tr> <tr>
                    <td>magenta_r</td>
                    <td>0x6D</td>
                    <td>91</td>
                </tr> <tr>
                    <td>yellow_r</td>
                    <td>0x6E</td>
                    <td>185</td>
                </tr> <tr>
                    <td>white_r</td>
                    <td>0x6F</td>
                    <td>231</td>
                </tr> </table>
        </irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="GXB" name="GXB">
        <irp:irp><![CDATA[{38.3k,520,msb}<1,-3|3,-1>(1,-1,D:4,F:8,P:1,1,^100m)*{P=1-#F%2}[D:0..15,F:0..255]]]></irp:irp>
        <irp:documentation>Decoder for a nonstandard Xbox remote.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Humax4Phase" name="Humax 4Phase">
        <irp:irp><![CDATA[{56k,105, msb}<-2,2|-3,1|1,-3|2,-2>(T=0,(2,-2,D:6,S:6,T:2,F:7,~F:1,^95m,T=1)+)  [D:0..63, S:0..63, F:0..127]]]></irp:irp>
        <irp:documentation>
            <a href="http://www.hifi-remote.com/forums/viewtopic.php?t=14219">See this</a>.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="InterVideoRC201" name="InterVideo RC-201">
        <irp:irp><![CDATA[{38k,300}<1,-1|1,-3>(10,-5,0:1,F:6,768:10,1,-10m)* [F:0..63]]]></irp:irp>
        <irp:documentation>Used by a remote marked as <i>InterVideo RC-201</i> that is paired with a USB HID receiver simply marked as <i>RC-201</i>. Exact carrier frequency not known.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="IODATAn" name="IODATAn">
        <irp:parameter name="alt_name">IODATAn-x-y</irp:parameter>
        <!--irp:parameter name="uei-executor">not known.</irp:parameter-->
        <irp:irp><![CDATA[{38k,550}<1,-1|1,-3>(16,-8,x:7,D:7,S:7,y:7,F:8,C:4,1,^108m)* {n = F:4 ^ F:4:4 ^ C:4} [D:0..127,S:0..127,F:0..255,C:0..15=0,x:0..127=0,y:0..127=0]]]></irp:irp>
        <irp:documentation>This is potentially a class of protocols distinguished by values of <i>n</i>, <i>x</i> and <i>y</i> with <i>n</i> = 0..15 and <i>x</i>, <i>y</i> = 0..127.  If <i>x</i> and <i>y</i> are both zero, they are omitted.  The only known example is IODATA1.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Jerrold" name="Jerrold">
        <irp:parameter name="uei-executor">0006</irp:parameter>
        <irp:irp><![CDATA[{0k,44}<1,-7.5m|1,-11.5m>(F:5,1,-23.5m)* [F:0..31]]]></irp:irp>
        <irp:documentation>This is not a robust protocol, so <A href="#spurious">spurious decodes</A> are likely.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="JVC" name="JVC">
        <irp:parameter name="uei-executor">0034</irp:parameter>
        <irp:irp><![CDATA[{37.9k,527,33%}<1,-1|1,-3>(16,-8,D:8,F:8,1,^59.08m,(D:8,F:8,1,^46.42m)*) [D:0..255,F:0..255]]]></irp:irp>
        <irp:documentation>JVC{2} indicates a JVC signal from which the lead-in is missing.  The JVC protocol has lead-in on only the first frame, so it is quite easy to have it missing from a learned signal.  So when JVC{2} is correct, it means the same as JVC.  But JVC{2} is not robust, so <A href="#spurious">spurious decodes</A> are likely.  It is also very similar in structure and timing to <A href="#Mitsubishi">Mitsubishi</A> protocol, so that DecodeIr has difficulty distinguishing one from the other.  The device number, OBC and EFC are all encoded the same way between the two.  So if you have JVC{2} decodes that you have reason to suspect should actually be Mitsubishi, you can try using them as Mitsubishi without changing the numbers.  However, true Mitsubishi signals will not misdecode as JVC, just as JVC{2}.  So if some of the signals for your device decode as JVC and others as JVC{2}, you should trust all those decodes and not try Mitsubishi.
        <a href="http://support.jvc.com/consumer/support/documents/RemoteCodes.pdf">Documentation by JVC</a>.
        </irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="JVC48" name="JVC-48">
        <irp:parameter name="uei-executor">001F</irp:parameter>
        <irp:parameter name="uei-executor">00C9</irp:parameter>
        <irp:parameter name="uei-executor">00CD</irp:parameter>
        <irp:irp><![CDATA[{37k,432}<1,-1|1,-3>(8,-4,3:8,1:8,D:8,S:8,F:8,(D^S^F):8,1,-173)* [D:0..255,S:0..255,F:0..255]]]></irp:irp>
        <irp:documentation>
            <p>JVC-48 is the member of the <a href="#Kaseikyo">Kaseikyo</a> family with OEM_code1=3 and OEM_code2=31.</p>

            <p>
                <a href="#Panasonic">Panasonic</a> protocol uses the same check byte rules as JVC-48, so you might want use the (more flexible) Panasonic entries in KM or RM to produce a JVC-48 upgrade (by changing the OEM_code1 and OEM_code2 values).  For simple JVC-48 upgrades you get exactly the same results by directly selecting the "JVC-48" protocol.</p>
        </irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="JVC56" name="JVC-56">
        <irp:irp><![CDATA[{37k,432}<1,-1|1,-3>(8,-4,3:8,1:8,D:8,S:8,X:8,F:8,(D^S^X^F):8,1,-173)*[D:0..255,S:0..255,F:0..255,X:0..255]]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol c-name="JVC2" name="JVC{2}">
        <irp:irp><![CDATA[{37.9k,527,33%}<1,-1|1,-3>(D:8,F:8,1,^46.42m)* [D:0..255,F:0..255]]]></irp:irp>
        <irp:documentation>JVC{2} indicates a JVC signal from which the lead-in is missing.  The JVC protocol has lead-in on only the first frame, so it is quite easy to have it missing from a learned signal.  So when JVC{2} is correct, it means the same as JVC.  But JVC{2} is not robust, so <A href="#spurious">spurious decodes</A> are likely.  It is also very similar in structure and timing to <A href="#Mitsubishi">Mitsubishi</A> protocol, so that DecodeIr has difficulty distinguishing one from the other.  The device number, OBC and EFC are all encoded the same way between the two.  So if you have JVC{2} decodes that you have reason to suspect should actually be Mitsubishi, you can try using them as Mitsubishi without changing the numbers.  However, true Mitsubishi signals will not misdecode as JVC, just as JVC{2}.  So if some of the signals for your device decode as JVC and others as JVC{2}, you should trust all those decodes and not try Mitsubishi.
        <a href="http://support.jvc.com/consumer/support/documents/RemoteCodes.pdf">Documentation by JVC</a>.
        </irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Kaseikyo" name="Kaseikyo">
        <irp:parameter name="relative-tolerance">0.035</irp:parameter>
        <irp:irp><![CDATA[{37k,432}<1,-1|1,-3>(8,-4,M:8,N:8,X:4,D:4,S:8,F:8,E:4,C:4,1,-173)* {X=((M^N)::4)^(M^N), chksum=D^S^F^(E*16), C=chksum::4 ^ chksum}[D:0..15,S:0..255,F:0..255,E:0..15,M:0..255,N:0..255]]]></irp:irp>
        <irp:documentation>
            <p>This is the nominal form of the Kaseikyo.  It is most commonly seen with OEM codes 170.90, which indicates "Sharp".  I assume (haven't tested) that the SharpDVD protocol in KM generates these Kaseikyo-170-90 signals.  We have also seen this protocol with OEM codes 3.32.  I'm not sure what manufacturer that indicates.</p>

<p>The Kaseikyo protocol in KM seems to be designed to produce this nominal form of Kaseikyo for any specified OEM codes and any constant value of E.  That should be the way to reproduce any Kaseikyo-???-??? decode other than SharpDVD, and might be better than SharpDVD for the Kaseikyo-170-90 signals.</p>
        </irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Kaseikyo56" name="Kaseikyo56">
        <irp:parameter name="relative-tolerance">0.04</irp:parameter>
        <irp:irp><![CDATA[{37k,432}<1,-1|1,-3>(8,-4,M:8,N:8,H:4,D:4,S:8,E:8,F:8,G:8,1,-173)* {H=((M^N)::4)^(M^N), chksum=S^G^F^(E*16)^D, C=chksum::4 ^ chksum}[D:0..15,S:0..255,F:0..255,G:0..255,M:0..255,N:0..255,E:0..255]]]></irp:irp>
        <irp:documentation>Kaseikyo56 is a lengthened version of the <a href="#Kaseikyo">Kaseikyo</a> family of protocols.  It has the same OEM codes indicating the same manufacturers as Kaseikyo, and it has the same variation (by manufacturer) in check byte and other details as Kaseikyo.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Kathrein" name="Kathrein">
        <irp:parameter name="uei-executor">0066</irp:parameter>
        <irp:irp><![CDATA[{38k,540}<1,-1|1,-3>(16,-8,D:4,~D:4,F:8,~F:8,1,^105m,(16,-8,F:8,1,^105m)+)[D:0..15,F:0..255]]]></irp:irp>
        <irp:documentation>This protocol signals repeats by the use of <A href="#repeat">dittos</A>.  It is unusual in that the ditto frame carries part of the signal data, specifically the function code (OBC) but not the device code. Similar to <a href="#Logitech">Logitech</a>, but both decodes give the same device number and OBC.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Konka" name="Konka">
        <irp:parameter name="uei-executor">019B</irp:parameter>
        <irp:irp><![CDATA[{38k,500,msb}<1,-3|1,-5>(6,-6,D:8,F:8,1,-8,1,-46)* [D:0..255,F:0..255]]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol c-name="Logitech" name="Logitech">
        <irp:parameter name="uei-executor">020B</irp:parameter>
        <irp:irp><![CDATA[{38k,127}<3,-4|3,-8>(31,-36,D:4,~D:4,F:8,~F:8,3,-50m)*[D:0..15,F:0..255]]]></irp:irp>
        <irp:documentation>Logitech is used with their PS3 adapter.  The IR signal is similar to <a href="#Kathrein">Kathrein</a>.  If a Logitech signal is decoded as Kathrein, the device number and OBC are still correct.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Lumagen" name="Lumagen" usable="true">
        <irp:irp><![CDATA[{38.4k,416,msb}<1,-6|1,-12>(D:4,C:1,F:7,1,-26)* {C = (#F+1)&1} [D:0..15,F:0..127]]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol name="Lutron">
        <irp:irp><![CDATA[
            {40k,2300,msb}<-1|1>(255:8,X:24,0:4)*[X:0..0xFFFFFF]
    ]]></irp:irp>
        <irp:documentation>
            This is an unusual protocol in that an 8-bit device code and 8-bit OBC are encoded
            in a 24-bit error-correcting code as the X of the IRP notation.
            This is constructed as follows.
            First two parity bits are appended to the 16 data bits to give even parity for the two sets
            of 9 bits taken alternately.
            The resulting 18-bit sequence is then treated as 6 octal digits (0-7) expressed in 3-bit binary code.
            These are then re-coded in the 3-bit Gray code
            (also called, more descriptively, the reflected-binary code) with a parity bit to give odd parity,
            so giving 6 4-bit groups treated as a single 24-bit sequence.
            The whole thing allows any single-bit error in transmission to be identified and corrected.
        </irp:documentation>
    </irp:protocol>
        <irp:protocol c-name="Matsui" name="Matsui">
        <irp:irp><![CDATA[{38k,525}<1,-1|1,-3>(D:3,F:7,1,^30.5m)* [D:0..7,F:0..127]]]></irp:irp>
        <irp:documentation>This is not a robust protocol, so <A href="#spurious">spurious decodes</A> are likely.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="MCE" name="MCE" usable="true">
        <irp:parameter name="prefer-over">RC6-M-32</irp:parameter>
        <irp:parameter name="alt_name">RC6-6-32</irp:parameter>
        <irp:irp><![CDATA[{36k,444,msb}<-1,1|1,-1>((6,-2,1:1,6:3,-2,2,OEM1:8,S:8,T:1,D:7,F:8,^107m)*,T=1-T) {OEM1=128}[D:0..127,S:0..255,F:0..255,T@:0..1=0]]]></irp:irp>
        <irp:documentation>MCE is a member of the RC6 family.  Technically it is <a href="#RC6-M-32">RC6-6-32</a> with the standard toggle bit zero, with the OEM1 field equal to 128, and with a nonstandard (for the RC6 family) toggle bit added. If all those rules are met, DecodeIr will display the name as "MCE" and with the OEM2 field moved to the subdevice position.  Otherwise it will display RC6-6-32.</irp:documentation>
    </irp:protocol>
    <irp:protocol name="MCIR-2-kbd" c-name="MCIR2kbd">
        <irp:irp><![CDATA[
 {300,msb}<-1,1|1,-1>(9,32:8,C:5,0:8,F:8,M:8,-74m)*
{c1 =  #(F & 0b11111000) % 2,
 c2 = (#(F & 0b00000111) + #(M & 0b00110000)) % 2,
 c3 = (#(F & 0b11000111) + #(M & 0b10001110)) % 2,
 c4 = (#(F & 0b00110110) + #(M & 0b10101101)) % 2,
 c5 = (#(F & 0b10101101) + #(M & 0b10011011)) % 2,
 C = (c1 << 4) | (c2 << 3) | (c3 << 2) | (c4 << 1) | c5 }
[F:0..255,M:0..255]
            ]]></irp:irp>
        <irp:documentation>A RC6-ish keyboard IR protocol used by the Microsoft Remote Keyboard
            for Windows Media Center Edition, referred to by Microsoft's Windows Media Center
            remote specification docs as "an internal protocol called MCIR-2".
            See <a href="http://www.hifi-remote.com/forums/viewtopic.php?t=100888">HiFi-Remote thread</a> and
            <a href="https://github.com/torvalds/linux/blob/master/drivers/media/rc/ir-mce_kbd-decoder.c">Linux media driver</a>.
        </irp:documentation>
    </irp:protocol>
    <irp:protocol name="MCIR-2-mouse" c-name="MCIR2mouse">
        <irp:irp><![CDATA[
{300,msb}<-1,1|1,-1>(9,8:8,C:5,y:7,x:7,R:1,L:1,F:5,-10.7m)*
[C:0..31,L:0..1,R:0..1,x:0..127,y:0..127,F:0..31]
            ]]></irp:irp>
        <irp:documentation>A RC6-ish mouse IR protocol used by the Microsoft Remote Keyboard
            for Windows Media Center Edition, referred to by Microsoft's Windows Media Center
            remote specification docs as "an internal protocol called MCIR-2".
            See <a href="http://www.hifi-remote.com/forums/viewtopic.php?t=100888">HiFi-Remote thread</a> and
            <a href="https://github.com/torvalds/linux/blob/master/drivers/media/rc/ir-mce_kbd-decoder.c">Linux media driver</a>.
        </irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Metz19" name="Metz19">
        <irp:irp><![CDATA[{37.9k,106,msb}<4,-9|4,-16>((8,-22,T:1,D:3,~D:3,F:6,~F:6,4,-125m)*,T=1-T)[D:0..7,F:0..63,T@:0..1=0]]]></irp:irp>
        <irp:documentation>The toggle bit T is inverted each time a new button press occurs.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Mitsubishi" name="Mitsubishi">
        <irp:parameter name="uei-executor">0014</irp:parameter>
        <irp:irp><![CDATA[{32.6k,300}<1,-3|1,-7>(D:8,F:8,1,-80)* [D:0..127,F:0..255]]]></irp:irp>
        <irp:documentation>This is not a robust protocol, so <A href="#spurious">spurious decodes</A> are likely.  It is also very similar in structure and timing to <A href="#JVC">JVC{2}</A> protocol, so that DecodeIr has difficulty distinguishing one from the other.  The device number, OBC and EFC are all encoded the same way between the two.  So if you have Mitsubishi decodes that you have reason to suspect should actually be JVC, you can try using them as JVC without changing the numbers.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="MitsubishiK" name="Mitsubishi-K">
        <irp:irp><![CDATA[{37k,432}<1,-1|1,-3>(8,-4,35:8,203:8,X:4,D:8,S:8,F:8,T:4,1,-100)* {X=6,T=-S:4:0-S:4:4-F:4:0-F:4:4+15}[D:0..255,F:0..255, S:0..255]]]></irp:irp>
        <irp:documentation>Mitsubishi-K is the member of the <a href="#Kaseikyo">Kaseikyo</a> family with OEM_code1=35 and OEM_code2=203.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="NEC" name="NEC">
        <irp:parameter name="prefer-over">NEC-Shirriff-32</irp:parameter>
        <!--irp:parameter name="prefer-over">NEC1</irp:parameter>
        <irp:parameter name="prefer-over">NEC2</irp:parameter-->
        <irp:parameter name="prefer-over">NEC1-f16</irp:parameter>
        <irp:parameter name="prefer-over">Pioneer</irp:parameter>
        <irp:parameter name="prefer-over">Roku</irp:parameter>
        <irp:parameter name="decode-only">true</irp:parameter>
        <irp:irp><![CDATA[{38.4k,564}<1,-1|1,-3>(16,-8,D:8,S:8,F:8,~F:8,1,^108m) [D:0..255,S:0..255=255-D,F:0..255]]]></irp:irp>
        <irp:documentation>Analogous to DecodeIR, we call a NEC signal without repeat "NEC".</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="NECShirriff" name="NEC-Shirriff">
        <irp:irp><![CDATA[{38.4k,msb,564}<1,-1|1,-3>(16,-8,data:length,1,-1) [data:0..UINT32_MAX,length:1..64]]]></irp:irp>
        <irp:parameter name="decodable">false</irp:parameter>
        <irp:documentation>Like <a href="#NEC1">NEC1</a> but without repeat, just one large parameter, and msb bit order, and no sensible ending silence.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="NECShirriff32" name="NEC-Shirriff-32">
        <irp:irp><![CDATA[{38.4k,msb,564}<1,-1|1,-3>(16,-8,data:32,1,-1) [data:0..UINT32_MAX]]]></irp:irp>
        <irp:documentation>Like <a href="#NEC1">NEC1</a> but without repeat, just one large parameter, and msb bit order, and no sensible ending silence..</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="NEC1" name="NEC1">
        <irp:parameter name="prefer-over">NEC1-f16</irp:parameter>
        <irp:parameter name="prefer-over">Pioneer</irp:parameter>
        <irp:parameter name="reject-repeatless">true</irp:parameter>
        <!--irp:parameter name="frequencyTolerance">100</irp:parameter>
        <irp:parameter name="relative-tolerance">0.04</irp:parameter>
        <irp:parameter name="absolute-tolerance">20</irp:parameter-->
        <irp:irp><![CDATA[{38.4k,564}<1,-1|1,-3>(16,-8,D:8,S:8,F:8,~F:8,1,^108m,(16,-4,1,^108m)*) [D:0..255,S:0..255=255-D,F:0..255]]]></irp:irp>
        <irp:documentation>A few devices use NEC1 protocol at 40Khz, rather than the typical frequency.  When getting a decode of NEC1, if you notice that the frequency is closer to 40Khz than to 38Khz, examine multiple learns from the same device to estimate whether the 40Khz frequency is a learning error or a true characteristic of the device. If the 40Khz is correct, there are methods in JP1, or MakeHex (whichever you are using) to reproduce NEC1 at 40Khz rather than the usual frequency.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="NEC1f16" name="NEC1-f16">
        <irp:parameter name="prefer-over">NEC-Shirriff-32</irp:parameter>
        <irp:irp><![CDATA[{38.4k,564}<1,-1|1,-3>(16,-8,D:8,S:8,F:16,1,^108m,(16,-4,1,^108m)*) [D:0..255,S:0..255=255-D,F:0..65535]]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol c-name="NEC1rnc" name="NEC1-rnc">
        <irp:parameter name="prefer-over">NEC1-f16</irp:parameter>
        <irp:parameter name="prefer-over">NEC-Shirriff-32</irp:parameter>
        <irp:irp><![CDATA[{38.4k,564}<1,-1|1,-3>(16,-8,D:8,S:8,F:8,~F:4:4,~F:4,1,^108m,(16,-4,1,^108m)*) [D:0..255,S:0..255=255-D,F:0..255]]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol c-name="NEC2" name="NEC2">
        <irp:parameter name="prefer-over">NEC-Shirriff-32</irp:parameter>
        <irp:parameter name="prefer-over">Pioneer</irp:parameter>
        <irp:parameter name="reject-repeatless">true</irp:parameter>
        <irp:irp><![CDATA[{38.4k,564}<1,-1|1,-3>(16,-8,D:8,S:8,F:8,~F:8,1,^108m)* [D:0..255,S:0..255=255-D,F:0..255]]]></irp:irp>
        <irp:documentation>
            <a href="#Pioneer">Pioneer</a> is distinguished from NEC2 only by frequency.  So if your learning system does not learn frequency accurately, it won't accurately distinguish Pioneer from NEC2.  All Pioneer signals should have a device number in the range 160 to 175 and no subdevice.  No NEC2 signal should fit those rules.  So you usually can determine whether the decision (by frequency) was wrong by checking the device numbers.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="NECx1" name="NECx1">
        <irp:parameter name="reject-repeatless">true</irp:parameter>
        <irp:irp><![CDATA[{38.4k,564}<1,-1|1,-3>(8,-8,D:8,S:8,F:8,~F:8,1,^108m,(8,-8,D:1,1,^108m)*) [D:0..255,S:0..255=255-D,F:0..255]]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol c-name="NECx2" name="NECx2">
        <irp:parameter name="reject-repeatless">true</irp:parameter>
        <irp:irp><![CDATA[{38.4k,564}<1,-1|1,-3>(8,-8,D:8,S:8,F:8,~F:8,1,^108m)* [D:0..255,S:0..255=255-D,F:0..255]]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol c-name="Nokia" name="Nokia">
        <irp:irp><![CDATA[{36k,1p,msb}<6,-10|6,-16|6,-22|6,-28>(15,-10,D:8,S:8,F:8,6,^100m)* [D:0..255,S:0..255,F:0..255]]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol c-name="Nokia12" name="Nokia12">
        <irp:irp><![CDATA[{36k,1p,msb}<6,-10|6,-16|6,-22|6,-28>(15,-10,D:4,F:8,6,^100m)*[D:0..15,F:0..255]]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol c-name="Nokia32" name="Nokia32">
        <irp:parameter name="absolute-tolerance">50</irp:parameter>
        <irp:parameter name="relative-tolerance">0.04</irp:parameter>
        <irp:irp><![CDATA[{36k,1p,msb}<6,-10|6,-16|6,-22|6,-28>((15,-10,D:8,S:8,T:1,X:7,F:8,6,^100m)*,T=1-T) [D:0..255,S:0..255,F:0..255,T@:0..1=0,X:0..127]]]></irp:irp>
        <irp:documentation>The Nokia32 protocol is one variation of the RCMM 1.5 protocol developed by Philips.  RCMM refers to X as "System" and to D:2,S:4:4 as "Customer". The parameters have been taken from <a href="http://www.sbprojects.com/knowledge/ir/rcmm.php">here</a>.</irp:documentation>
    </irp:protocol>
    <irp:protocol name="Nova Pace" c-name="NovaPace">
        <irp:irp><![CDATA[
    {38k, 300, msb}<-1,1|1,-1>((1,-1,D:10, S:8, F:8, T:1, -1, 1,-82m)*,T=1-T)
            [D:0..1023,S:0..255,F:0..255,T@:0..1=0]
            ]]></irp:irp>
            <irp:documentation>
                <a href="http://www.hifi-remote.com/forums/viewtopic.php?t=16645">Forum thread.</a>
            </irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="NRC16" name="NRC16">
        <irp:parameter name="uei-executor">00B0</irp:parameter>
        <irp:irp><![CDATA[{38k,500}<-1,1|1,-1>(1,-5,1:1,254:8,127:7,-15m,(1,-5,1:1,F:8,D:7,-110m)+,1,-5,1:1,254:8,127:7,-15m) [D:0..127,F:0..255]]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol c-name="NRC1632" name="NRC16-32">
        <irp:parameter name="uei-executor">0075</irp:parameter>
        <irp:irp><![CDATA[{32k,500}<-1,1|1,-1>(1,-5,1:1,254:8,127:7,-15m,(1,-5,1:1,F:8,D:7,-110m)+,1,-5,1:1,254:8,127:7,-15m) [D:0..127,F:0..255]]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol c-name="NRC17" name="NRC17">
        <irp:parameter name="uei-executor">00BD</irp:parameter>
        <irp:irp><![CDATA[{500,38k,25%}<-1,1|1,-1>(1,-5,1:1,254:8,255:8,-28, (1,-5,1:1,F:8,D:8,-220)+, 1,-5,1:1,254:8,255:8,-200)[D:0..255,F:0..255]]]></irp:irp>
        <irp:documentation>Taken from <a href="http://www.hifi-remote.com/forums/viewtopic.php?t=1044">John Fine's contribution</a> (fixed), modified for the setup <a href="http://www.sbprojects.com/knowledge/ir/nrc17.php">here</a>.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="OrtekMCE" name="OrtekMCE">
        <irp:parameter name="uei-executor">01ED</irp:parameter>
        <irp:irp><![CDATA[{38.6k,480}<1,-1|-1,1>([P=0][P=1][P=2],4,-1,D:5,P:2,F:6,C:4,-48m)+{C=3+#D+#P+#F}[D:0..31,F:0..63]]]></irp:irp>
        <irp:documentation>The <A href="#repeat">repeat frames</A> are not all identical. P is a position code: 0 for the start frame of a repeat sequence, 2 for the end frame and 1 for all frames in between. C is a checksum, 3 more than the number of 1 bits in D, P, F together.  DecodeIR v2.37 and later check P and will report in the Misc field if either the start or end frame, or both, is/are missing.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="PaceMSS" name="PaceMSS">
        <irp:parameter name="alt_name">Pace</irp:parameter>
        <irp:parameter name="uei-executor">0095</irp:parameter>
        <irp:irp><![CDATA[{38k,630,msb}<1,-7|1,-11>(1,-5,1,-5,T:1,D:1,F:8,1,^120m)* [D:0..1,F:0..255,T:0..1]]]></irp:irp>
        <irp:documentation>This is a moderately robust protocol, but <A href="#spurious">spurious decodes</A> are still possible.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Panasonic" name="Panasonic">
        <irp:parameter name="uei-executor">001F</irp:parameter>
        <irp:parameter name="uei-executor">00C9</irp:parameter>
        <irp:parameter name="uei-executor">00CD</irp:parameter>
        <irp:parameter name="prefer-over">Kaseikyo</irp:parameter>
        <irp:irp><![CDATA[{37k,432}<1,-1|1,-3>(8,-4,2:8,32:8,D:8,S:8,F:8,(D^S^F):8,1,-173)* [D:0..255,S:0..255,F:0..255]]]></irp:irp>
        <irp:documentation>Panasonic protocol is the most commonly seen member of the <a href="#Kaseikyo">Kaseikyo</a> family.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Panasonic2" name="Panasonic2">
        <irp:parameter name="uei-executor">0109</irp:parameter>
        <irp:parameter name="prefer-over">Kaseikyo56</irp:parameter>
        <irp:irp><![CDATA[{37k,432}<1,-1|1,-3>(8,-4,2:8,32:8,D:8,S:8,X:8,F:8,(D^S^X^F):8,1,-173)* [D:0..255,S:0..255,F:0..255,X:0..255]]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol c-name="Panasonic_Old" name="Panasonic_Old">
        <irp:parameter name="uei-executor">0000</irp:parameter>
        <irp:parameter name="uei-executor">0087</irp:parameter>
        <irp:irp><![CDATA[{57.6k,833}<1,-1|1,-3>(4,-4,D:5,F:6,~D:5,~F:6,1,-44m)* [D:0..31,F:0..63]]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol c-name="PCTV" name="PCTV">
        <irp:irp><![CDATA[{38.4k,832}<-1|1>(2,-8,1,D:8,F:8,2,-100m) [D:0..255,F:0..255]]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol c-name="pid0001" name="pid-0001">
        <irp:parameter name="uei-executor">0001</irp:parameter>
        <irp:irp><![CDATA[{0k,msb}<24,-9314|24,-13486>(24,-21148,(F:5,1,-28m)+)[F:0..31]]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol c-name="pid0003" name="pid-0003">
        <irp:parameter name="uei-executor">0003</irp:parameter>
        <irp:irp><![CDATA[{40.2k,389}<2,-2|3,-1>(F:8,~F:8,^102m)*[F:0..255]]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol c-name="pid0004" name="pid-0004">
        <irp:parameter name="uei-executor">0004</irp:parameter>
        <irp:irp><![CDATA[{0k,msb}<12,-130|12,-372>(F:6,12,-27m)*[F:0..63]]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol c-name="pid0083" name="pid-0083">
        <irp:parameter name="uei-executor">0083</irp:parameter>
        <irp:irp><![CDATA[{42.3k, 3000}<1,-3,1,-7|1,-7,1,-3>(F:5,1,-27)*[F:0..31]]]></irp:irp>
        <irp:documentation>This protocol is a very limited design.  We have seen it used only in the UEI setup code TV/0159, which is for some TVs brand named Fisher, Sanyo and Sears.  It is not likely that any other code set uses this protocol.  So if you get a correct decode of pid-0083 you probably have a TV that can be controlled by the TV/0159 setup code.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Pioneer" name="Pioneer">
        <irp:parameter name="uei-executor">00E2</irp:parameter>
        <irp:irp><![CDATA[{40k,564}<1,-1|1,-3>(16,-8,D:8,S:8,F:8,~F:8,1,^108m)* [D:0..255,S:0..255=255-D,F:0..255]]]></irp:irp>
        <irp:documentation>Pioneer is distinguished from <a href="#NEC2">NEC2</a> only by frequency.  So if your learning system does not learn frequency accurately, it won't accurately distinguish Pioneer from NEC2.  All Pioneer signals should have a device number in the range 160 to 175 and no subdevice.  No NEC2 signal should fit those rules.  So you usually can determine whether the decision (by frequency) was wrong by checking the device numbers.

Many Pioneer commands are sent as combinations of two different Pioneer signals.  This version of DecodeIr does not associate the two signals together into one command. It decodes them separately. If you get more than one of the same OBC from decoding a learned signal, that just means the learning system failed to understand the repeat pattern. It does not mean a two part signal. But if there are two different OBCs (with the same or different device numbers) you have a two part Pioneer signal.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="PioneerMix" name="Pioneer-Mix">
        <irp:irp><![CDATA[{40k,564}<1,-1|1,-3>(16,-8,D0:8,~D0:8,F0:8,~F0:8,1,^108m,(16,-8,D:8,~D:8,F:8,~F:8,1,^108m)+) [D0:0..255,F0:0..255,D:0..255=D0,F:0..255=F0]]]></irp:irp>
        <irp:documentation>Two-signal version of the <a href="#Pioneer">Pioneer</a> protocol;
        first sends the "normal" signal (parameters D0 and F0), then, as repeat, the one determined by D and F.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Proton" name="Proton">
        <irp:parameter name="uei-executor">005C</irp:parameter>
        <irp:irp><![CDATA[{38.5k,500}<1,-1|1,-3>(16,-8,D:8,1,-8,F:8,1,^63m)*[D:0..255,F:0..255]]]></irp:irp>
        <irp:documentation>This is not a robust protocol, so <A href="#spurious">spurious decodes</A> are likely.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Proton40" name="Proton-40">
        <irp:parameter name="uei-executor">005C</irp:parameter>
        <irp:irp><![CDATA[{40.5k,500}<1,-1|1,-3>(16,-8,D:8,1,-8,F:8,1,^63m)*[D:0..255,F:0..255]]]></irp:irp>
        <irp:documentation>This is not a robust protocol, so <A href="#spurious">spurious decodes</A> are likely.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="RC5" name="RC5">
        <irp:parameter name="uei-executor">00E8</irp:parameter>
        <irp:irp><![CDATA[{36k,msb,889}<1,-1|-1,1>((1,~F:1:6,T:1,D:5,F:6,^114m)*,T=1-T)[D:0..31,F:0..127,T@:0..1=0]]]></irp:irp>
        <irp:documentation>In Philips' (the creator of the protocol) terminology, "D" is called "System" and "F" is called "Command".</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="RC57F" name="RC5-7F">
        <irp:parameter name="prefer-over">StreamZap</irp:parameter> <!-- like DecodeIR -->
        <irp:parameter name="uei-executor">0182</irp:parameter>
        <irp:irp><![CDATA[{36k,msb,889}<1,-1|-1,1>((1, ~D:1:5,T:1,D:5,F:7,^114m)*,T=1-T) [D:0..63,F:0..127,T@:0..1=0]]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol c-name="RC57F57" name="RC5-7F-57">
        <irp:parameter name="prefer-over">StreamZap-57</irp:parameter> <!-- like DecodeIR -->
        <irp:parameter name="uei-executor">0182</irp:parameter>
        <irp:irp><![CDATA[{57k,msb,889}<1,-1|-1,1>(1, ~D:1:5,T:1,D:5,F:7,^114m)*[D:0..63,F:0..127,T@:0..1=0]]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol c-name="RC5x" name="RC5x">
        <irp:parameter name="uei-executor">00F2</irp:parameter>
        <irp:irp><![CDATA[{36k,msb,889}<1,-1|-1,1>((1,~S:1:6,T:1,D:5,-4,S:6,F:6,^114m)*,T=1-T) [D:0..31,S:0..127,F:0..63,T@:0..1=0]]]></irp:irp>
        <irp:documentation>In Philips' (the creator of the protocol) terminology, "D" is called "System", "S" is called "Command", and is called "Data".</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="RC6" name="RC6">
        <irp:parameter name="uei-executor">0058</irp:parameter>
        <irp:parameter name="prefer-over">RC6-M-16</irp:parameter>
        <irp:parameter name="absolute-tolerance">300</irp:parameter>
        <irp:irp><![CDATA[{36k,444,msb}<-1,1|1,-1>((6,-2,1:1,0:3,<-2,2|2,-2>(T:1),D:8,F:8,^107m)*,T=1-T) [D:0..255,F:0..255,T@:0..1=0]]]></irp:irp>
        <irp:documentation>RC6 is the name used for the first member of the RC6 family of protocols.  Technically this is RC6-0-16, but DecodeIr will always display that as simply "RC6"</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="RC6620" name="RC6-6-20">
        <irp:parameter name="uei-executor">0020</irp:parameter>
        <irp:parameter name="absolute-tolerance">300</irp:parameter>
        <irp:irp><![CDATA[{36k,444,msb}<-1,1|1,-1>((6,-2,1:1,6:3,<-2,2|2,-2>(T:1),D:8,S:4,F:8,-100m)*,T=1-T)[D:0..255,S:0..15,F:0..255,T@:0..1=0]]]></irp:irp>
        <irp:documentation>This protocol is commonly used in Sky and Sky+ remotes.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="RC6M16" name="RC6-M-16">
        <irp:parameter name="absolute-tolerance">300</irp:parameter>
        <irp:irp><![CDATA[{36k,444,msb}<-1,1|1,-1>((6,-2,1:1,M:3,<-2,2|2,-2>(T:1),D:8,F:8,^107m)*,T=1-T) [D:0..255,F:0..255,M:0..7,T@:0..1=0]]]></irp:irp>
        <irp:documentation></irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="RC6M28" name="RC6-M-28">
        <irp:parameter name="absolute-tolerance">300</irp:parameter>
        <irp:irp><![CDATA[{36k,444,msb}<-1,1|1,-1>((6,-2,1:1,M:3,<-2,2|2,-2>(T:1),D:8,S:12,F:8,-100m)*,T=1-T)[D:0..255,S:0..4095,F:0..255,M:0..7,T@:0..1=0]]]></irp:irp>
    </irp:protocol>
    <irp:protocol c-name="RC6M32" name="RC6-M-32">
        <irp:parameter name="uei-executor">012A</irp:parameter>
        <irp:parameter name="EFC_translation">MSB</irp:parameter>
        <irp:parameter name="absolute-tolerance">300</irp:parameter>
        <irp:irp><![CDATA[
{36k,444,msb}<-1,1|1,-1>((6,-2,1:1,M:3,<-2,2|2,-2>(T:1),OEM1:8,OEM2:8,D:8,F:8,^107m)*,T=1-T)[OEM1:0..255,OEM2:0..255,D:0..255,F:0..255,M:0..7,T@:0..1=0]
]]></irp:irp>
        <irp:documentation>This is the generic form for a decode of protocols in the RC6
family, restricted to 32 bits. DecodeIr uses this form for all RC6 decodes, except RC6-0-16
which is displayed as simply "RC6", RC6-6-24 which is displayed as
            <a href="#Replay">Replay</a> and some RC6-6-32 which is displayed as <a href="#MCE">MCE</a>.
        </irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="RC6M56" name="RC6-M-56" usable="true">
        <irp:parameter name="absolute-tolerance">300</irp:parameter>
        <irp:irp><![CDATA[{36k,444,msb}<-1,1|1,-1>(6,-2,1:1,M:3,<-2,2|2,-2>(T:1),C:56,-131.0m)*[M:0..7,T@:0..1=0,C:0..72057594037927935]]]></irp:irp>
        <irp:documentation>This is the "RC6-?-?? protocol" made usable for the case of ??=56.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="RCA" name="RCA">
        <irp:irp><![CDATA[{58k,460,msb}<1,-2|1,-4>(8,-8,D:4,F:8,~D:4,~F:8,1,-16)*[D:0..15,F:0..255]]]></irp:irp>
        <irp:parameter name="uei-executor">00af</irp:parameter>
        <irp:parameter name="uei-executor">0114</irp:parameter>
        <irp:documentation>These are two very similar forms of RCA protocol which differ only in that RCA(Old) has an extended lead-in and a double-length ON pulse before the lead-out.  They are so similar that most RCA devices will accept either.  But some RCA devices only accept the one that really matches their own remote.  In versions of DecodeIR prior to v2.40, RCA(Old) was decoded as a frame of RCA{1} followed usually by a frame of RCA.  The second frame now no longer appears, so the protocol has been renamed to correspond to that used in KM and RM.

Note (BM): One entry split into two.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="RCAOld" name="RCA(Old)">
        <irp:parameter name="uei-executor">002d</irp:parameter>
        <irp:parameter name="uei-executor">0114</irp:parameter>
        <irp:irp><![CDATA[{58k,460,msb}<1,-2|1,-4>([40][8],-8,D:4,F:8,~D:4,~F:8,2,-16)[D:0..15,F:0..255]]]></irp:irp>
        <irp:documentation>These are two very similar forms of RCA protocol which differ only in that RCA(Old) has an extended lead-in and a double-length ON pulse before the lead-out.  They are so similar that most RCA devices will accept either.  But some RCA devices only accept the one that really matches their own remote.  In versions of DecodeIR prior to v2.40, RCA(Old) was decoded as a frame of RCA{1} followed usually by a frame of RCA.  The second frame now no longer appears, so the protocol has been renamed to correspond to that used in KM and RM.

Note (BM): One entry split into two.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="RCA38" name="RCA-38">
        <!--irp:parameter name="uei-executor">not known</irp:parameter-->
        <irp:irp><![CDATA[{38.7k,460,msb}<1,-2|1,-4>(8,-8,D:4,F:8,~D:4,~F:8,1,-16)*[D:0..15,F:0..255]]]></irp:irp>
        <irp:documentation>These are recently discovered variants of the RCA protocol.  They differ from RCA and RCA(Old) only in the frequency, which is 38.7kHz instead of the standard 58kHz.

Note (BM): One entry split into two.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="RCA38Old" name="RCA-38(Old)">
        <!--irp:parameter name="uei-executor">not known</irp:parameter-->
        <irp:irp><![CDATA[{38.7k,460,msb}<1,-2|1,-4>([40][8],-8,D:4,F:8,~D:4,~F:8,2,-16)[D:0..15,F:0..255]]]></irp:irp>
        <irp:documentation>These are recently discovered variants of the RCA protocol.  They differ from RCA and RCA(Old) only in the frequency, which is 38.7kHz instead of the standard 58kHz.

Note (BM): One entry split into two.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="RECS80" name="RECS80">
        <irp:parameter name="prefer-over">RECS80-0045</irp:parameter> <!-- like DecodeIR -->
        <irp:irp><![CDATA[RECS80-0045{}[D:0..7,F:0..63, T@:0..1=0]]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol c-name="RECS800045" name="RECS80-0045">
        <irp:irp><![CDATA[{38k,158,msb}<1,-31|1,-47>(1:1,T:1,D:3,F:6,1,-45m)* [D:0..7,F:0..63, T@:0..1=0]]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol c-name="RECS800068" name="RECS80-0068">
        <irp:irp><![CDATA[{33.3k,180,msb}<1,-31|1,-47>(1:1,T:1,D:3,F:6,1,^138m)* [D:0..7,F:0..63, T@:0..1=0]]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol c-name="RECS800090" name="RECS80-0090">
        <irp:irp><![CDATA[{0k,158,msb}<1,-31|1,-47>(1:1,T:1,D:3,F:6,1,^138m)* [D:0..7,F:0..63, T@:0..1=0]]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol c-name="Replay" name="Replay">
        <irp:parameter name="alt_name">RC6-6-24</irp:parameter>
        <irp:parameter name="uei-executor">0092</irp:parameter>
        <irp:irp><![CDATA[{36k,444,msb}<-1,1|1,-1>(6,-2,1:1,6:3,<-2,2|2,-2>(T:1),D:8,S:8,F:8,-100m/*???*/)*[D:0..255,S:0..255,F:0..255,T@:0..1=0]]]></irp:irp>
        <irp:documentation>Replay is a member of the RC6 family.  Technically it is RC6-6-24, but DecodeIr will always display the name as "Replay".  ProntoEdit calls this protocol "RC6 mode 6A" and KM has it under the alternate name "RC-6a" as well as its primary name "Replay".  RM has it under the alternate name "RC6-M-24n" as well as its primary name "Replay".

In ProntoEdit, DecodeIr's "Device" is called "Customer Code"; DecodeIr's "Subdevice" is called "System"; and DecodeIr's "OBC" is called "Command".</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Revox" name="Revox">
        <irp:irp><![CDATA[{0k,15u}<1,-9|1,-19>(1,-29,0:1,D:4,F:6,1,-29,1,-100285u)*[D:0..15,F:0..63]]]></irp:irp>
        <irp:documentation>Revox uses no modulation.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Roku" name="Roku">
        <irp:irp><![CDATA[{38.0k,564}<1,-1|1,-3>(16,-8,D:8,S:8,F:7,0:1,~F:7,1:1,1,^108m, (16,-8,D:8,S:8,F:7,1:1,~F:7,0:1,1,^108m)*)[D:0..255,S:0..255=255-D,F:0..127]]]></irp:irp>
        <irp:documentation>This IR protocol is very similar to <a href="#NEC2">NEC2</a>,
        except the repeat behavior is different. The second and additional frames of a repeating signal send the OBC + 128.
<a href="http://www.hifi-remote.com/forums/viewtopic.php?p=115990#115990">Reference</a>.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Rs200" name="Rs200">
        <irp:irp><![CDATA[{35.7k,msb}<50p,-120p|21p,-120p>(25:6,(H4-1):2,(H3-1):2,(H2-1):2,(H1-1):2,P:1,(D-1):3,F:2,0:2,sum:4,-1160p)*{   P=~(#(D-1)+#F):1,sum=9+((H4-1)*4+(H3-1)) + ((H2-1)*4+(H1-1)) + (P*8+(D-1)) + F*4}[H1:1..4, H2:1..4, H3:1..4, H4:1..4, D:1..6, F:0..2]]]></irp:irp>
        <irp:documentation>This protocol is/was used by the so-called RS-200 RF (433MHz) controlled switches, that was sold by Conrad Electronics. There is a "house number" consisting of for digits, each in the range 1 to 4. These are called H1, H2, H3, and H4 in the IRP. There is also a "device address". Officially, it ranges from 1 to 4, however, at least on the hardware I tried, 5 can also be used and assigned to a receiver. Also, 6 was working, and in fact controlled the "group" consisting of all devices with address 1,...,5. For 7 and 8, no function has been verified. F=0 is the power on command, F=1 the power off command, and F=2 the power toggle command.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Sampo" name="Sampo">
        <irp:irp><![CDATA[{38.4k, 833}<1,-1|1,-3>(4,-4,D:6,F:6,S:6,~F:6,1,-39)*[D:0..63,S:0..63,F:0..63]]]></irp:irp>
        <irp:documentation>This is a moderately robust protocol, but <A href="#spurious">spurious decodes</A> are still possible.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Samsung20" name="Samsung20">
        <irp:parameter name="uei-executor">002F</irp:parameter>
        <irp:irp><![CDATA[{38.4k,564}<1,-1|1,-3>(8,-8,D:6,S:6,F:8,1,^100m)*[D:0..63,S:0..63,F:0..255]]]></irp:irp>
        <irp:documentation>This is a moderately robust protocol, but <A href="#spurious">spurious decodes</A> are still possible.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Samsung36" name="Samsung36">
        <irp:parameter name="uei-executor">01B5</irp:parameter>
        <irp:parameter name="relative-tolerance">0.2</irp:parameter>
        <irp:irp><![CDATA[{37.9k,560,33%}<1,-1|1,-3>(4500u,-4500u,D:8,S:8,1,-9,E:4,F:8,~F:8,1,^108m)*[D:0..255,S:0..255,F:0..255,E:0..15]]]></irp:irp>
        <irp:documentation>
            <a href="http://elektrolab.wz.cz/katalog/samsung_protocol.pdf">Reference</a>.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="ScAtl6" name="ScAtl-6">
        <irp:parameter name="uei-executor">0078</irp:parameter>
        <irp:irp><![CDATA[{57.6k,846}<1,-1|1,-3>(4,-4,D:6,F:6,~D:6,~F:6,1,-40)*[D:0..63,F:0..63]]]></irp:irp>
        <irp:documentation>ScAtl-6 is distinguished from <a href="#Emerson">Emerson</a> only by frequency. So if you are using a learning system that doesn't record the frequency accurately, then DecodeIr can't accurately select between Emerson and ScAtl-6.

        Most Scientific Atlanta cable tuners use <a href="#Panasonic_Old">Panasonic_Old</a> protocol, not this protocol.</irp:documentation>
    </irp:protocol>
    <irp:protocol name="Sejin-1-38" c-name="Sejin_1_38">
        <irp:parameter name="uei-executor">0161</irp:parameter>
        <irp:parameter name="prefer-over">Sejin-1-56</irp:parameter>
        <irp:irp><![CDATA[
    {38.8k,310,msb}<-1|1>(<8:4|4:4|2:4|1:4>(3,3:2,D:8,F:8,S:8,E:4,C:4,-77))*
    {C = D:4 + D:4:4 + F:4 + F:4:4 + S:4 + S:4:4 + E}
    [D:0..255, S:0..255, F:0..255, E:0..15=0]
            ]]></irp:irp>
            <irp:documentation>This is the Sejin-1 version from
                <a href="http://www.hifi-remote.com/wiki/index.php?title=DecodeIR#Sejin-M-38_and_Sejin-M-56">DecodeIR</a>,
            with the following substitutions: Dx -&gt; D, Fx -&gt; F, Fy -&gt; S, L = 77.
                (Teaser uses a slightly different parameterization.)
            </irp:documentation>
    </irp:protocol>
    <irp:protocol name="Sejin-1-56" c-name="Sejin_1_56">
        <irp:parameter name="uei-executor">0161</irp:parameter>
        <irp:irp><![CDATA[
    {56.3k,310,msb}<-1|1>(<8:4|4:4|2:4|1:4>(3,3:2,D:8,F:8,S:8,E:4,C:4,-77))*
    {C = D:4 + D:4:4 + F:4 + F:4:4 + S:4 + S:4:4 + E}
    [D:0..255, S:0..255, F:0..255, E:0..15=0]
            ]]></irp:irp>
            <irp:documentation>This is the Sejin-1 version from
                <a href="http://www.hifi-remote.com/wiki/index.php?title=DecodeIR#Sejin-M-38_and_Sejin-M-56">DecodeIR</a>,
            with the following substitutions: Dx -&gt; D, Fx -&gt; F, Fy -&gt; S, L = 77.
                (Teaser uses a slightly different parameterization.)
            </irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Sharp" name="Sharp">
        <irp:irp><![CDATA[{38k,264}<1,-3|1,-7>(D:5,F:8,1:2,1,-165,D:5,~F:8,2:2,1,-165)*[D:0..31,F:0..255]]]></irp:irp>
        <irp:documentation>A Sharp signal, which is identical to <a href="#Denon">Denon</a>, has two halves, either one of which is enough to fully decode the information. A significant fraction of Sharp learned signals contain just one half or have the halves separated so that DecodeIr can't process them together. When one half is seen separate from the other, DecodeIr will name the protocol Sharp{1} or Sharp{2} depending on which half is decoded. Sharp, Sharp{1} and Sharp{2} all represent the same protocol when they are correct.  But only Sharp is robust. A Sharp{1} or Sharp{2} decode might be <A href="#spurious">spurious</A>.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="SharpDVD" name="SharpDVD">
        <irp:parameter name="uei-executor">00F8</irp:parameter>
        <irp:parameter name="prefer-over">Kaseikyo</irp:parameter>
        <irp:irp><![CDATA[{38k,400}<1,-1|1,-3>(8,-4,170:8,90:8,15:4,D:4,S:8,F:8,E:4,C:4,1,-48)*{C = D ^ S:4:0 ^ S:4:4 ^ F:4:0 ^ F:4:4 ^ E:4}[D:0..15,S:0..255,F:0..255,E:0..15=1]]]></irp:irp>
        <irp:documentation>SharpDVD is the member of the <a href="#Kaseikyo">Kaseikyo</a> family with OEM_code1=170 and OEM_code2=90. E=1 in all instances seen so far.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Sharp1" name="Sharp{1}">
        <irp:irp><![CDATA[{38k,264}<1,-3|1,-7>(D:5,F:8,1:2,1,-165)*[D:0..31,F:0..255]]]></irp:irp>
        <irp:documentation>A Sharp signal has two halves, either one of which is enough to fully decode the information. A significant fraction of Sharp learned signals contain just one half or have the halves separated so that DecodeIr can't process them together. When one half is seen separate from the other, DecodeIr will name the protocol Sharp{1} or Sharp{2} depending on which half is decoded. Sharp, Sharp{1} and Sharp{2} all represent the same protocol when they are correct.  But only Sharp is robust. A Sharp{1} or Sharp{2} decode might be <A href="#spurious">spurious</A>.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Sharp2" name="Sharp{2}">
        <irp:irp><![CDATA[{38k,264}<1,-3|1,-7>(D:5,~F:8,2:2,1,-165)*[D:0..31,F:0..255]]]></irp:irp>
        <irp:documentation>A Sharp signal has two halves, either one of which is enough to fully decode the information. A significant fraction of Sharp learned signals contain just one half or have the halves separated so that DecodeIr can't process them together. When one half is seen separate from the other, DecodeIr will name the protocol Sharp{1} or Sharp{2} depending on which half is decoded. Sharp, Sharp{1} and Sharp{2} all represent the same protocol when they are correct.  But only Sharp is robust. A Sharp{1} or Sharp{2} decode might be <A href="#spurious">spurious</A>.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="SIM2" name="SIM2">
        <irp:irp><![CDATA[{38.8k,400}<3,-3|3,-7>(6,-7,D:8,F:8,3,^115m)[D:0..255=236,F:0..255]]]></irp:irp>
        <irp:documentation>
            <a href="http://www2.aerne.com/Public/dok-sw.nsf/0c6187bc750a16fcc1256e3c005a9740/a17a3bd85a29f8e5c1257227004dfdf8/$FILE/SIM2%20Remote%20Control%20Spec.%201.1.pdf">Reference</a>.
            In  that document, there is a contradiction between the verbal description and the Pronto Hex code given.
Here we follow the Pronto form, which is also consistent with DecodeIR.
        </irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Solidtek16" name="Solidtek16" usable="true">
        <irp:irp><![CDATA[{38k}<-624,468|468,-624>(S=0,(1820,-590,0:1,D:4,F:7,S:1,C:4,1:1,-143m,S=1)3) {C= F:4:0 + F:3:4 + 8*S } [D:0..15, F:0..127]]]></irp:irp>
        <irp:documentation>This is a keyboard protocol.  The make/break bit is decoded into the subdevice field.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Somfy" name="Somfy">
        <irp:irp><![CDATA[{35.7k}<308,-881|669,-520>(2072,-484,F:2,D:3,C:4,-2300)*{C = F*4 + D + 3}[F:0..3,D:0..7]]]></irp:irp>
        <irp:documentation>C is reported as SubDevice.  It is probably a check nibble {C = F*4 + D + 3}. F = 1 for UP or 2 for DOWN. D = 1, 2 or 3 for the three observed devices, or D = 0 to control all devices together.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Sony12" name="Sony12">
        <irp:parameter name="uei-executor">00CA</irp:parameter>
        <irp:irp><![CDATA[{40k,600}<1,-1|2,-1>(4,-1,F:7,D:5,^45m)*[D:0..31,F:0..127]]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol c-name="Sony15" name="Sony15">
        <irp:parameter name="uei-executor">00CA</irp:parameter>
        <irp:irp><![CDATA[{40k,600}<1,-1|2,-1>(4,-1,F:7,D:8,^45m)*[D:0..255,F:0..127]]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol c-name="Sony20" name="Sony20">
        <irp:parameter name="uei-executor">00DE</irp:parameter>
        <irp:irp><![CDATA[{40k,600}<1,-1|2,-1>(4,-1,F:7,D:5,S:8,^45m)*[D:0..31,S:0..255,F:0..127]]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol c-name="Sony8" name="Sony8">
        <irp:irp><![CDATA[{40k,600}<1,-1|2,-1>(4,-1,F:8,^45m)[F:0..255]]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol c-name="StreamZap" name="StreamZap">
        <irp:irp><![CDATA[{36k,msb,889}<1,-1|-1,1>(1,~F:1:6,T:1,D:6,F:6,^114m)*[D:0..63,F:0..63,T:0..1]]]></irp:irp>
        <irp:documentation>DecodeIR V2.43 decodes this as <a href="#RC5-7F">RC5-7F</a>.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="StreamZap57" name="StreamZap-57">
        <irp:irp><![CDATA[{57k,msb,889}<1,-1|-1,1>(1,~F:1:6,T:1,D:6,F:6,^114m)*[D:0..63,F:0..63,T:0..1]]]></irp:irp>
        <irp:documentation>DecodeIR V2.43 decodes this as <a href="#RC5-7F-57">RC5-7F-57</a>.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Sunfire" name="Sunfire">
        <irp:irp><![CDATA[{38k,560,msb}<1,-1|3,-1>(16,-8, D:4,F:8,~D:4,~F:8, -32)*[D:0..15,F:0..255]]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol c-name="TDC38" name="TDC-38">
        <irp:irp><![CDATA[{38k,315,msb}<-1,1|1,-1>(1,-1,D:5,S:5,F:7,-89m)*[D:0..31,S:0..31,F:0..127]]]></irp:irp>
        <irp:documentation>There are two variants of this protocol, with different frequencies but with the same number of carrier cycles in each burst, which makes the duration of a burst also differ.  TDC-38 has a 38kHz carrier and is used by Danish TDC IPTV.  TDC-56 has a 56.3kHz carrier and is used by Italian ALICE Home TV box.  These implementations effectively use a 6-bit OBC as bit 0 of F is always the complement of bit 1, but there are other implementations which do not follow that pattern.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="TDC56" name="TDC-56">
        <irp:irp><![CDATA[{56.3k,213,msb}<-1,1|1,-1>(1,-1,D:5,S:5,F:7,-89m)*[D:0..31,S:0..31,F:0..127]]]></irp:irp>
        <irp:documentation>There are two variants of this protocol, with different frequencies but with the same number of carrier cycles in each burst, which makes the duration of a burst also differ.  TDC-38 has a 38kHz carrier and is used by Danish TDC IPTV.  TDC-56 has a 56.3kHz carrier and is used by Italian ALICE Home TV box.  These implementations effectively use a 6-bit OBC as bit 0 of F is always the complement of bit 1, but there are other implementations which do not follow that pattern.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="TeacK" name="Teac-K">
        <irp:parameter name="uei-executor">00BB</irp:parameter>
        <irp:irp><![CDATA[{37k,432}<1,-1|1,-3>(8,-4,67:8,83:8,X:4,D:4,S:8,F:8,T:8,1,-100,(8,-8,1,-100)*) {T=D+S:4:0+S:4:4+F:4:0+F:4:4} [D:0..15,S:0..255,F:0..255,X:0..15=1]]]></irp:irp>
        <irp:documentation>Teac-K is the member of the <a href="#Kaseikyo">Kaseikyo</a> family with OEM_code1=67 and OEM_code2=83.

Teac-K uses different repeat rules and a different check byte than other Kaseikyo protocols.

00BB requires 2-byte hex commands.  DecodeIr returns both hex cmd bytes through the interface that usually means one or the other (for mini combos) but in this case it means both.

This protocol signals repeats by the use of <A href="#repeat">dittos</A>.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Thomson" name="Thomson">
        <irp:parameter name="uei-executor">004B</irp:parameter>
        <irp:irp><![CDATA[{33k,500}<1,-4|1,-9>((D:4,T:1,D:1:4,F:6,1,^80m)*,T=1-T)[D:0..31,F:0..63,T@:0..1=0]]]></irp:irp>
        <irp:documentation>This is not a robust protocol, so <A href="#spurious">spurious decodes</A> are likely.

DecodeIR2.42 deprecates Thompson (5 bits of device, and 6 bits of function) and reports these signals as Thompson7 (4 bits of device and 7 bits of function).</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Thomson7" name="Thomson7">
        <irp:parameter name="prefer-over">Thomson</irp:parameter> <!-- like DecodeIR -->
        <irp:parameter name="uei-executor">004B</irp:parameter>
        <irp:irp><![CDATA[{33k,500}<1,-4|1,-9>((D:4,T:1,F:7,1,^80m)*,T=1-T) [D:0..15,F:0..127,T@:0..1=0]]]></irp:irp>
        <irp:documentation>DecodeIR2.42 deprecates Thompson (5 bits of device, and 6 bits of function) and reports these signals as Thompson7 (4 bits of device and 7 bits of function).</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Tivo" name="Tivo">
        <irp:parameter name="prefer-over">NEC1-f16</irp:parameter>
        <irp:irp><![CDATA[{38.4k,564}<1,-1|1,-3>(16,-8,D:8,S:8,F:8,U:4,~F:4:4,1,-78,(16,-4,1,-173)*) [D:133..133=133,S:48..48=48,F:0..255,U:0..15]]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol c-name="Velleman" name="Velleman">
        <irp:irp><![CDATA[{38k,msb}<700,-5060|700,-7590>(1:1,T:1,D:3,F:6,700,-55m)* [D:0..7,F:0..63,T@:0..1=0]]]></irp:irp>
        <irp:documentation>Very similar to RECS80-0045, except on duration is longer.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Velodyne" name="Velodyne">
        <irp:parameter name="relative-tolerance">0.04</irp:parameter>
        <irp:parameter name="absolute-tolerance">100</irp:parameter>
        <irp:irp><![CDATA[{38k,136,msb}<210u,-760u|210u,-896u|210u,-1032u|210u,-1168u|210u,-1304u|210u,-1449u|210u,-1576u|210u,-1712u|210u,-1848u|210u,-1984u|210u,-2120u|210u,-2256u|210u,-2392u|210u,-2528u|210u,-2664u|210u,-2800u>([T=0][T=8],S:4:4,~C:4,S:4,15:4,D:4,T:4,F:8,210u,-79m){C=(8+S:4+S:4:4+15+D+T+F:4+F:4:4)&15}[D:0..15,S:0..255,F:0..255]]]></irp:irp>
        <irp:documentation>Velodyne is a close relative of <a href="#XMP">XMP</a>.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Viewstar" name="Viewstar">
        <irp:parameter name="uei-executor">0021</irp:parameter>
        <irp:irp><![CDATA[{50.5k,337}<1,-8|1,-5>(~F:5,1,-17)*[F:0..31]]]></irp:irp>
        <irp:documentation>This is not a robust protocol, so <A href="#spurious">spurious decodes</A> are likely.</irp:documentation>
    </irp:protocol>
    <irp:protocol name="Whynter">
        <irp:irp><![CDATA[
         {38k,750,msb}<1,-1|1,-3>(0:1,4,-4,F:32,1,-50m)[F:0..0xFFFFFFFF]
  ]]>
        </irp:irp>
        <irp:documentation>From <a href="https://github.com/z3t0/Arduino-IRremote">IRremote</a>, see also
        <a href="https://github.com/z3t0/Arduino-IRremote/pull/105">this issue</a>.
        "Tested with Whynter ARC-110WD."</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="X10" name="X10">
        <irp:parameter name="uei-executor">01DF</irp:parameter>
        <irp:irp><![CDATA[{40.8k,565}<2,-12|7,-7>(7,-7,F:5,~F:5,21,-7)*[F:0..31]]]></irp:irp>
        <irp:documentation>These are two variants of the same Home Automation protocol.  They differ in that X10.<i>n</i> has a distinctive start frame that carries a sequence number, the <i>n</i> of the protocol name, in addition to the OBC.  The repeat frames, and all frames of the X10 version, only carry the OBC.  The value of <i>n</i> runs from 0 to 15 (or some lower value) and then restarts again at 0.  It is incremented on each successive keypress.  A valid X10.<i>n</i> signal must have at least one repeat frame.  If this is missing then the Misc column shows "invalid signal".

RemoteMaster has a single protocol, named X10 with PID 003F, that sends X10.<i>n</i> signals.  This is the same as the UEI protocol with that PID.  There is no control over the value of <i>n</i>, this is handled automatically by the remote.  The newer UEI protocol, with PID 01DF, sends X10 signals.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="X10n" name="X10.n">
        <irp:parameter name="uei-executor">003F</irp:parameter>
        <irp:irp><![CDATA[{40.8k,565}<2,-12|7,-7>(F:5,N:-4,21,-7,(7,-7,F:5,~F:5,21,-7)+)[F:0..31,N:0..15]]]></irp:irp>
        <irp:documentation>These are two variants of the same Home Automation protocol.  They differ in that X10.<i>n</i> has a distinctive start frame that carries a sequence number, the <i>n</i> of the protocol name, in addition to the OBC.  The repeat frames, and all frames of the X10 version, only carry the OBC.  The value of <i>n</i> runs from 0 to 15 (or some lower value) and then restarts again at 0.  It is incremented on each successive keypress.  A valid X10.<i>n</i> signal must have at least one repeat frame.  If this is missing then the Misc column shows "invalid signal".

RemoteMaster has a single protocol, named X10 with PID 003F, that sends X10.<i>n</i> signals.  This is the same as the UEI protocol with that PID.  There is no control over the value of <i>n</i>, this is handled automatically by the remote.  The newer UEI protocol, with PID 01DF, sends X10 signals.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="X10_18" name="X10_18">
        <irp:irp><![CDATA[{40.8k,565}<2,-12|7,-7>(7,-7,F:9,~F:9,21,-7)*[F:0..511]]]></irp:irp>
    </irp:protocol>
    <irp:protocol c-name="X10_8" name="X10_8">
        <irp:irp><![CDATA[{40.8k,565}<2,-12|7,-7>(7,-7,F:4,~F:4,21,-7)*[F:0..15]]]></irp:irp>
    </irp:protocol>
    <irp:protocol name="Xiaomi">
        <irp:irp><![CDATA[
       {36k,290,msb}<2,-2|2,-3|2,-4|2,-5>(1000u,-2,D:8,F:8,C:4,2,^30m)* {C=(D:4:4^D:4^F:4:4^F:4)} [D:0..255,F:0..255]
]]></irp:irp>
        <irp:documentation>
            Protocol found in the Xiaomi Mi Box Streaming Android TV Device.
            Defined and described in <a href="http://www.hifi-remote.com/forums/viewtopic.php?t=100421">this thread</a>.
        </irp:documentation>
        <!-- another thread: http://www.remotecentral.com/cgi-bin/mboard/rc-harmony/thread.cgi?8164 -->
    </irp:protocol>
    <irp:protocol c-name="XMP" name="XMP">
        <irp:parameter name="prefer-over">XMPMeta</irp:parameter>
        <irp:parameter name="relative-tolerance">0.04</irp:parameter>
        <irp:parameter name="absolute-tolerance">100</irp:parameter>
        <irp:parameter name="uei-executor">016C</irp:parameter>
        <irp:irp><![CDATA[{38k,136,msb}<210u,-760u|210u,-896u|210u,-1032u|210u,-1168u|210u,-1304u|210u,-1449u|210u,-1576u|210u,-1712u|210u,-1848u|210u,-1984u|210u,-2120u|210u,-2256u|210u,-2392u|210u,-2528u|210u,-2664u|210u,-2800u>([T=0][T=8],S:4:4,C1:4,S:4,15:4,OEM:8,D:8,210u,-13.8m,S:4:4,C2:4,T:4,S:4,F:16,210u,-80.4m){ C1=-(S+S::4+15+OEM+OEM::4+D+D::4), C2=-(S+S::4+T+F+F::4+F::8+F::12) }[F:0..65535,D:0..255,S:0..255,OEM:0..255=68]]]></irp:irp>
        <irp:documentation>The Device code is D, the SubDevice code is S and there are two OBC values.  OBC1 is the high byte of F, OBC2 is the low byte of F. The OEM code is normally 0x44 and is reported in the Misc field only if it has a different value. The XMP-1 protocol is XMP with OBC2 = 0.  The OBC field in DecodeIR then shows OBC1. The XMP-2 protocol is XMP with OBC1 = 0.  The OBC field in DecodeIR then shows OBC2.

This protocol has a 4-bit toggle T that is 0 for the first frame and normally 8 for all repeat frames.  There is, however, a variant in which a further frame with T=9 is sent after the button is released, separated from the preceding frame by the short leadout of 13.8m that is used between two half-frames rather than the long lead-out of 80.4m used at the end of all other frames.  When this frame is detected then the Misc field displays "With Final Frame".  For this to be shown in a learned signal, the button must be released before the learning process times out, so a short button press is needed.

These are problem decodes because JP1 remotes don"t typically learn these signals accurately enough for a correct decode.  NG Prontos also do a rotten job of learning these signals.  Older Prontos seem to do fairly well.  DecodeIR v2.40 includes algorithms that attempt to reconstruct a valid XMP signal from a corrupt learn, but it is impossible to correct all learning errors and there can be no certainty that a reconstruction is actually correct.

In a correctly learned or fully reconstructed signal there will be an "XMP", "XMP-1" or "XMP-2" decode with device, subdevice and OBC values that can be used with RemoteMaster or any similar program to regenerate a clean signal.  The Misc field shows which algorithms, if any, have been applied, as a list in brackets after any decode data in this field.  There are notes below on the reliability of the various algorithms.  When the protocol shows as (unqualified) XMP, both OBC values are non-zero.  The OBC and Hex fields show OBC1.  The corresponding values for OBC2 are shown in the Misc field.

The learned signal itself will certainly not be valid if any reconstruction algorithms have been applied and it may not be so even if it has been decoded without reconstruction.  The possible algorithm indicators in the Misc field are as follows:

<ul> <li>End (= Endpoint):  The lead-out burst is missing and has been inserted.  This is almost certainly correct.</li> <li>Rec (= Recovery):  Look-ahead has been used to recover a missing burst from the following repeat frame.  This is very likely to be correct.</li> <li>Cor (= Correction): Two bursts have been coalesced in the learning process, e.g. those for hex digits C and D, causing a C to appear as D or vice versa. The error has been identified and corrected.  This is probably correct.</li> <li>Cal (= Calculated): A missing digit has been calculated from a checksum.  The digit is probably correct but it may be in the wrong place.  The most likely error in the reconstruction is that the two digits of the OBC are the wrong way round.</li> <li>Cal2 (= Calculated 2)  Two consecutive missing zero digits have been identified, corresponding to a zero OBC.  When this happens, the signal will always be shown as XMP-1.  The most likely error in the reconstruction is that it should actually be XMP-2.</li> </ul>

If a learned signal is good enough to be recognised as XMP but not good enough to be fully reconstructed, the protocol will display with a name of the form XMP:136.218-0F0F441A0A800F00

In IR.exe you'll need to widen the Protocol column to see the whole thing. This represents intermediate data from an unsuccessful attempt to decode a XMP signal.

The number in the position where the 136 is in this example represents the time scale.  A number (like this example) that is near 137 is reasonable.  A number much further from 137 indicates a more serious learning or decoding problem.  The number in the position where the .218 is in this example (it is not part of the 136) represents the level of inconsistency in the individual hex digit decodes.  A value greater than .100 means the hex digits aren't very reliable.

The hex string, where the 0F0F441A0A800F00 is, is the decoded data. At least one digit is almost certainly wrong or the whole decode wouldn't be displayed in this form.  With a JP1 learning remote, the most common errors are that a digit is actually missing, in which case the string will have fewer than 16 hex digits, or that two or more digits which are decoded the same are actually different, so some of them are correct and some are one value higher or lower.  Although the reconstruction algorithms attempt to correct these types of errors, it is not always possible.  In this example I happen to know the correct signal.  One of the three F's is really an E and one of the two A's is really a 9.  The correct string is 0E0F441A09800F00.

Almost all examples we've seen start with "0E0F441A0" or "060F44120". But we've also seen upgrades from UEI for "0D1F441A0" and "0C2F441A0" and "0B3F441A0".  The last 4 digits of the whole 16 digit string (if they are correct) represent the Hex command needed to reproduce the signal in a JP1 upgrade or KeyMove.  DecodeIR shows them as two 8-bit OBC values, as described with the IRP notation above.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="XMP1" name="XMP-1">
        <irp:parameter name="prefer-over">XMP</irp:parameter>
        <irp:parameter name="relative-tolerance">0.04</irp:parameter>
        <irp:parameter name="absolute-tolerance">100</irp:parameter>
        <irp:irp><![CDATA[{38k,136,msb}<210u,-760u|210u,-896u|210u,-1032u|210u,-1168u|210u,-1304u|210u,-1449u|210u,-1576u|210u,-1712u|210u,-1848u|210u,-1984u|210u,-2120u|210u,-2256u|210u,-2392u|210u,-2528u|210u,-2664u|210u,-2800u>([T=0][T=8],S:4:4,C1:4,S:4,15:4,OEM:8,D:8,210u,-13.8m,S:4:4,C2:4,T:4,S:4,(F*256):16,210u,-80.4m){ C1=-(S+S::4+15+OEM+OEM::4+D+D::4),C2=-(S + S::4 + T + 256*F + 16*F + F + F::4) }[D:0..255, S:0..255, F:0..255, OEM:0..255=68]]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol c-name="XMP2" name="XMP-2">
        <irp:parameter name="prefer-over">XMP</irp:parameter>
        <irp:parameter name="prefer-over">XMPMeta</irp:parameter>
        <irp:parameter name="relative-tolerance">0.04</irp:parameter>
        <irp:parameter name="absolute-tolerance">100</irp:parameter>
        <irp:irp><![CDATA[{38k,136,msb}<210u,-760u|210u,-896u|210u,-1032u|210u,-1168u|210u,-1304u|210u,-1449u|210u,-1576u|210u,-1712u|210u,-1848u|210u,-1984u|210u,-2120u|210u,-2256u|210u,-2392u|210u,-2528u|210u,-2664u|210u,-2800u>([T=0][T=8],S:4:4,C1:4,S:4,15:4,OEM:8,D:8,210u,-13.8m,S:4:4,C2:4,T:4,S:4,F:16,210u,-80.4m){ C1=-(S+S::4+15+OEM+OEM::4+D+D::4),C2=-(S+S::4+T+F+F::4+F::8+F::12) }[D:0..255, S:0..255, F:0..255, OEM:0..255=68]]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol c-name="XMPFinalFrameMeta" name="XMPFinalFrameMeta" usable="false">
        <irp:parameter name="relative-tolerance">0.04</irp:parameter>
        <irp:parameter name="absolute-tolerance">100</irp:parameter>
        <irp:irp><![CDATA[{38k,136,msb}<210u,-760u>(<0:1|0:1,-1|0:1,-2|0:1,-3|0:1,-4|0:1,-5|0:1,-6|0:1,-7|0:1,-8|0:1,-9|0:1,-10|0:1,-11|0:1,-12|0:1,-13|0:1,-14|0:1,-15>(T=0,((S:4:4,C1:4,S:4,15:4,OEM:8,D:8,210u,-13.8m,S:4:4,C2:4,T:4,S:4,FF:16,210u,[-80.4m][-80.4m][-13.8m],T=8)+,T=9))){ C1=-(S+S::4+15+OEM+OEM::4+D+D::4),C2=-(S+S::4+T+FF+FF::4+FF::8+FF::12)}[FF:0..65535,D:0..255,S:0..255,OEM:0..255=68]]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol c-name="XMPff" name="XMPff">
        <irp:parameter name="relative-tolerance">0.04</irp:parameter>
        <irp:parameter name="absolute-tolerance">100</irp:parameter>
        <irp:parameter name="uei-executor">016C</irp:parameter>
        <irp:irp><![CDATA[{38k,136,msb}<210u,-760u|210u,-896u|210u,-1032u|210u,-1168u|210u,-1304u|210u,-1449u|210u,-1576u|210u,-1712u|210u,-1848u|210u,-1984u|210u,-2120u|210u,-2256u|210u,-2392u|210u,-2528u|210u,-2664u|210u,-2800u>([T=0][T=8][T=9],S:4:4,C1:4,S:4,15:4,OEM:8,D:8,210u,-13.8m,S:4:4,C2:4,T:4,S:4,F:16,210u,[-80.4m][-80.4m][-13.8m]){ C1=-(S+S::4+15+OEM+OEM::4+D+D::4),C2=-(S+S::4+T+F+F::4+F::8+F::12) }[F:0..65535,D:0..255,S:0..255,OEM:0..255=68]]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol c-name="XMPff1" name="XMPff-1">
        <irp:parameter name="prefer-over">XMPff</irp:parameter>
        <irp:parameter name="relative-tolerance">0.04</irp:parameter>
        <irp:parameter name="absolute-tolerance">100</irp:parameter>
        <irp:irp><![CDATA[{38k,136,msb}<210u,-760u|210u,-896u|210u,-1032u|210u,-1168u|210u,-1304u|210u,-1449u|210u,-1576u|210u,-1712u|210u,-1848u|210u,-1984u|210u,-2120u|210u,-2256u|210u,-2392u|210u,-2528u|210u,-2664u|210u,-2800u>([T=0][T=8][T=9],S:4:4,C1:4,S:4,15:4,OEM:8,D:8,210u,-13.8m,S:4:4,C2:4,T:4,S:4,(F*256):16,210u,[-80.4m][-80.4m][-13.8m]){ C1=-(S+S::4+15+OEM+OEM::4+D+D::4),C2=-(S + S::4 + T + 256*F + 16*F + F + F::4) }[D:0..255, S:0..255, F:0..255, OEM:0..255=68]]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol c-name="XMPff2" name="XMPff-2">
        <irp:parameter name="prefer-over">XMPff</irp:parameter>
        <irp:parameter name="relative-tolerance">0.04</irp:parameter>
        <irp:parameter name="absolute-tolerance">100</irp:parameter>
        <irp:irp><![CDATA[{38k,136,msb}<210u,-760u|210u,-896u|210u,-1032u|210u,-1168u|210u,-1304u|210u,-1449u|210u,-1576u|210u,-1712u|210u,-1848u|210u,-1984u|210u,-2120u|210u,-2256u|210u,-2392u|210u,-2528u|210u,-2664u|210u,-2800u>([T=0][T=8][T=9],S:4:4,C1:4,S:4,15:4,OEM:8,D:8,210u,-13.8m,S:4:4,C2:4,T:4,S:4,F:16,210u,[-80.4m][-80.4m][-13.8m]){ C1=-(S+S::4+15+OEM+OEM::4+D+D::4),C2=-(S+S::4+T+F+F::4+F::8+F::12) }[D:0..255, S:0..255, F:0..255, OEM:0..255=68]]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol c-name="XMPMeta" name="XMPMeta">
        <irp:parameter name="relative-tolerance">0.04</irp:parameter>
        <irp:parameter name="absolute-tolerance">100</irp:parameter>
        <irp:irp><![CDATA[{38k,136,msb}<210u,-760u|210u,-896u|210u,-1032u|210u,-1168u|210u,-1304u|210u,-1449u|210u,-1576u|210u,-1712u|210u,-1848u|210u,-1984u|210u,-2120u|210u,-2256u|210u,-2392u|210u,-2528u|210u,-2664u|210u,-2800u>([T=0][T=8],S:4:4,C1:4,S:4,15:4,OEM:8,D:8,210u,-13.8m,S:4:4,C2:4,T:4,S:4,FF:16,210u,-80.4m){ C1=-(S+S::4+15+OEM+OEM::4+D+D::4),C2=-(S+S::4+T+FF+FF::4+FF::8+FF::12)}[FF:0..65535,D:0..255,S:0..255,OEM:0..255=68]]]></irp:irp>
        <irp:documentation/>
    </irp:protocol>
    <irp:protocol c-name="Zaptor36" name="Zaptor-36">
        <irp:irp><![CDATA[{36k,330,msb}<-1,1|1,-1>([][T=0][T=1],8,-6,2,D:8,T:1,S:7,F:8,E:4,C:4,-74m){C = (D:4+D:4:4+S:4+S:3:4+8*T+F:4+F:4:4+E)&15}[D:0..255,S:0..127,F:0..127,E:0..15]]]></irp:irp>
        <irp:documentation>where T=0 for all frames except the last, T=1 for last frame, E is a checksum seed. A protocol so far seen only in the Motorola Zaptor.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Zaptor56" name="Zaptor-56">
        <irp:irp><![CDATA[{56k,330,msb}<-1,1|1,-1>([][T=0][T=1],8,-6,2,D:8,T:1,S:7,F:8,E:4,C:4,-74m){C = (D:4+D:4:4+S:4+S:3:4+8*T+F:4+F:4:4+E)&15}[D:0..255,S:0..127,F:0..127,E:0..15]]]></irp:irp>
        <irp:documentation>where T=0 for all frames except the last, T=1 for last frame, E is a checksum seed. A protocol so far seen only in the Motorola Zaptor.</irp:documentation>
    </irp:protocol>
    <irp:protocol c-name="Zenith" name="Zenith">
        <irp:parameter name="uei-executor">0022</irp:parameter>
        <irp:parameter name="decodable">false</irp:parameter>
        <irp:irp><![CDATA[{40k,520,msb}<1,-10|1,-1,1,-8>(S:1,<1:2|2:2>(F:D),-90m)*[S:0..1,F:0..255,D:5..8]]]></irp:irp>
        <irp:documentation>An unusual protocol, in that the number of bits in the function code is variable.  It is represented in DecodeIR as the device code.  There are also two lead-in styles, decoded as subdevice values 0 and 1. Style 1 aka "double-start" is usually used in TV's, other appliances use 0 aka "single start".  If the device code is &gt;8 then the bytes given in the Misc field as E = ... follow the OBC in the function code value.</irp:documentation>
    </irp:protocol>
    <irp:protocol name="Zenith5">
        <irp:irp><![CDATA[Zenith{D=5}[S:0..1,F:0..255]]]></irp:irp>
        <irp:documentation>Special case of the Zenith protocol, with D = 5.</irp:documentation>
    </irp:protocol>
    <irp:protocol name="Zenith6">
        <irp:irp><![CDATA[Zenith{D=6}[S:0..1,F:0..255]]]></irp:irp>
        <irp:documentation>Special case of the Zenith protocol, with D = 6.</irp:documentation>
    </irp:protocol>
    <irp:protocol name="Zenith7">
        <irp:irp><![CDATA[Zenith{D=7}[S:0..1,F:0..255]]]></irp:irp>
        <irp:documentation>Special case of the Zenith protocol, with D = 7.</irp:documentation>
    </irp:protocol>
    <irp:protocol name="Zenith8">
        <irp:irp><![CDATA[Zenith{D=8}[S:0..1,F:0..255]]]></irp:irp>
        <irp:documentation>Special case of the Zenith protocol, with D = 8.</irp:documentation>
    </irp:protocol>
</irp:protocols>
