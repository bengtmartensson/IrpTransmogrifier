group c;

beginComment() ::= "// "
endComment() ::= ""

FileBegin() ::= <<
<LineComment("This file was generated from IrpTransmogrifier")>
typedef unsigned int microseconds_t;

extern void  on(microseconds_t duration);
extern void off(microseconds_t duration);

#define INLINE static inline
>>

//FileEnd() ::= <<
//<LineComment("End of file")>
//>>
FileEnd() ::= ""

LineComment(text) ::= <<
<beginComment()><text><endComment()>
>>

RestOfLineComment(text) ::= "<beginComment()><text><endComment()>"

Irp(irp) ::= <<
<beginComment()>IRP: <irp><endComment()>
>>

//Documentation(documentation) ::= <<
//<beginComment()><documentation><endComment()>
//>>
Documentation(documentation) ::= ""

ProtocolNameComment(name) ::= <<
<beginComment()>ProtocolName: <name><endComment()>
>>

implementationTypes ::= [
    "intType": "unsigned int",
    "booleanType": "bool",
    "parameterType": "unsigned int"
]

DefineFlashGapExtent(hasExtent) ::= <<
static void INLINE flash(microseconds_t duration) {
<if(hasExtent)>
    sumOfDurations += duration;
<endif>
    on(duration);
}

static void INLINE gap(microseconds_t duration) {
<if(hasExtent)>
    sumOfDurations += duration;
<endif>
    off(duration);
}

<if(hasExtent)>
static void INLINE extent(microseconds_t duration) {
    off(duration - sumOfDurations);
}
<endif>
>>

InitValue(v) ::= "<if(v)> = <v><endif>"

InstanceVariableDefinition(type, name, initialValue) ::= <<
static <ImplementationType(type)> <name><InitValue(initialValue)>;
>>

ImplementationType(type) ::= <<
<implementationTypes.(type)>
>>

CodeFileExtension() ::= ".c"

StatementSeparator() ::= ";"

templateNames ::= [
    "class org.harctoolbox.irp.Flash": "FlashTemplate",
    "class org.harctoolbox.irp.Gap": "GapTemplate",
    "class org.harctoolbox.irp.Extent": "ExtentTemplate",
    "class org.harctoolbox.irp.FiniteBitField": "FiniteBitFieldTemplate",
    "class org.harctoolbox.irp.IrStream": "IrStreamTemplate"

]

FlashTemplate(x, unit) ::= "FLaSh <x> <x.unit> <unit>"
GapTemplate() ::= "GAP"
ExtentTemplate(x, unit) ::= "Xtent <x> <x.unit> <unit>"
FiniteBitFieldTemplate() ::= "BitField"
IrStreamTemplate() ::= "IrStream"

TemplateName(class) ::= <<
<templateNames.(class)>
>>

bracket(x,unit) ::= <<
<x.class> <unit>
<(TemplateName(x.class))(x, unit)>
[<x>] 
>>

BitspecIrstream(arg1, arg2) ::= <<
<arg1>

<arg2>
>>

BitSpec(arg1, arg2) ::= <<
<arg1>

<arg2>
>>

BitSpecCase(number,code) ::= <<
case <number>: {
<code>;
}
break;
>>

BareIrStream(body) ::= <<
<body; separator=";\n">
>>

BitSpecMsb(chunkSize,bitmask,body) ::= <<
for (<ImplementationType("intType")> i = 0; i \< width; i += <chunkSize>) {
    switch((data \>> (width - i - <chunkSize>)) & <bitmask>) {
        <body; separator="\n">
    }
}
>>

BitSpecLsb(chunkSize, bitmask, body) ::= <<
for (<ImplementationType("intType")> i = 0; i \< width; i += <chunkSize>) {
    switch((data \>> i) & <bitmask>) {
        <body; separator="\n">
    }
}
>>

NormalBitSpec(body) ::= <<
static void bitField(<ImplementationType("parameterType")> data, <ImplementationType("parameterType")> width) {
<body>
}
>>

ReverseBitSpec(body) ::= <<
static void bitFieldReverse(<ImplementationType("parameterType")> data, <ImplementationType("parameterType")> width) {
<body>
}
>>

ParameterSpecs(arg) ::= <<
<arg; separator=", ">
>>

ParameterSpec(name, min, max, deflt, memory) ::= <<
<ImplementationType("parameterType")> <name>
>>

XFunction(name,parameterList, protocolName, functionBody) ::= <<
void <name><protocolName>(<parameterList>) {
<functionBody>;
}
>>

ResetDurationCounter() ::= <<
sumOfDurations = 0
>>

Repeat(repeats, body) ::= <<
for (<ImplementationType("intType")> repeatCounter = 0; repeatCounter \< <repeats>; repeatCounter++) {
    <body>
}
>>

FunctionBody(reset, body) ::= <<
<if(reset)><ResetDurationCounter()>;<endif>
<body>
>>

SetOfStatements(body) ::= <<
<body; separator=";\n">
>>

Chop(chop) ::= "<if(chop)> >> (<chop>)<endif>"

FiniteBitField(data, width, chop, complement, reverse) ::= <<
<if(reverse)>bitFieldReverse<else>bitField<endif>(<if(complement)>~<endif>((<data>)<Chop(chop)>), <width>)
>>

InfiniteBitFieldExpression(data, chop, complement) ::= <<
<if(complement)>~<endif>((<data>) \>> (<chop>))
>>

FiniteBitFieldExpression(data, width, chop, complement, reverse) ::= <<
<if(reverse)>finiteBitFieldExpressionReverse(TODO)<else><if(complement)>~<endif>(((<data>) \>> (<chop>)) & ((1 \<\< <width>)-1))<endif>
>>

Flash(arg)          ::= "flash(<arg>)"
Gap(arg)            ::= "gap(<arg>)"
Extent(arg)         ::= "extent(<arg>)"

Name(name, eval)    ::= "<name>"

Add(arg1,arg2)      ::= "(<arg1>)+(<arg2>)"
Subtract(arg1,arg2) ::= "(<arg1>)-(<arg2>)"
Multiply(arg1,arg2) ::= "(<arg1>)*(<arg2>)"
Divide(arg1,arg2)   ::= "(<arg1>)/(<arg2>)"

add(arg1,arg2)      ::= "<arg1>+<arg2>"
sub(arg1,arg2)      ::= "<arg1>-<arg2>"
mul(arg1,arg2)      ::= "<arg1>*<arg2>"
div(arg1,arg2)      ::= "<arg1>/<arg2>"

BitwiseExclusiveOr(arg1,arg2) ::= "(<arg1>)^(<arg2>)"