group c;

beginComment() ::= "// "
endComment() ::= ""

FileBegin() ::= <<
<LineComment("This file was generated from IrpTransmogrifier")>
package org.harctoolbox.render;

import java.util.Map;
import org.harctoolbox.ircore.IrSignal;

>>

//FileEnd() ::= <<
//<LineComment("End of file")>
//>>
FileEnd() ::= ""

LineComment(text) ::= <<
<beginComment()><text><endComment()>
>>

RestOfLineComment(text) ::= "<beginComment()><text><endComment()>"

NamedProtocol(name, irp, documentation, frequency, dutycycle, parameters, instanceVariableDefinition, defineFlashGapExtent, bitSpec, introCode, repeatCode, endingCode) ::= <<
public final class <name>Renderer extends IrpRenderer {
    <Irp(irp)>
    <Documentation(documentation)>
    <DeclareParameters(parameters)>
    <DeclareFrequency(frequency)>
    <DeclareDutycycle(dutycycle)>
    <DeclareParameterlessConstructor(name)>
    <DeclareCompute(name, parameters)>

    <!instanceVariableDefinition!>
    <!defineFlashGapExtent!>

    <introCode>
    <repeatCode>
    <endingCode>
    <DefineClassList(bitSpec)>
}
>>

Irp(irp) ::= <<
public final static String irpString = "<irp>";
>>

//Documentation(documentation) ::= <<
//<beginComment()><documentation><endComment()>
//>>
Documentation(documentation) ::= <<
public final static String documentation = "<documentation>";
>>

ProtocolNameComment(name) ::= <<
<beginComment()>ProtocolName: <name><endComment()>
>>

implementationTypes ::= [
    "intType": "int",
    "booleanType": "boolean",
    "parameterType": "long"
]

DeclareParameterlessConstructor(name) ::= <<
public <name>Renderer() {
}
>>

DeclareParameters(parameters) ::= <<
<parameters:DeclareParameter()>
>>

DeclareParameter(parameter) ::= <<
private <ImplementationType("parameterType")> <parameter>;

>>

DeclareCompute(name, parameters) ::= <<
public IrSignal compute(<parameters:DeclareFormalParameter(); separator=", ">) {
    <parameters:LocalAssignment(); separator="\n">
    setup();
    return getIrSignal();
}

@Override
public IrSignal compute(Map\<String,Long> map) {
    <parameters:MapLocalAssignment(); separator="\n">
    setup();
    return getIrSignal();
}

public static IrSignal newIrSignal(<parameters:DeclareFormalParameter(); separator=", ">) {
    <name>Renderer instance = new <name>Renderer();
    return instance.compute(<parameters; separator=", ">);
}
>>

LocalAssignment(par) ::= <<
this.<par> = <par>;
>>

MapLocalAssignment(par) ::= <<
<par> = map.get("<par>");
>>

DeclareFormalParameter(parameter) ::= <<
<ImplementationType("parameterType")> <parameter>
>>

DeclareFrequency(frequency) ::= <<
@Override
public double getFrequency() {
    return <frequency>;
}
>>

DeclareDutycycle(dutycycle) ::= <<
@Override
public double getDutycycle() {
    return <dutycycle>;
}
>>

DefineFlashGapExtent(hasExtent) ::= <<
static void INLINE flash(microseconds_t duration) {
<if(hasExtent)>
    sumOfDurations += duration;
<endif>
    on(duration);
}

static void INLINE gap(microseconds_t duration) {
<if(hasExtent)>
    sumOfDurations += duration;
<endif>
    off(duration);
}

<if(hasExtent)>
static void INLINE extent(microseconds_t duration) {
    off(duration - sumOfDurations);
}
<endif>
>>

Assignment(name, expression) ::= <<
<name> = <expression>
>>

DefineClassList(bitSpec) ::= <<
private static class LocalIrList extends IrpRenderer.IrList {
    <bitSpec>
}
>>

InitValue(v) ::= "<if(v)> = <v><endif>"

InstanceVariableDefinition(type, name, initialValue) ::= <<
static <ImplementationType(type)> <name><InitValue(initialValue)>;
>>

ImplementationType(type) ::= <<
<implementationTypes.(type)>
>>

CodeFileExtension() ::= ".c"

StatementSeparator() ::= ";"

FlashTemplate(x, unit) ::= "FLaSh <x> <x.unit> <unit>"
GapTemplate() ::= "GAP"
ExtentTemplate(x, unit) ::= "Xtent <x> <x.unit> <unit>"
FiniteBitFieldTemplate() ::= "BitField"
IrStreamTemplate() ::= "IrStream"

TemplateName(class) ::= <<
<templateNames.(class)>
>>

bracket(x,unit) ::= <<
<x.class> <unit>
<(TemplateName(x.class))(x, unit)>
[<x>] 
>>

BitspecIrstream(arg1, arg2) ::= <<
<arg1>

<arg2>
>>

BitSpec(arg1, arg2) ::= <<
<arg1>

<arg2>
>>

BitSpecCase(number,code) ::= <<
case <number>: {
    <code>;
}
break;
>>

BareIrStream(body) ::= <<
<body; separator=";\n">
>>

BitSpecMsb(chunkSize,bitmask,body) ::= <<
for (<ImplementationType("intType")> i = 0; i \< width; i += <chunkSize>) {
    switch(((<ImplementationType("intType")>)data \>> (width - i - <chunkSize>)) & <bitmask>) {
        <body; separator="\n">
    }
}
>>

BitSpecLsb(chunkSize, bitmask, body) ::= <<
for (<ImplementationType("intType")> i = 0; i \< width; i += <chunkSize>) {
    switch(((<ImplementationType("intType")>)data \>> i) & <bitmask>) {
        <body; separator="\n">
    }
}
>>

NormalBitSpec(body) ::= <<
@Override
void bitField(<ImplementationType("parameterType")> data, <ImplementationType("parameterType")> width) {
    LocalIrList list = this;
    <body>
}
>>

//ReverseBitSpec(body) ::= <<
//void bitFieldReverse(<ImplementationType("parameterType")> data, <ImplementationType("parameterType")> width) {
//    LocalIrList list = this;
//    <body>
//}
//>>
ReverseBitSpec(body) ::= ""

ParameterSpecs(arg) ::= <<
<arg; separator=", ">
>>

ParameterSpec(name, min, max, deflt, memory) ::= <<
<ImplementationType("parameterType")> <name>
>>

XFunction(name,parameterList, protocolName, functionBody) ::= <<
@Override
protected LocalIrList setup<name>() {
    LocalIrList list = new LocalIrList();
    <functionBody>;
    return list;
}
>>

//ResetDurationCounter() ::= <<
//sumOfDurations = 0
//>>
ResetDurationCounter() ::= ""

Repeat(repeats, body) ::= <<
for (<ImplementationType("intType")> repeatCounter = 0; repeatCounter \< <repeats>; repeatCounter++) {
    <body>
}
>>

FunctionBody(reset, body) ::= <<
<if(reset)><ResetDurationCounter()><endif>
<body>
>>

SetOfStatements(body) ::= <<
<body; separator=";\n">
>>

Chop(chop) ::= "<if(chop)> >> (<chop>)<endif>"

FiniteBitField(data, width, chop, complement, reverse) ::= <<
list.<if(reverse)>bitFieldReverse<else>bitField<endif>(<if(complement)>~<endif>((<data>)<Chop(chop)>), <width>)
>>

InfiniteBitFieldExpression(data, chop, complement) ::= <<
<if(complement)>~<endif>((<data>) \>> (<chop>))
>>

FiniteBitFieldExpression(data, width, chop, complement, reverse) ::= <<
<if(reverse)>finiteBitFieldExpressionReverse(TODO)<else><if(complement)>~<endif>(((<data>) \>> (<chop>)) & ((1 \<\< <width>)-1))<endif>
>>

Flash(arg)          ::= "list.flash(<arg>)"
Gap(arg)            ::= "list.gap(<arg>)"
Extent(arg)         ::= "list.extent(<arg>)"

Name(name, eval)    ::= "<name>"

Add(arg1,arg2)      ::= "(<arg1>)+(<arg2>)"
Subtract(arg1,arg2) ::= "(<arg1>)-(<arg2>)"
Multiply(arg1,arg2) ::= "(<arg1>)*(<arg2>)"
Divide(arg1,arg2)   ::= "(<arg1>)/(<arg2>)"

add(arg1,arg2)      ::= "<arg1>+<arg2>"
sub(arg1,arg2)      ::= "<arg1>-<arg2>"
mul(arg1,arg2)      ::= "<arg1>*<arg2>"
div(arg1,arg2)      ::= "<arg1>/<arg2>"

BitwiseExclusiveOr(arg1,arg2) ::= "(<arg1>)^(<arg2>)"