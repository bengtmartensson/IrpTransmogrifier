group c;

beginComment() ::= "// "
endComment() ::= ""

CodeFileExtension() ::= ".java"

FileSuffix() ::= "Renderer.java"

FileBegin() ::= <<
<LineComment("This file was generated by IrpTransmogrifier")>
package org.harctoolbox.render;

import java.util.Map;
import org.harctoolbox.ircore.IrCoreUtils;
import org.harctoolbox.ircore.IrSignal;

>>

//FileEnd() ::= <<
//<LineComment("End of file")>
//>>
FileEnd() ::= ""

LineComment(text) ::= <<
<beginComment()><text><endComment()>
>>

RestOfLineComment(text) ::= "<beginComment()><text><endComment()>"

NamedProtocol(protocolName, cProtocolName, irp, documentation, generalSpec, parameterSpecs, instanceVariableDefinition, assignmentVariables, definitions, defineFlashGapExtent, bitSpec, chunkSize, code, introCode, repeatCode, endingCode) ::= <<
public final class <cProtocolName>Renderer extends IrpRenderer {
    <Irp(irp)>
    <Documentation(documentation)>
    
    <DeclareStatic(cProtocolName, parameterSpecs)>
    
    <DeclareParameters(parameterSpecs)>
    
    <DeclareAssignmentVariables(assignmentVariables)>
    
    <DeclareParameterlessConstructor(cProtocolName)>
    
    <DeclareFrequency(generalSpec.frequency)>
    
    <DeclareDutyCycle(generalSpec.dutyCycle)>
    
    <DeclareCompute(cProtocolName, parameterSpecs)>
    
    <DefineNames(definitions)>

    <!instanceVariableDefinition!>
    <!defineFlashGapExtent!>
    <!DefineCode(code)!>
    <introCode>
    
    <repeatCode>
    
    <endingCode>
    
    <DefineClassList(bitSpec,chunkSize)>
}
>>

Irp(irp) ::= <<
public final static String irpString = "<irp>";
>>

//Documentation(documentation) ::= <<
//<beginComment()><documentation><endComment()>
//>>
Documentation(documentation) ::= <<
public final static String documentation = "<documentation>";
>>

ProtocolNameComment(protocolName) ::= <<
<beginComment()>ProtocolName: <protocolName> (<cProtocolName>)<endComment()>
>>

implementationTypes ::= [
    "intType": "int",
    "booleanType": "boolean",
    "parameterType": "long"
]

DeclareParameterlessConstructor(cProtocolName) ::= <<
public <cProtocolName>Renderer() {
}
>>

DeclareParameters(parameters) ::= <<
// Parameters as declared in ParameterSpec
<parameters:{par | <DeclareParameter(par)>}>
>>

DeclareParameter(parameter) ::= <<
private <if(parameter.memory)>static <endif><ImplementationType("parameterType")> <parameter.name><if(parameter.memory)> = <parameter.default><endif>;

>>

DeclareSimpleParameter(parameterName) ::= <<
private <ImplementationType("parameterType")> <parameterName>;
>>

DeclareAssignmentVariables(assignmentVariables) ::= <<
// Internal variables, not declared in ParameterSpec
<assignmentVariables:DeclareSimpleParameter()>
>>

DeclareCompute(cProtocolName, parameters) ::= <<
public IrSignal compute(<parameters:DeclareFormalParameter(); separator=", ">) {
    <parameters:LocalAssignment(); separator="\n">
    setup();
    return getIrSignal();
}

@Override
public IrSignal compute(Map\<String,Long> map) {
    <parameters:MapLocalAssignment(); separator="\n">
    setup();
    return getIrSignal();
}
>>

DeclareStatic(cProtocolName, parameters) ::= <<
// Static convenience functions
public static IrSignal newIrSignal(<parameters:DeclareFormalParameter(); separator=", ">) {
    <cProtocolName>Renderer instance = new <cProtocolName>Renderer();
    return instance.compute(<parameters:{p | <p.name>}; separator=", ">);
}

public static IrSignal newIrSignal(Map\<String, Long> map) {
    <cProtocolName>Renderer instance = new <cProtocolName>Renderer();
    return instance.compute(map);
}
>>

LocalAssignment(par) ::= <<
this.<par.name> = <par.name>;
>>

MapLocalAssignment(par) ::= <<
<par.name> = map.get("<par.name>");
>>

DeclareFormalParameter(parameter) ::= <<
<ImplementationType("parameterType")> <parameter.name>
>>

DefineNames(definitions) ::= <<
// Local functions; corresponds to Definitions in the IRP.
<definitions>
>>

NameEngine(definitions) ::= <<
<definitions; separator=";\n">
>>

NameDefinition(name, expression) ::= <<
private <ImplementationType("parameterType")> <name>() {
    return <expression>;
}
>>

DeclareFrequency(frequency) ::= <<
@Override
public double getFrequency() {
    return <frequency>;
}
>>

DeclareDutyCycle(dutyCycle) ::= <<
@Override
public double getDutyCycle() {
    return <dutyCycle>;
}
>>

DefineFlashGapExtent(hasExtent) ::= <<
static void INLINE flash(microseconds_t duration) {
<if(hasExtent)>
    sumOfDurations += duration;
<endif>
    on(duration);
}

static void INLINE gap(microseconds_t duration) {
<if(hasExtent)>
    sumOfDurations += duration;
<endif>
    off(duration);
}

<if(hasExtent)>
static void INLINE extent(microseconds_t duration) {
    off(duration - sumOfDurations);
}
<endif>
>>

Assignment(name, expression) ::= <<
<name> = <expression>
>>

DefineClassList(bitSpec,chunkSize) ::= <<
private static class LocalIrList extends IrpRenderer.IrList {
<if(chunkSize)>
    private long pendingData = 0L;
    private long pendingBits = 0L;
<endif>
    <bitSpec>
}
>>

InitValue(v) ::= "<if(v)> = <v><endif>"

InstanceVariableDefinition(type, name, initialValue) ::= <<
static <ImplementationType(type)> <name><InitValue(initialValue)>;
>>

ImplementationType(type) ::= <<
<implementationTypes.(type)>
>>

//StatementSeparator() ::= ";"

FlashTemplate(x, unit) ::= "FLaSh <x> <x.unit> <unit>"
GapTemplate() ::= "GAP"
ExtentTemplate(x, unit) ::= "Xtent <x> <x.unit> <unit>"
FiniteBitFieldTemplate() ::= "BitField"
IrStreamTemplate() ::= "IrStream"

TemplateName(class) ::= <<
<templateNames.(class)>
>>

bracket(x,unit) ::= <<
<x.class> <unit>
<(TemplateName(x.class))(x, unit)>
[<x>] 
>>

BitspecIrstream(arg1, arg2) ::= <<
<arg1>

<arg2>
>>

BitSpec(arg1, arg2) ::= <<
<arg1>

<arg2>
>>

BitSpecCase(number,code) ::= <<
case <number>: {
    <code>;
}
break;
>>

BareIrStream(body) ::= <<
<body; separator=";\n">
>>

BitSpecMsb(chunkSize,bitmask,body) ::= <<
for (<ImplementationType("intType")> i = 0; i \< width; i += <chunkSize>) {
    switch(((<ImplementationType("intType")>)data \>> (width - i - <chunkSize>)) & <bitmask>) {
        <body; separator="\n">
    }
}
>>

BitSpecLsb(chunkSize, bitmask, body) ::= <<
for (<ImplementationType("intType")> i = 0; i \< width; i += <chunkSize>) {
    switch(((<ImplementationType("intType")>)data \>> i) & <bitmask>) {
        <body; separator="\n">
    }
}
>>

NormalBitSpec(body, chunkSize) ::= <<
@Override
void bitField(<ImplementationType("parameterType")> data, <ImplementationType("parameterType")> width) {
    LocalIrList list = this;
    <if(chunkSize)>
    if (pendingBits > 0L) {
        // This code is valid for msb only
        data &= (1L \<\< width) - 1L;
        data |= pendingData \<\< width;
        width += pendingBits;
        pendingBits = 0L;
    }
    if (width % <chunkSize>L != 0L) {
        pendingData = data;
        pendingBits = width;
        width = 0L;
    }
    <endif>
    <body>
}
>>

//ReverseBitSpec(body) ::= <<
//void bitFieldReverse(<ImplementationType("parameterType")> data, <ImplementationType("parameterType")> width) {
//    LocalIrList list = this;
//    <body>
//}
//>>
ReverseBitSpec(body, chunkSize) ::= ""

ParameterSpecs(arg) ::= <<
<arg; separator=", ">
>>

ParameterSpec(name, min, max, deflt, memory) ::= <<
<ImplementationType("parameterType")> <name>
>>

Statement(stmt) ::= <<
<stmt>;
>>

XFunction(name,parameterList, protocolName, functionBody) ::= <<
@Override
protected LocalIrList setup<name>() {
    LocalIrList list = new LocalIrList();
    <functionBody>
    return list;
}
>>

//ResetDurationCounter() ::= <<
//sumOfDurations = 0
//>>
ResetDurationCounter() ::= ""

Repeat(repeats, body) ::= <<
for (<ImplementationType("intType")> repeatCounter = 0; repeatCounter \< <repeats>; repeatCounter++) {
    <SetOfStatements(body)>
}
>>

FunctionBody(reset, body) ::= <<
<if(reset)><ResetDurationCounter()><endif>
<body:{x|<x>;}; separator="\n">
>>

SetOfStatements(body) ::= <<
<body:{x|<x>;}; separator="\n">
>>

Chop(chop) ::= "<if(chop)> >> (<chop>)<endif>"

//list.<if(reverse)>bitFieldReverse<else>bitField<endif>(<if(complement)>~<endif>((<data>)<Chop(chop)>), <width>)

FiniteBitField(data, width, chop, complement, reverse) ::= <<
list.bitField(<if(complement)>~<endif><if(reverse)>IrCoreUtils.reverse<endif>(<data><if(reverse)>, (int)<width><endif>)<Chop(chop)>, <width>)
>>

InfiniteBitFieldExpression(data, chop, complement) ::= <<
<if(complement)>~<endif>((<data>) \>> (<chop>))
>>

FiniteBitFieldExpression(data, width, chop, complement, reverse) ::= <<
finiteBitField(<data>, <width>, <if(chop)><chop><else>0<endif>, <complement>, <reverse>)
>>

DefineCode(code) ::= <<
<DefineFunction("Intro",[code.intro])>

<DefineFunction("Repeat",code.repeat)>

<DefineFunction("Ending",code.ending)>
<code>

<code.intro.body>

>>

DefineFunction(name, codes) ::= <<
@Override
protected LocalIrList setup<name>() {
    LocalIrList list = new LocalIrList();
    <if(codes.reset)>RESET<endif>
    <codes><!functionBody:Statement()!>
    return list;
}
>>

Flash(arg)          ::= "list.flash(<arg>)"
Gap(arg)            ::= "list.gap(<arg>)"
Extent(arg)         ::= "list.extent(<arg>)"

Name(name, eval)    ::= "<name>"
NameAsDefinition(name, eval)    ::= "<name>()"

Add(arg1,arg2)      ::= "(<arg1>)+(<arg2>)"
Subtract(arg1,arg2) ::= "(<arg1>)-(<arg2>)"
Multiply(arg1,arg2) ::= "(<arg1>)*(<arg2>)"
Divide(arg1,arg2)   ::= "(<arg1>)/(<arg2>)"
Modulo(arg1,arg2)   ::= "(<arg1>)%(<arg2>)"
Exponentiate(arg1,arg2) ::= "IrpUtils.power(arg1,arg2)"

add(arg1,arg2)      ::= "<arg1>+<arg2>"
sub(arg1,arg2)      ::= "<arg1>-<arg2>"
mul(arg1,arg2)      ::= "<arg1>*<arg2>"
div(arg1,arg2)      ::= "<arg1>/<arg2>"

BitwiseExclusiveOr(arg1,arg2) ::= "(<arg1>)^(<arg2>)"
BitwiseAnd(arg1,arg2)         ::= "(<arg1>)&(<arg2>)"
BitwiseOr(arg1,arg2)          ::= "(<arg1>)|(<arg2>)"
BitCount(arg)                 ::= "Long.bitCount(<arg>)"
UnaryMinus(arg)               ::= "-(<arg>)"
