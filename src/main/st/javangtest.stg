group c;

beginComment() ::= "// "
endComment() ::= ""

CodeFileExtension() ::= ".java"

FileSuffix() ::= "RendererNGTest.java"

FileBegin() ::= <<
<LineComment("This file was generated by IrpTransmogrifier")>
package org.harctoolbox.render;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import org.harctoolbox.ircore.IncompatibleArgumentException;
import org.harctoolbox.ircore.IrSignal;
import org.harctoolbox.irp.*;
import static org.testng.Assert.assertTrue;
import static org.testng.Assert.fail;
import org.testng.annotations.Test;
import org.xml.sax.SAXException;

>>

//FileEnd() ::= <<
//<LineComment("End of file")>
//>>
FileEnd() ::= ""

LineComment(text) ::= <<
<beginComment()><text><endComment()>
>>

RestOfLineComment(text) ::= "<beginComment()><text><endComment()>"

NamedProtocol(protocolName, cProtocolName, irp, documentation, frequency, dutyCycle, parameterSpecs, instanceVariableDefinition, assignmentVariables, definitions, defineFlashGapExtent, bitSpec, introCode, repeatCode, endingCode) ::= <<
public class <cProtocolName>RendererNGTest {
    private final static String configFile = "../IrpTransmogrifier/src/main/config/IrpProtocols.xml";
    private final static int noRandomTests = 10;

    private final IrpDatabase irpDatabase;
    private final NamedProtocol prot;
    public <cProtocolName>RendererNGTest() throws IOException, SAXException, IncompatibleArgumentException, IrpSyntaxException, IrpSemanticException, ArithmeticException, InvalidRepeatException, UnknownProtocolException, UnassignedException {
        irpDatabase = new IrpDatabase(configFile);
        prot = irpDatabase.getNamedProtocol("<protocolName>");
    }

    <DeclareTestParameters(parameterSpecs)>
    
    public void testMap(Map\<String, Long> map) {
        try {
            NameEngine nameEngine = new NameEngine(map);
            //System.out.println(nameEngine);
            IrSignal expResult = prot.toIrSignal(nameEngine);
            IrSignal result = <cProtocolName>Renderer.newIrSignal(map);
            assertTrue(result.approximatelyEquals(expResult));
        } catch (IncompatibleArgumentException | IrpSemanticException | ArithmeticException | UnassignedException | IrpSyntaxException | DomainViolationException ex) {
            fail();
        }
    }

    <DeclareExhaustiveTest(parameterSpecs)>

    /**
     * Test of newIrSignal method, of class RC5Renderer.
     */
    @Test
    public void testNewIrSignal() throws IrpSyntaxException {
        System.out.println("newIrSignal@<cProtocolName>");
        for (int i = 0; i \< noRandomTests; i++)
            testMap(prot.randomParameters());
    }
}
>>

Irp(irp) ::= <<
public final static String irpString = "<irp>";
>>

//Documentation(documentation) ::= <<
//<beginComment()><documentation><endComment()>
//>>
Documentation(documentation) ::= <<
public final static String documentation = "<documentation>";
>>

ProtocolNameComment(protocolName,cProtocolName) ::= <<
<beginComment()>ProtocolName: <protocolName> (<cProtocolName>)<endComment()>
>>

implementationTypes ::= [
    "intType": "int",
    "booleanType": "boolean",
    "parameterType": "long"
]

DeclareParameterlessConstructor(cProtocolName) ::= <<
public <cProtocolName>Renderer() {
}
>>

DeclareExhaustiveTest(parameterSpecs) ::= <<
/**
 * Exhaustive test of newIrSignal method, of class RC5Renderer.
 */
//@Test
public void testNewIrSignalExhaustive() {
System.out.println("newIrSignalExhaustive");
<parameterSpecs:{par |    for (<ImplementationType("parameterType")> <par.name> = <par.min>; <par.name> \<= <par.max>; <par.name>++)}; separator="\n">
        testNewIrSignalParameters(<parameterSpecs:{p | <p.name>}; separator=", ">);
}
>>

DeclareTestParameters(parameterSpecs) ::= <<
private void testNewIrSignalParameters(<parameterSpecs:DeclareFormalParameter(); separator=", ">) {
    Map\<String, Long> map = new HashMap\<>(<length(parameterSpecs)>);
    <parameterSpecs:{par | map.put("<par.name>", <par.name>);}; separator="\n">
    testMap(map);
}
>>

DeclareParameters(parameterSpecs) ::= <<
<parameterSpecs:DeclareParameter()>
>>

DeclareParameter(parameter) ::= <<
private <ImplementationType("parameterType")> <parameter>;

>>

DeclareAssignmentVariables(assignmentVariables) ::= <<
<assignmentVariables:DeclareParameter()>
>>

DeclareCompute(cProtocolName, parameters) ::= <<
public IrSignal compute(<parameters:DeclareFormalParameter(); separator=", ">) {
    <parameterSpecs:LocalAssignment(); separator="\n">
    setup();
    return getIrSignal();
}

@Override
public IrSignal compute(Map\<String,Long> map) {
    <parameters:MapLocalAssignment(); separator="\n">
    setup();
    return getIrSignal();
}

public static IrSignal newIrSignal(<parameterSpecs:DeclareFormalParameter(); separator=", ">) {
    <cProtocolName>Renderer instance = new <cProtocolName>Renderer();
    return instance.compute(<parameterSpecs; separator=", ">);
}

public static IrSignal newIrSignal(Map\<String, Long> map) {
    <cProtocolName>Renderer instance = new <cProtocolName>Renderer();
    return instance.compute(map);
}
>>

LocalAssignment(par) ::= <<
this.<par> = <par>;
>>

MapLocalAssignment(par) ::= <<
<par> = map.get("<par>");
>>

DeclareFormalParameter(parameter) ::= <<
<ImplementationType("parameterType")> <parameter.name>
>>

DefineNames(definitions) ::= <<
<definitions>
>>

NameEngine(definitions) ::= <<
<definitions; separator=";\n">
>>

NameDefinition(name, expression) ::= <<
private <ImplementationType("parameterType")> <name>() {
    return <expression>;
}
>>

DeclareFrequency(frequency) ::= <<
@Override
public double getFrequency() {
    return <frequency>;
}
>>

DeclareDutyCycle(dutyCycle) ::= <<
@Override
public double getDutyCycle() {
    return <dutyCycle>;
}
>>

DefineFlashGapExtent(hasExtent) ::= <<
static void INLINE flash(microseconds_t duration) {
<if(hasExtent)>
    sumOfDurations += duration;
<endif>
    on(duration);
}

static void INLINE gap(microseconds_t duration) {
<if(hasExtent)>
    sumOfDurations += duration;
<endif>
    off(duration);
}

<if(hasExtent)>
static void INLINE extent(microseconds_t duration) {
    off(duration - sumOfDurations);
}
<endif>
>>

Assignment(name, expression) ::= <<
<name> = <expression>
>>

DefineClassList(bitSpec) ::= <<
private static class LocalIrList extends IrpRenderer.IrList {
    <bitSpec>
}
>>

InitValue(v) ::= "<if(v)> = <v><endif>"

InstanceVariableDefinition(type, name, initialValue) ::= <<
static <ImplementationType(type)> <name><InitValue(initialValue)>;
>>

ImplementationType(type) ::= <<
<implementationTypes.(type)>
>>

StatementSeparator() ::= ";"

FlashTemplate(x, unit) ::= "FLaSh <x> <x.unit> <unit>"
GapTemplate() ::= "GAP"
ExtentTemplate(x, unit) ::= "Xtent <x> <x.unit> <unit>"
FiniteBitFieldTemplate() ::= "BitField"
IrStreamTemplate() ::= "IrStream"

TemplateName(class) ::= <<
<templateNames.(class)>
>>

bracket(x,unit) ::= <<
<x.class> <unit>
<(TemplateName(x.class))(x, unit)>
[<x>] 
>>

BitspecIrstream(arg1, arg2) ::= <<
<arg1>

<arg2>
>>

BitSpec(arg1, arg2) ::= <<
<arg1>

<arg2>
>>

BitSpecCase(number,code) ::= <<
case <number>: {
    <code>;
}
break;
>>

BareIrStream(body) ::= <<
<body; separator=";\n">
>>

BitSpecMsb(chunkSize,bitmask,body) ::= <<
for (<ImplementationType("intType")> i = 0; i \< width; i += <chunkSize>) {
    switch(((<ImplementationType("intType")>)data \>> (width - i - <chunkSize>)) & <bitmask>) {
        <body; separator="\n">
    }
}
>>

BitSpecLsb(chunkSize, bitmask, body) ::= <<
for (<ImplementationType("intType")> i = 0; i \< width; i += <chunkSize>) {
    switch(((<ImplementationType("intType")>)data \>> i) & <bitmask>) {
        <body; separator="\n">
    }
}
>>

NormalBitSpec(body) ::= <<
@Override
void bitField(<ImplementationType("parameterType")> data, <ImplementationType("parameterType")> width) {
    LocalIrList list = this;
    <body>
}
>>

//ReverseBitSpec(body) ::= <<
//void bitFieldReverse(<ImplementationType("parameterType")> data, <ImplementationType("parameterType")> width) {
//    LocalIrList list = this;
//    <body>
//}
//>>
ReverseBitSpec(body) ::= ""

ParameterSpecs(arg) ::= <<
<arg; separator=", ">
>>

ParameterSpec(name, min, max, deflt, memory) ::= <<
<ImplementationType("parameterType")> <name>
>>

XFunction(name,parameterList, protocolName, functionBody) ::= <<
@Override
protected LocalIrList setup<name>() {
    LocalIrList list = new LocalIrList();
    <functionBody>;
    return list;
}
>>

//ResetDurationCounter() ::= <<
//sumOfDurations = 0
//>>
ResetDurationCounter() ::= ""

Repeat(repeats, body) ::= <<
for (<ImplementationType("intType")> repeatCounter = 0; repeatCounter \< <repeats>; repeatCounter++) {
    <body>
}
>>

FunctionBody(reset, body) ::= <<
<if(reset)><ResetDurationCounter()><endif>
<body>
>>

SetOfStatements(body) ::= <<
<body; separator=";\n">
>>

Chop(chop) ::= "<if(chop)> >> (<chop>)<endif>"

FiniteBitField(data, width, chop, complement, reverse) ::= <<
list.<if(reverse)>bitFieldReverse<else>bitField<endif>(<if(complement)>~<endif>((<data>)<Chop(chop)>), <width>)
>>

InfiniteBitFieldExpression(data, chop, complement) ::= <<
<if(complement)>~<endif>((<data>) \>> (<chop>))
>>

FiniteBitFieldExpression(data, width, chop, complement, reverse) ::= <<
finiteBitField(<data>, <width>, <if(chop)><chop><else>0<endif>, <complement>, <reverse>)
>>

Flash(arg)          ::= "list.flash(<arg>)"
Gap(arg)            ::= "list.gap(<arg>)"
Extent(arg)         ::= "list.extent(<arg>)"

Name(name, eval)    ::= "<name>"
NameAsDefinition(name, eval)    ::= "<name>()"

Add(arg1,arg2)      ::= "(<arg1>)+(<arg2>)"
Subtract(arg1,arg2) ::= "(<arg1>)-(<arg2>)"
Multiply(arg1,arg2) ::= "(<arg1>)*(<arg2>)"
Divide(arg1,arg2)   ::= "(<arg1>)/(<arg2>)"

add(arg1,arg2)      ::= "<arg1>+<arg2>"
sub(arg1,arg2)      ::= "<arg1>-<arg2>"
mul(arg1,arg2)      ::= "<arg1>*<arg2>"
div(arg1,arg2)      ::= "<arg1>/<arg2>"

BitwiseExclusiveOr(arg1,arg2) ::= "(<arg1>)^(<arg2>)"
BitwiseAnd(arg1,arg2)         ::= "(<arg1>)&(<arg2>)"