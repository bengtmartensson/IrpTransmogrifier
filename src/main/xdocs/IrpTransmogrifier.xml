<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="xdoc2html.xsl"?>
<!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V2.0//EN" "http://forrest.apache.org/dtd/document-v20.dtd">
<document>
    <header>
        <title>IrpTransmogrifier: Parser for IRP notation protocols, with rendering, code generation, and recognition applications.</title>
    </header>
    <body>
        <note>Possibly you should not read this document! If your are
            looking for a user friendly GUI program for generating, decoding, and analyzing IR signals etc,
            please try the program <a href="IrScrutinizer.html">IrScrutinizer</a>, and get
            back here if (and only if) you want to know the detail on IR signal
            generation.
        </note>

        <section>
            <title>Revision history</title>
            <table>
                <tr>
                    <th>Date</th>
                    <th>Description</th>
                </tr>
                <tr>
                    <td>2019-07-23</td>
                    <td>Initial version, for IrpTransmogrifier Version 1.0.0.</td>
                </tr>
            </table>
        </section>

        <section>
            <title>Revision notes</title>
            <p>
                <a href="IrpTransmogrifier.releasenotes.txt">Release notes for the current version</a>
            </p>
        </section>
        <section>
            <title>Introduction</title>
            <p>IrTransmogrifier is a software that, with the use of a data base of IR protocols,
            can generate, decode, and analyze IR signals. It can be used as am interactive command line program,
            and through its API, be embedded in a larger GUI program, like IrScrutinizer.</p>
            <p>The <em>IRP notation</em> is a domain specific language for describing IR
                protocols, i.e. ways of mapping a number of parameters to infrared
                signals. It is a very powerful, slightly cryptic, way of describing
                IR protocols, that was first developed by John Fine in a series of postings on a restricted Yahoo forum on March 13, 2003 and a few following days.
                In early 2010, Graham Dixon (mathdon in the <a
                    href="http://www.hifi-remote.com/forums">JP1-Forum</a>) wrote a <a
                    href="http://www.hifi-remote.com/wiki/index.php?title=IRP_Notation">specification</a>.
                Both this, and the present program, are Java programs/libraries,
                    written in pure Java. It can be used as a command
                line program, or it can
                be used through its API.
            </p>
            <p>This project does not contain a graphical user interface (GUI). See <a
                    href="#Main+principles">Main principles</a> for a background. Instead, the
                accompanying program <a href="IrScrutinizer.html">IrScrutinizer</a> provides a GUI.
            </p>

            <p>This is a new program, written from scratch, that is intended to replace IrpMaster, DecodeIR, and (most of) ExchangeIR,
                and much more, like potentially replacing "all" hand written decoders/renders.
                The project consists of an API library that is also callable from the command line as a command line program.
                The library has been integrated in user-friendly GUI programs, IrScrutinizer.
            </p>

            <p>For understanding this document and program, a basic understanding
                of IR protocol is assumed. However, the program
                can be successfully used just by understanding that an "IRP protocol"
                is a
                "program" in a particular "domain specific language" for turning a
                number of parameters into an IR signal, and the
                present program is a compiler/interpreter/decompiler of that language. Some parts
                of this document requires more IRP knowledge, however.
            </p>
            <section>
                <title>Background</title>
                <p>
                    This program can be considered as a successor of [IrpMaster](http://www.harctoolbox.org/IrpMaster,html).
                    The Irp parser therein is based upon a [ANTLR3 grammar](http://www.antlr.org). The "new version"
                    ANTLR4 is really not a new version, but a completely different tool, fixing most of the quirks that were irritating
                    in IrpMaster (like the "ugliness" of embedding actions within the grammar and no left recursion).
                    Unfortunately, this means that using version 4 instead of version 3 is not like updating a compiler or such,
                    but necessitates a complete rewrite of the grammar and the actions.</p>

                <p>It turned out that IrScrutionizer 1.*.* (i.e. the version based upon IrpMaster for generating and
                    <a href="http://localhost:8888/Glossary.html#DecodeIR">DecodeIR</a> for decoding)
                    had a fundamental problem: Although DecodeIR and IrpMaster (through the data base <code>IrpProtocols.ini</code>)
                    agree on most (but not all) protocols, they relied upon two different, dis-coupled sources of protocol information.
                    If the data base for the sending protocols were changed or extended, this affected sending only,
                    while decoding was not changed, and potentially conflicted with the sending protocols.
                    Also, both DecodeIR and the Analyzer,  that was used in IrScrutinizer 1.*.*, have shown to be
                    essentially impossible to maintain and extend.
                </p>
            </section>
            <section>
                <title>Dependencies</title>
                <p>The program depends on ANTLR 4 and JCommander, described below.
                    Except for building and testing of the program, and of course the Java framework,
                    there are no other dependencies. In particular, to avoid circular dependencies, it does not depend on any other Harctoolbox software.
                </p>
            </section>

            <section>
                <title>Documentation principles</title>
                <p>The role of program documentation has changed considerably the last few decades.
                    Ideally, a well designed program does not need any documentation at all.
                    Unfortunately, non-trivial problems almost never have trivial solutions,
                    so some sort of documentation is almost always necessary for sufficiently
                    complex programs.
                    The next best thing is that the program contains its own documentation,
                    for GUI programs through tool-tips, info-popups etc, for command line programs
                    through help texts. This can contain precise information over the syntax and semantic
                    of, for example, commands. Since they are integrated in the program and maintained
                    together with the program source, it is less likely that it lacks behind the actual program behavior,
                    than in the traditional program manual.</p>

                <p>The program documentation, on paper or electronically, should play another role
                    than in the last century. It should be centered around explaining the concepts
                    of the program, the "why", and not the "how". Some details that cannot in a natural way be explained
                    within the program can also be covered.</p>

                <p>The current document is written in that spirit. We do not explain the details of
                    all the commands, at least as long as it is (almost) obvious.</p>

                <p>One or more tutorial Youtube videos are planned, explaining the program and its principles more informally.</p>
            </section>

            <section>
                <title>Acknowledgement</title>
                <p>
                    I would like to acknowledge the influence of the <a href="http://hifi-remote.com/forums/index.php">JP1 forum</a>, both the programs
                    (in particular of course <a href="http://www.hifi-remote.com/wiki/index.php?title=DecodeIR">DecodeIR</a>, and the discussions
                    (in particular with Dave Reed ("3FG")). This work surely would not exist without the JP1 forum.
                </p>
            </section>

            <section>
                <title>Copyright and License</title>
                <p>
                    The program, as well as this document, is copyright by myself. Of
                    course, it is
                    based upon the <a href="#Specification_of_IRP_Notation">IRP
                        documentation</a>, but is to be considered original work. The "database
                    file" <code>IrpProtocols.xml</code> is derived from many sources, in particular <a
                        href="#DecodeIR.html">DecodeIR.html</a>, so I do not claim copyright.</p>

                <p>The program uses some third-party project. It depends on <a
                        href="http://www.antlr.org/">ANTLR4</a> (<a href="https://github.com/antlr/antlr4/blob/master/LICENSE.txt">license</a>),
                    and  <a href="https://www.stringtemplate.org/">Stringtemplate</a>
                    (<a href="https://github.com/antlr/stringtemplate4/blob/master/LICENSE.txt">license</a>) by Terence Parr.
                    It also uses the command argumend decoder <a href="http://jcommander.org/">JCommander</a>
                    by CÃ©dric Beust. This is free software released under the
                    <a href="https://github.com/cbeust/jcommander/blob/master/license.txt">Apache 2.0 license</a>.
                </p>

                <p>The program and its documentation are licensed under the <a
                        href="http://www.gnu.org/licenses/gpl.html">GNU General Public License version
                        3</a>, making everyone free to use, study, improve, etc., under certain
                    conditions.</p>
            </section>
        </section>

        <section>
            <title>Main principles</title>
            <section>
                <title>Design principles</title>
                <p>It is my opinion that it is better to get the functionality and the
                    API right, before you do a graphical user interface (GUI). It is much
                    easier and logical to put a GUI on top of a sane API, then to try to
                    extract API functionality from a program that was never designed
                    sanely but built around the GUI. (Look at WinZip for a good example of
                    the latter. Or almost any Windows program, commercial or freeware...)</p>
                <p>
                    I have tried to follow the IRP document, Section 1 -- 13, as closely as possible, in
                    particular with respect to the grammar and the syntax.</p>
                <section>
                    <title>Performance considerations</title>
                    <p>
                        Performance consideration, both time and space, were given minimal priorities. As it stands,
                        rendering a single IR signal typically takes less than 1 ms, so this
                        seems justified.
                        However, the decoding mechanism is intrinsically much slower that DecodeIR due to
                        the method used. A single decode can take several hundred milli-seconds.
                        However, in normal interactive use of IrScrutinizer, this is not user noticeable.
                    </p>
                </section>
                <section>
                    <title>Data types</title>
                    <p>
                        Everything that is a physical quantity
                        (durations and frequency), are real numbers (in the code double
                        precision numbers), and are internally represented as a double.</p>
                    <p>Durations are always given in micro seconds. Unless in a context where the
                        IRP says otherwise, all others quantities are given
                        in (pure) SI units without prefix. So is duty cycle and relative tolerance both a real
                        number between 0 and 1, not a number of percents. Modulation frequency is given in Hz, not it kHz
                        (unless in the GeneralSpec).
                    </p>
                    <p>
                        Integer quantities are in principle arbitrarily large, but in some cases limited to 63 bits.
                    </p>
                    <p>Integer literals can be given in base 16 (using prefix "0x"), base 8 (using prefix "0"),
                        base 2 (using prefix "0b"), as well as in base 10 (no prefix, omitting leading zeros).</p>
                    <p>
                        All "integer quantities" like expressions, where previously done in Java's long
                        format, 64 bits long, amounting to 63 bits plus sign.
                        Using this principle, all parameters are limited to Java's long, and can thus be
                        no larger than  2^63-1 = 9223372036854775807.</p>

                    <p>Work is ongoing to remove this restriction, by, alternatively using Java's <code>BigInteger</code>.
                        At the time of this writing, this is only partially implemented.
                    </p>
                </section>
                <section>
                    <title>Internationalization</title>
                    <p>
                        Being a command line program and API library, this project is not a
                        a candidate for internationalization.</p>
                </section>
            </section>
        </section>
        <section>
            <title>Theory and general concepts</title>
            <section>
                <title>Main concepts</title>
                <section>
                    <title>IrSequence</title>
                    <p>
                        Sequence of time durations, in general in expressed microseconds,
                        together with a modulation frequency.
                        The even numbered entries normally denote times when the IR light is on (modulated), called "flashes" or sometimes "marks",
                        the other denote off-periods, "gaps" or "spaces". They always start with a flash, and end with a gap.
                    </p>
                </section>

                <section>
                    <title>IrSignal</title>
                    <p>Consists of three <a href="#IrSequence">IR sequences</a>, called</p>
                    <ol>
                        <li>
                            <em>start sequence</em> (or "intro", or
                            "beginning sequence"), sent exactly once at the beginning of the transmission
                            of the IR signal,</li>
                        <li>
                            <em>repeat  sequence</em>, sent "while the
                            button is held down", i.e. zero or more times during the transmission
                            of the IR signal (although some protocols may require at least one copy to be transmitted),</li>
                        <li>
                            <em>ending sequence</em>, sent exactly once at
                            the end of the transmission of the IR signal, "when the button has been
                            released". Only present in a few protocols.</li>
                    </ol>
                    <p>
                        Any of these can be empty, but not both the intro and the repeat. A
                        non-empty ending sequence is only meaningful with a non-empty repeat.
                    </p>
                </section>

                <section>
                    <title>Repeat finder</title>
                </section>

                <section>
                    <title>Protocol data base</title>
                </section>

                <section>
                    <title>Writing protocol for decoding</title>
                </section>
            </section>
        </section>

        <section>
            <title>Use cases</title>
            <p>
                The reason for this project is not (just) to migrate IrpMaster to ANTLR4 -- version 3 is still operational,
                and no more broken than it was at the start. There are a number of interesting use cases for a nice parser/tree traverser:</p>

            <section>
                <title>Rendering</title>
                <p>This use case corresponds to IrpMaster. It is probably to be implemented as a traversing of the parse tree of an IRP protocol,
                    with numerical values assigned to the parameters.</p>

                <p>In the present implementation, only one infinite repeat is allowed.
                    (A realistic protocol, or use case, requiring more than
                    one infinite repeat is not known to me.) Also, individual bitfields are restricted to 63 bits of length or less.
                    (This is inherited from the use of Java's long type. It [may be removed in the future](https://github.com/bengtmartensson/IrpTransmogrifier/issues/38).)
                    With the exception of these restriction, the implementations should be complete, down to specification holes.
                    There are also a few extensions to the IRP notation as described in the [official documenation](http://www.hifi-remote.com/wiki/index.php/IRP_Notation).</p>

                <p>In IrScrutinizer, the word "generate" is used instead of "render". These words can be considered as synonyms (here).</p>
            </section>

            <section>
                <title>Recognition</title>
                <p>
                    This use case corresponds to a dynamic version of DecodeIR: given a numerical IR signal,
                    find the parameter/protocol combination(s) that could have generated the given signal.
                    This is implemented by trying to parse the given signal with respect to the candidate protocols.
                    It is thus very systematic, but [comparatively slow](https://github.com/bengtmartensson/IrpTransmogrifier/issues/44).</p>

                <p>
                    It is not claimed that all protocols in the protocol data base are recognizable.
                    Non-recognizable protocols are to be marked by setting the <code>decodable</code> parameter to <code>false</code>.
                    To be recognizable, the IRP protocol should preferably adhere to some additional rules:

                </p>
                <ul>
                    <li>The "+" form of repetitions is discouraged in favor of the "*" form.</li>
                    <li>The width and shift of a Bitfield must be constant</li>
                    <li>The decoder is capable of _simple_ equation solving (e.g. <code>Arctech</code>),
                        but not of complicated equation solving (e.g. <code>Fujitsu_Aircon</code>).</li>
                </ul>

                <p>
                    Presently all but two protocols (<code>zenith</code>, <code>nec1-shirrif</code>, (bitfield width as parameter), <code>fujitsu_aircon</code> (would require non-trivial equation solving))
                    are recognizable.  It is not guaranteed that new protocols automatically will be recognizable.</p>
            </section>

            <section>
                <title>Loose matches, Guessing</title>
                <p>
                    Many captured signals are not quite correct according to their protocol. However, the firmware in a receiving device is often "forgiving",
                    and accepts slightly flawed signals. It is thus desirable for a program of this type to find a near match, "guess", when an real match fails.
                    The program currently does not implement this, however, it is [planned](https://github.com/bengtmartensson/IrpTransmogrifier/issues/42).</p>
            </section>

            <section>
                <title>Code generation for rendering and/or decoding</title>
                <p>
                    For a particular protocol, generate target code (C, C++, Java, Python,...) that can render or decode signals
                    with the selected protocol. As opposed to the previous use cases, efficency (memory, execution time) (for the generated code) is potentially
                    an issue. This should be able to generate protocol renders for e.g. the Arduino libraries IrRemote, IrLib, and AGirs.
                    At least in the first version, not all protocols describable by IRPs need to be supported. Not implemented in the first phase: Protocols with hierarchical bitspecs
                    (rc6*, replay, arctech, entone), protocols with bitspec lenght as parameter (zenith, nec1-shirrif). Also default are not implemented, e.g. NEC1 has to be
                    called with 3 parameters.</p>

                <p>
                    Two mechanisms are available: XML and [Stringtemplate](http://www.stringtemplate.org/).
                    The program does not come with an XSLT engine, so this has to be invoked independently on the XML export.
                    The program just invokes the template, without caring what it does; if it generates a renderer or decoder.
                    The user is instead governs this by invoking the style sheets or templates (s)he want using the <code>--target</code> (<code>-t</code>) option to the <code>code</code> sub subcommand.
                    (For this reason, there is no <code>--renderer</code> or <code>--decoder</code> option to the <code>code</code> sub command.)
                    It is also possible to pass
                    target-specific parameters to the code generators using the <code>--parameter</code> (<code>-p</code>) argument.</p>

                <p>Targets:</p>
                <dl>
                    <dt>Lircd.conf(http://lirc.org/html/lircd.conf.html)</dt>
                    <dd>generation from IrScrutinizer. This is based on an XSLT-transformation (<code>lirc.xsd</code>) and generates
                        [an XSLT (version 1) file that can work with IrScrutinizer](https://github.com/bengtmartensson/harctoolboxbundle/blob/master/IrScrutinizer/src/main/config/exportformats.d/lirc.xml).
                        Handling of definitions as well as expressions as bitfields not implemented, as well as a few other things (search for "omitted" in the above file),
                        otherwise works. "90% complete", see [this issue](https://github.com/bengtmartensson/IrpTransmogrifier/issues/6).
                        To create: see (or execute) the shell script <code>tools/generate-lirc.sh</code>. In short, this generates the xml export, and then invokes
                        xslt transformations on that xml file.</dd>
                    <dt>Java</dt>
                    <dd>Essentially for testing. This is essentially working both for rendering and decoding, including a generated test rig
                        (see the [test project](https://github.com/bengtmartensson/JavaIrpProtocolTest)). Targets: <code>java-decoder java-decoder-test java-renderer java-renderer-test</code>.
                        Not quite finished, see [this issue](https://github.com/bengtmartensson/IrpTransmogrifier/issues/25).</dd>
                </dl>

                <p>Some possible future targets:</p>
                <ul>
                    <li>[Infrared4Arduino](https://github.com/bengtmartensson/Infrared4Arduino).</li>
                    <li>[IRremote](https://github.com/z3t0/Arduino-IRremote)</li>
                    <li>Linux kernel modules in [linux/drivers/media/rc](https://github.com/torvalds/linux/tree/master/drivers/media/rc) (decoding only).</li>
                </ul>
            </section>

            <section>
                <title>General code analysis</title>
                <p>
                    Not really connected to parsing IRP, but fits in the general framework.
                    This has been inspired by to the Analyzer and the RepeatFinder in
                    <a href="http://www.hifi-remote.com/forums/dload.php?action=file&amp;file_id=8460">Graham Dixon's ExchangeIR</a>
                    <a href="https://sourceforge.net/p/controlremote/code/HEAD/tree/trunk/exchangeir/">(Java translation)</a>.</p>
                <section>
                    <title>Subcommand analyze</title>
                    <p>
                        The "analyze" command takes as input one or several sequences or signals,
                        and computes an IRP form that corresponds to the given input (within
                        the specified tolerances). The input can be given either as Pronto
                        Hex or in raw form, optionally with signs (ignored). Several raw
                        format input sequences can be given by enclosing the individual sequences
                        in brackets ("[]"). However, if using the <code>--intro-repeat-ending</code> option,
                        the sequences are instead interpreted as intro-, repeat-, and (optionally)
                        ending sequences of an IR signal.</p>

                    <p>
                        For raw sequences, an explicit modulation frequency can be given with
                        the <code>--frequency</code> option. Otherwise the default frequency, 38000Hz,
                        will be assumed.
                        If this option is given together with a Pronto type signal (which contains
                        a modulation frequency), it is ignored.</p>

                    <p>Using the option <code>--input</code>, instead the content of a file can be taken
                        as input, containing sequences to be analyzed, one per line, blank
                        lines ignored. Using the option <code>--namedinput</code>, the sequences may have
                        names, immediately preceeding the sequence.
                        In both cases, the data is taken as IrSequences.
                        IrSignals, with intro-, repeat-, and ending, are coerced into IrSequences.</p>

                    <p>
                        In the Harctoolbox world, IR sequences start with a flash (mark) and ends with a
                        non-zero gap (space). In some other "worlds", the last gap is omitted. These signal
                        are in general rejected. The option <code>--trailinggap duration</code> adds a dummy duration
                        to the end of each IR sequence lacking a final gap.</p>

                    <p>Input sequences can be pre-processed using the options <code>--chop</code>, <code>--clean</code>,
                        and <code>--repeatfinder</code>
                    </p>

                    <p>The cleaner works according to this idea: The collected durations found in the sequence(s)
                        are bundled into "bins" (disjoint intervals), according to <code>absolutetolerance</code> and <code>relativetolerance</code>.
                        Every duration belonging to a bin is "close" (determined by those parameters) to the bin
                        middle. All the durations within the bin are then replaced by the average of its
                        members. It is thus not guaranteed that the distance between a duration and its replacement
                        will be consistent with <code>absolutetolerance</code> and <code>relativetolerance</code>.</p>

                    <p>
                        The input sequence(s) are matched using different "decoders". Normally
                        the "best" decoder match is output. With the <code>--all</code> option, all decoder
                        matches are output.</p>

                    <p>The options <code>--statistics</code> and <code>--dump-repeatfinder</code> (the latter forces
                        the repeatfinder to be on) can be used to print extra information.
                        The common options <code>--absolutetolerance</code>, <code>--relativetolerance</code>, <code>--minrepeatgap</code>
                        determine how the repeat finder breaks the input data. The options
                        <code>--extent</code>, <code>--invert</code>, <code>--lsb</code>, <code>--maxmicroseconds</code>, <code>--maxparameterwidth</code>,
                        <code>--maxroundingerror</code>, <code>--maxunits</code>, <code>--parameterwidths</code>, <code>--radix</code>, and <code>--timebase</code>
                        determine how the computed IRP is displayed.</p>
                </section>

            </section>
            <section>
                <title>Protocol Data Base</title>
                <p>
                    The "ini"-file <code>IrpProtocols.ini</code> of IrpMaster has been replaced by an XML file,
                    per default called <code>IrpProtocols.xml</code>. The XML format
                    is defined by the W3C schema [irp-protocols](http://www.harctoolbox.org/schemas/irp-protocols.xsd), and has the name space
                    <code>http://www.harctoolbox.org/irp-protocols</code>. This format has many advantages in
                    comparison with the simpler previous format, for example, it can contain embedded XHTLM fragments,
                    for writing documentation.
                    It also can contain different parameters that can be used by different programs, for example, tolerance parameters
                    for decoding.
                    Arbitrary string-valued parameters are permitted. It is up to an interpreting program to determine the semantic.
                    Within IrpTransmogrifier, this is used for providing protocol-specific values for the parameters
                    absolutetolerance, relativetolerance  TODO.

                </p>

                <p>
                    There is also an XSLT stylesheet, which technically translates the XML to HTML, allowing for creating an
                    HTML version of <code>IrpProtocols.xml</code>, for reading in a HTML browser.</p>
                <p>
                    Using the sub-command <code>convertconfig</code>,
                    the program is capable of reading and translating to and from the old format <code>IrpProtocols.ini</code>.
                </p>
            </section>

            <section>
                <title>Installation</title>
                <p>
                    Unpack the binary distribution in a new, empty directory. Start the program by invoking the wrapper
                    (<code>irptransmobrifier.bat</code> on Windows, <code>irptransmogrifier.sh</code> on Unix-like systems like Linux and MacOS.)
                    from the command line.
                    Modify and/or relocate the wrapper(s) if desired or necessary.
                    Do not double click the wrappers, since this program runs only from the command line.</p>

                <section>
                    <title>Building from sources</title>
                    <p>
                        The project uses [Maven](https://maven.apache.org/) as build system. Any modern IDE should be able
                        to open/import and build it (as Maven project). Of course, Maven can also be run from the command line,
                        like</p>
                    <source>
                        mvn install
                    </source>
                </section>
                <section>
                    <title>Dependencies</title>


                    <section>
                        <title>Usage</title>
                        <p>
                            Using from the command line, this is a command with subcommands. Before the sub command,
                            common options can be given. After the command, command-specific options can be specified.
                            Commands and option names can be abbreviated, as long as the abbreviation is unique.
                            They are matched case sensitively, and can be abbreviated as long as the abbreviation is unambiguous.
                        </p>
                        <p>
                            The command

                            irptransmogrifier help --short
                            lists the subcommands.
                            A command like

                            irptransmogrifier analyze --help
                            gives the usage for the subcommand <code>analyze</code>,
                            while a command like

                            irptransmogrifier analyze --help
                            gives a possibly somewhat longer description for the subcommand <code>analyze</code>.


                            The subcommands are briefly described next.</p>

                    </section>

                    <section>
                        <title>Subcommand bitfield</title>
                        <p>
                            The "bitfield" command computes the value and the binary form corresponding
                            to the bitfield given as input. Using the <code>--nameengine</code> argument,
                            the bitfield can also refer to names.</p>

                        <p>
                            As an alternatively, the "expression" command may be used.</p>
                    </section>

                    <section>
                        <title>Subcommand code</title>
                        <p>
                            Used for generating code for different targets.</p>
                    </section>

                    <section>
                        <title>Subcommand convertconfig</title>
                        <p>This command converts between the xml form and the ini form on IrpProtocols.
                            decode --desc</p>
                    </section>

                    <section>
                        <title>Subcommand decode</title>
                        <p>
                            The "decode" command takes as input one or several sequences or signals,
                            and output one or many protocol/parameter combinations that corresponds
                            to the given input (within the specified tolerances). The input can
                            be given either as Pronto Hex or in raw form, optionally with signs
                            (ignored). Several raw format input sequences can be given by enclosing
                            the individual sequences in brackets ("[]").</p>

                        <p>
                            For raw sequences, an explicit modulation frequency can be given with
                            the <code>--frequency</code> option. Otherwise the default frequency, 38000Hz,
                            will be assumed.</p>

                        <p>
                            Using the option <code>--input</code>, instead the content of a file can be taken
                            as input, containing sequences to be analyzed, one per line, blank
                            lines ignored. Using the option <code>--namedinput</code>, the sequences may have
                            names, immediately preceeding the signal.</p>

                        <p>
                            In the Harctoolbox world, IR sequences start with a flash (mark) and ends with a
                            non-zero gap (space). In some other "worlds", the last gap is omitted. These signal
                            are in general rejected. The option <code>--trailinggap duration</code> adds a dummy duration
                            to the end of each IR sequence lacking a final gap.</p>

                        <p>
                            Input sequences can be pre-processed using the options <code>--clean</code>, and
                            <code>--repeatfinder</code>.</p>

                        <p>
                            The common options <code>--absolutetolerance</code>, <code>--relativetolerance</code>, <code>--minrepeatgap</code>
                            determine how the repeat finder breaks the input data.</p>

                    </section>
                    <section>
                        <title>Subcommand help</title>
                        <p>This command list the syntax for the command(s) given as argument,
                            default all. Also see the option <code>--describe</code>.</p>

                    </section>
                    <section>
                        <title>Subcommand lirc</title>
                        <p>
                            This command reads a Lirc configuration, from a file, directory, or
                            an URL, and computes a correponding IRP form.</p>
                    </section>
                    <section>
                        <title>Subcommand list</title>
                        <p>
                            This command list miscellaneous properties of the protocol(s) given
                            as arguments.</p>
                    </section>
                    <section>
                        <title>Subcommand render</title>
                        <p>
                            This command is used to compute an IR signal from one or more protocols
                            ("render" it). The protocol can be given either by name(s) (or regular
                            expression if using the <code>--regexp</code> option), or, using the <code>--irp</code> options,
                            given explicitly as an IRP form. The parameters can be either given
                            directly with the -n option,or the <code>--random</code> option can be used to
                            generate random, but valid parameters. With the <code>--count</code> or <code>--number-repeats</code>
                            option, instead an IR sequence is computed,containing the desired
                            number of repeats.</p>
                    </section>

                    <section>
                        <title>Subcommand version</title>
                        <p>
                            Reports version number and license.</p>
                    </section>
                </section>
            </section>
        </section>

        <section>
            <title>Installing</title>
            <p>There is no "installer" for IrpTransmogrifier.
                The normal way to install the program is to <a href="IrScrutinizer.html#Installation">install IrScrutinizer</a>.
                This will install a wrapper for IrpTransmogrifier too.
                (However the st- and xslt-files, <!-- TODO Link -->
                are not included.)
            </p>

            <p>
                On Github, the
                <a href="https://github.com/bengtmartensson/IrpTransmogrifier/releases/latest">latest official source- and binary distribution</a>
                is found. Also, the <a href="https://github.com/bengtmartensson/IrpTransmogrifier/releases/tag/ci-build">development version</a> can be found.
            </p>

            <p>In all cases, there is a wrapper, <code>irptransmogrifier.bat</code> (for Windows) or <code>irscrutinizer.sh</code> (for other systems),
                that is used to execute the pure-java IrpTransmogrifier program.</p>
        </section>
        <section>
            <title>Usage of the program from the command line</title>
            <p>I will next describe how to invoke the program from the command line.
                Elementary knowledge of command line usage is assumed.</p>
            <p>
                There is a lot of functionality crammed in the command line interface.
                The usage message of the program gives an extremely brief summary:</p>

            <p>
                In the simplest and most general form, parameter assignments are made
                on the command line in one argument of the type <em>
                    <code>name=value</code>
                </em>. On both sides of the
                "="-signs, there should not be any spaces. (More precisely, it is
                required that all assignments are made within a single "argument" to
                the program, which is determined by the command line interpreter. Thus
                writing the arguments within single or double quotes, extra spaces can
                be parsed.) After named parameters are given (possibly none), up to
                four "standard" parameters can be given. These are, in order D, S, F,
                and T (which per convention in the JP1 community stands for
                "Device", "Subdevice", "Function" (also called OBC or command number),
                and "Toggle"). If using -1 as the value, that parameter is considered
                as not being assigned. One value without name defaults to <code>F</code>,
                two values defaults to <code>D</code> and <code>F</code>, three values defaults to <code>D</code>, <code>S</code>,
                and <code>F</code>, and four to <code>D</code>, <code>S</code>, <code>F</code>, and <code>T</code>, in the order given.
                For example,</p>
                <source>E=12 34 -1 56 1</source>
                <p>
                    assigns the value 12 to E, the value 34 to
                    D, the value of 56 to F, and 1 to T, while S is not assigned anything
                    at all. Parameters can be given not only in decimal notation, but also
                    as hexadecimal (using prefix 0x) binary (using prefix 0b or %), or
                    octal (using prefix 0). </p>
                <p>
                    If the command line cannot be parsed the usage message will be printed.
                    If you are unsure of exactly what is wrong, consider issuing "<code>-d
                        1</code>" (the debug option with argument 1) as the first argument on
                    the command line, which may produce more verbose error messages. </p>
                <p>
                    Using the <code>-r</code> or <code>--raw</code> option, the output is
                    given in "raw form" (in JP1-Forum jargon, this is a sequence of
                    positive numbers (indicating "flashes", or on-times in micro seconds)
                    and negative numbers (indicating "gaps" or off-times, where the
                    absolute value indicates the duration in micro seconds. Carrier
                    frequency is specified separately). Alternatively, or additionally,
                    using the <code>-p</code> or <code>--pronto</code> option, output is
                    produced in the so-called Pronto format, see e.g. <a
                        href="http://www.hifi-remote.com/wiki/index.php?title=Working_With_Pronto_Hex">this
                        document</a>. This format is popular in several IR using Internet
                    communities, like <a href="http://www.promixis.com">Promixis</a>
                    (known for their (commercial) products Girder and NetRemote), as well
                    as <a href="http://www.eventghost.net">EventGhost</a>. Optionally,
                    these can be wrapped into an XML skeleton, offering an ideal platform
                    for translating to every other IR format this planet has encountered.
                    If desired, the output of the program is directed to a particular named
                    file using the <code>-o </code>
                    <em>
                        <code>filename</code>
                    </em>
                    or <code>--output </code>
                    <em>
                        <code>filename</code>
                    </em>
                    option. (There is also a possibility (using the <code>--ict</code> or
                    <code>-I</code> option) to generate output files in <a
                        href="http://www.hifi-remote.com/wiki/index.php?title=IR_Scope_and_IR_Widget_User%27s_Guide">IRScope's
                        ict-format</a>, but I am not sure this was as wise design decision: it
                    may be a better idea to generate additional formats by post-processing
                    the XML file.)</p>
        </section>
        <section>
            <title>Iterating over input parameter ranges</title>
            <p>Either for generating configuration files for other programs, or for
                testing, there is a very advanced feature for looping over input
                parameter sets. For all of the parameters to a protocol, instead of a
                single value, a set can be given. The program then computes all IR
                signals/sequences belonging to the <a
                    href="http://en.wikipedia.org/wiki/Cartesian_product">Cartesian product</a>
                of the input parameter sets. There are five types of parameter
                sets:</p>
            <ol>
                <li>Of course, there is the singleton set, just consisting of one
                    value</li>
                <li>There is also a possibility to give some arbitrary values,
                    separated by commas. Actually, the commas even separate sets, in the
                    sense of the current paragraph.</li>
                <li>An interval, optionally with a stride different from 1, can be
                    given, either as <code>min..max++increment</code> or
                    <code>min:max++increment</code>, or alternatively, simply as *, which will get
                    the min and max values from the parameter's parameter specs.  </li>
                <li>Also, a set can be given as <code>a:b&lt;&lt;c</code>,
                    which has the following semantics: starting with <code>a</code>, this
                    is shifted to the left by <code>c</code> bits, until <code>b</code>
                    has been exceeded (reminding of the left-shift operator <code>&lt;&lt;</code>
                    found in languages such as C).</li>
                <li>Finally, <code>a:b#c</code> generates c pseudo random numbers between a and b
                    (inclusive). The "pseudo random" numbers are completely
                    deterministically determined from the seed, optionally given with the
                    <code>--seed</code> option. As of version 0.2.2 <code>a</code> and
                    <code>b></code> are optional. If left out, the values are taken as from the protocol parameters min
                    and max respectively, just as with the <code>*</code> form.</li>
            </ol>
            <p>
                See the test file <code>test.sh</code> (include in the distributions) for some examples.
                Of course, using the command line, some of the involved characters,
                most notably the *, has a meaning to the command line interpreter and
                may need "escaping" by a backslash character, or double or single
                quotes.</p>
            <p>
                There is also an option, denoted -<code>#</code> or <code>--repetitions
                </code>taking an integer argument, that will compute that many "copies"
                of the IR signal or sequence. This may be of interest for signals that
                are non-constant (toggles being the simplest example) or for profiling
                the program.</p>
        </section>
        <section>
            <title>Debugging/logging possibilities</title>
            <p>
                TO BE WRITTEN
            </p>
        </section>
        <section>
            <title>Third-party Java archives (jars)</title>
            <p>
                The program depends on <a href="https://www.antlr.org">ANTLR4</a> (<a href="https://github.com/antlr/antlr4/blob/master/LICENSE.txt">license</a>),
                <a href="https://www.stringtemplate.org/">Stringtemplate</a> (<a href="https://github.com/antlr/stringtemplate4/blob/master/LICENSE.txt">license</a>),
                as well as the command line decoder <a href="http://jcommander.org/">JCommander</a>
                (licensed under the <a href="https://github.com/cbeust/jcommander/blob/master/license.txt">Apache 2 license</a>).</p>
            <p>
                When using Maven for building, these are automatically downloaded and installed.
            </p>
        </section>
        <section>
            <title>Extensions to, and deviation from, IRP semantic and syntax</title>
            <section>
                <title>Repetitions</title>
                <p>Possibly the major difficulty in turning the IRP Specification into
                    programming code was how to make sense of its
                    <a href="http://www.hifi-remote.com/wiki/index.php?title=IRP_Notation#Repeat_markers">repetition concept</a>.
                    Most formalisms on IR signals (for example the Pronto format) considers an IR
                    signal as an introduction sequence (corresponding to pressing a button
                    on a remote control once), followed by a repeating signal,
                    corresponding to holding down a repeating button. Any, but not both of
                    these may be empty. In a few relatively rare cases, there is also an
                    ending sequence, send after a repeating button has been released.
                    Probably 99% of all IR signals fit into the intro/repetition scheme,
                    allowing ending sequence in addition should leave very few practically
                    used IR signals left. In "abstract" IRP notation, these are of the form
                    A,(B)*,C with A, B, and C being (possibly empty) "bare irstreams".</p>
                <p>
                    In contrast, the IRP notation reminds of they syntax and
                    semantics of regular expressions: There may be any numbers, and they
                    can even be hierarchical. There certainly does not appear to be a
                    consensus on how this extremely general notation should be
                    practically thought of as a generator of IR signals.</p>
                <p>
                    The predecessor program IrpMaster tried to be very smart here, by trying to
                    implement all aspects, with the exception of hierarchical repetitions (repetitions within repetitions).
                    This never turned out to be useful.
                    The present program takes a simpler approach, by prohibiting multiple (infinite) repetitions.
                </p>
            </section>
            <section>
                <title>Parameter Specifications</title>
                <p>
                    In the first, now obsolete, version of the IRP notation the parameters
                    of a protocol had to be declared with the allowed max- and min-value. This is
                    not present in the <a
                        href="http://www.hifi-remote.com/wiki/index.php?title=IRP_Notation">current
                        specification version 2</a>. I
                    have reinvented this, using the name parameter_spec. For example, the
                    well known NEC1 protocol, the Parameter Spec reads:
                    <code>[D:0..255,S:0..255=255-D,F:0..255]</code>. (D, S, and F have the
                    semantics of device, sub-device, and function or
                    command number.) This defines the three variables D, S, and F, having
                    the allowed domain the integers between 0 and 255. D and F must be
                    given, however, S has a default value that is used if the user does not
                    supply a value. The software requires that the values without default
                    values are actually given, and within the stated limits. If, and only
                    if, the parameter specs is incomplete, there may occur run-time errors
                    concerning not assigned values. It is the duty of the IRP author to
                    ensure that all variables that are referenced within the main
                    body of the IRP are defined either within the parameter specs, defined
                    with "definitions" (Chapter 10 of the specification), or assigned in
                    assignments before usage, otherwise a run-time error will occur
                    (technically an <code>NameUnassignedException</code> will be thrown). </p>
                <p>
                    The preferred ordering of the parameters is: D, S (if present), F, T
                    (if present), then the rest in alphabetical order,</p>
                <p>
                    The formal syntax is as follows, where the semantic of the '@' will be
                    explained in the <a href="#Persistency+of+variables">following section</a>:</p>
                  <source>
parameter_specs:
    '[' parameter_spec (',' parameter_spec )* ']' | '['  ']'

parameter_spec:
     name     ':' number '.' '.' number ('=' bare_expression)?
   | name '@' ':' number '.' '.' number '=' bare_expression
                  </source>
            </section>
            <section>
                <title>The GeneralSpec</title>
                <p>
                    For the implementation, I allow the four parts (three in the original
                    specification) to be given in any order, if at all, but I do not
                    disallow multiple occurrences &#x2014; it is quite hard to implement cleanly and
                    simply not worth it. (For example, ANTLR does not implement exclusions. The only
                    language/grammar I know with that property is SGML, which is probably
                    one of the reasons why it was considered so difficult (in comparison
                    to XML) to write a complete parser.)
                </p>
                <p>
                    The default frequency is 38kHz, not 0kHz as in the specification.
                    It is encouraged to use the default, not an explicit "38k", for the cases of
                    modulation frequency not reasonable well known, but close enough to 38kHz.
                </p>
                <section>
                    <title>GeneralSpecs, duty cycle</title>
                    <p>
                        Without any very good reason, I allow a duty cycle in percent to be
                        given within the GeneralSpec, for example as <code>{37k,123,msb,33%}</code>.
                        It is currently not used for anything, but preserved through the processing and
                        can be retrieved using API-functions. If some, possibly future, hardware needs
                        it, it is there.</p>
                </section>
            </section>
            <section>
                <title>Persistency of variables</title>
                <p>
                    Graham, in the specification and in following forum contributions,
                    appears to consider all variables in a IRP description as intrinsically
                    persistent: They do not need explicit initialization, if they are not,
                    they are initialized to an undefined, random value. This may be a
                    reasonable model for a particular physical remote control, however,
                    from a scientific standpoint it is less attractive. I have a way of
                    denoting a variable, typically a toggle of some sort, as persistent by
                    appending an "@" to its name in the parameter specs. An initial value
                    (with syntax as default value) is here mandatory. It is set to its
                    initial value by the constructor of the Protocol class. Calling the
                    renderIrSignal(...) function or such of the Protocol instance typically
                    updates the value (as given in an assignment, a 0-1 toggle goes like
                    T=1-T). As opposed to variables that has not been declared as
                    persistent, it (normally) retains its value between the invocations of
                    renderIrSignal(...).  A toggle is typically declared as <code>[T@:0..1=0]
                    </code>in the parameter specs.</p>
            </section>
            <section>
                <title>Comments</title>
                <p>
                    Comments in the C syntax (starting with <code>/*</code> and ended by
                    <code>*/</code>) are allowed and ignored.
                    Also, C++-style comments ("//" until end of line) are accepted.
                </p>
            </section>
            <section>
                <title>Whitespace</title>
                <p>
                    All white space, including line breaks, are ignored. (In the original spec, the IRP form has to be on one line.)
                </p>
            </section>

            <section>
                <title>Extents</title>
                <p>The specification writes ``<em>An extent has a scope which consists of a
                        consecutive range of items that immediately precede the extent in the order of
                        transmission in the signal. ... The precise scope of an extent has to be
                        defined in the context in which it is used.</em>'', and, to my best knowledge,
                    nothing more. I consider it as
                    specification hole.
                    I have effectively implemented this interpretation:
                    âAn extent has a scope which consists of a consecutive range of all non-extent items
                    that immediately precede the extent in the order of transmission in the signal,
                    starting with the first element after the last preceding extent, or from the start if there is no preceding extent.â
                    Differently put: Every extend encountered resets the duration count.
                </p>
            </section>
            <section>
                <title>Multiple definitions allowed</title>
                <p>
                    It turned out that the <a
                        href="#Preprocessing+and+inheritance">preprocessing/inheritance
                        concept</a> necessitated allowing several definition objects. These are
                    simply evaluated in the order they are encountered, possibly
                    overwriting previous content. </p>
            </section>
            <section>
                <title>Names</title>
                <p>
                    Previous programs, like makehex have only allowed one-letter
                    names. However, in  <a
                        href="http://www.hifi-remote.com/wiki/index.php?title=DecodeIR">DecodeIR.html</a>
                    there are some multi-letter names. The
                    IRP documentation allows multi-letter names, using only capital
                    letters. I have, admittedly somewhat arbitrarily, extended it to the
                    C-name syntax: Letters (both upper and lower cases) and digits allowed,
                    starting with letter. Underscore "_" counts as letter. Case is
                    significant.</p>
            </section>
            <section>
                <title>Namespaces</title>
                <p>
                    There is a difference in between the IRP documentation and the
                    implementation of the Makehex program, in that the former has one name
                    space for both <em>assignments</em> and <em>definitions</em>, while the
                    latter has two different name spaces. IrpTransmogrifier (just as the precessor IrpMaster) has one name space, as
                    in the documentation. (This is implemented with the <code>NameEngine</code>
                    class.)</p>
            </section>
            <section>
                <title>Expressions</title>
                <p>
                    Some extensions to the expressions have been made. Note that, informally speaking,
                    an expression is an integer, that, in different contexts are differently interpreted: as integer value,
                    (potentially infinite) bit pattern (using 2-complement representation),
                    and logical (0 is <code>false</code>, everything else is <code>true</code>).
                </p>
                <section>
                    <title>Terminology</title>
                    <p>In the code, we use the terms <em>para_expression</em> and <em>expression</em>
                        instead of the specification's <em>expression</em> and <em>bare_expression</em>,
                        since it was felt that the latter was too far away from normal-day usage.</p>
                </section>
                <section>
                    <title>Literals</title>
                    <p>A few pre-defined literals are introduced for convenience and readability.
                        These are:</p>
                    <ul>
                        <li>
                            <code>UINT8_MAX</code> 2^8 - 1 = 255,
                        </li>
                        <li>
                            <code>UINT16_MAX</code> = 2^16 - 1 = 65535,</li>
                        <li>
                            <code>UINT24_MAX</code> = 2^24 - 1 = 16777215,</li>
                        <li>
                            <code>UINT32_MAX</code> = 2^32 - 1 = 4294967295, and</li>
                        <li>
                            <code>UINT64_MAX</code> = 2^64 - 1 = 18446744073709551615.</li>
                    </ul>
                </section>
                <section>
                    <title>Unary operators</title>
                    <p>In addition to the specification's unary minus ("-"), some additional unary operators have been implemented, described next.</p>
                    <section>
                        <title>Logical not, "!"</title>
                        <p>The exclamation point, logical not, acts like in C:
                            it turns everything that evaluates to 0 (zero) into 1 (<code>true</code>),
                        everything else to 0 (<code>false</code>).</p>
                    </section>
                    <section>
                        <title>Bit inversion, "~"</title>
                        <p>
                            This operator turns all 0 to 1 and all 1 to 0 in the binary representation.
                        </p>
                    </section>
                    <section>
                        <title>BitCount Function</title>
                        <p>
                            Generally, I think you should be very reluctant to add "nice features"
                            to something like IRP. However, in the applications in DecodeIR.html,
                            the phrase "number of ones", often modulo 2 ("parity"), occurs
                            frequently in the more complicated protocols. This is awkward and
                            error prone to implement using expressions, for example: <code>F:1 + F:1:1 +
                                F:1:2 + F:1:3 + F:1:4 + F:1:5 + F:1:6 + F:1:7</code>. Instead, I have introduced the BitCount function, denoted by "#".
                            Thus, odd parity of <code>F</code>
                            will be <code>#F%1</code>, even parity <code>1-#F%2</code>. It is
                            implemented by translating to the <a
                                href="http://download.oracle.com/javase/6/docs/api/java/lang/Long.html#bitCount%28long%29">Java Long.bitCount</a>-function.
                        </p>
                    </section>
                </section>

                <section>
                    <title>Binary operators</title>
                    <section>
                        <title>Shift operators</title>
                        <p>
                            Although not present in the specification,
                            IrpTransmogrifier implements the shift operators "&lt;&lt;" (left shift)
                            and "&gt;&gt;" ((arithmetic) right shift), with syntax and semantics as in the C programming language.
                            (See <a
                                href="http://www.hifi-remote.com/forums/viewtopic.php?t=11850">this
                                discussion</a>.)</p>
                    </section>
                    <section>
                        <title>Binary logical operators</title>
                        <p>
                            In the light of <a
                                href="http://www.hifi-remote.com/forums/viewtopic.php?t=13374&amp;start=17">current
                                discussion on the F12 protocol</a>,
                            the logical operators <code>&amp;&amp;, ||</code>, and <code>?:</code>, would be useful,
                            having
                            their <a href="https://en.wikipedia.org/wiki/Short-circuit_evaluation">short circuiting semantics</a>,
                            like in languages such as C and Perl.
                            Recall, the expression <code>A &amp;&amp; B</code> is evaluated as follows: First <code>A</code> is checked for being 0 or
                            not. If 0, then 0 (<code>false</code>) is returned, without even evaluating <code>B</code>. If
                            however, <code>A</code> is nonzero, <code>B</code> is evaluated, possibly to a
                            "funny" type and that is returned.</p>
                    </section>
                </section>
                <section>
                    <title>Ternary operator</title>
                    <section>
                        <title>Conditional operator ?:</title>
                        <p>Similarly, the ternary operator "A ? B : C", returning B if A is true (non-zero),
                            otherwise C, has been implemented, and turns out often to be useful.
                            As opposed to other operators (with the exception of exponentiation "**"), it is right associative.
                        </p>
                    </section>
                </section>
            </section>

            <section>
                <title>Preprocessing and inheritance</title>
                <p>
                    Reading through the protocols in DecodeIR.html, the
                    reader is struck by the observation that there are a few general
                    abstract "families", and many concrete protocol are "special cases".
                    For example all the variants of the NEC* protocols, the Kaseikyo-protocols,
                    or the rc6-families. Would it not be elegant, theoretically as well as
                    practically, to be able to express this, for example as a kind of
                    inheritance, or sub-classing?</p>
                <p>
                    For a problem like this, it is easily suggested to invoke a general
                    purpose macro preprocessor, like the <a
                        href="http://en.wikipedia.org/wiki/C_preprocessor">C preprocessor</a>
                    or <a href="http://en.wikipedia.org/wiki/M4_%28computer_language%29">m4</a>.
                    I have successfully resisted that temptation, and am instead offering
                    the following solution: If the IRP notation does not start with
                    "{" (as they all have to do to confirm with the specification), the
                    string up until the first "{" is taken as an "ancestor protocol", that
                    has hopefully been defined at some other place in the configuration
                    file. Its name is replaced by its IRP string, with a possible parameter
                    spec removed &#x2014; parameter specs are not sensible to inherit. The
                    process is then repeated up until, currently, 5 times. </p>
                <p>
                    The preprocessing takes place in the class IrpMaster, in its role as
                    data base manager for IRP protocols.</p>
                <section>
                    <title>Example</title>
                    <p>
                        This shows excepts from an example configuration file. Let
                        us define the "abstract" protocol <code>metanec</code> by</p>
                    <source>
                        [protocol]
                        name=metanec
                        irp={38.4k,564}&lt;1,-1|1,-3&gt;(16,-8,A:32,1,-78,(16,-4,1,-173)*)[A:0..4294967295]
                    </source>
                    <p>
                        having an unspecified 32 bit payload, to be subdivided by its "inherited
                        protocols". Now we can define, for example, the NEC1 protocol as</p>
                    <source>
                        [protocol]
                        name=NEC1
                        irp=metanec{A = D | 2**8*S | 2**16*F | 2**24*(~F:8)}[D:0..255,S:0..255=255-D,F:0..255]
                    </source>
                    <p>
                        As can be seen, this definition does nothing else than to stuff the
                        unstructured payload with D, S, and F, and to supply a corresponding
                        parameter spec. The IrpMaster class replaces "<code>metanec</code>"
                        by <code>{38.4k,564}&lt;1,-1|1,-3&gt;(16,-8,A:32,1,-78,(16,-4,1,-173)*)</code>"
                        (note that the parameter spec was stripped), resulting in an IRP string
                        corresponding to the familiar NEC1 protocol. Also, the "Apple protocol"
                        can now be formulated as
                    </p>
                    <source>
                        [protocol]
                        name=Apple
                        irp=metanec{A=D | 2**8*S | 2**16*C:1 | 2**17*F | 2**24*PairID} \
                        {C=1-(#F+#PairID)%2,S=135} \
                        [D:0..255=238,F:0..127,PairID:0..255]
                    </source>
                    <p>
                        The design is not cast in iron, and I am open to suggestions for
                        improvements. For example, it seems reasonable that protocols that only
                        differ in carrier frequency should be possible to express in a concise
                        manner. </p>
                </section>
            </section>
            <section>
                <title>The Configuration file/IRP protocol database</title>
                <p>
                    There is presently not a "official" IRP database. <a href="#MakeHex">MakeHex
                    </a>comes with a number of protocol files with the <code>.irp</code>-extension,
                    but that is another, obsolete and much less powerful format.
                    The <a
                        href="#DecodeIR.html">DecodeIR.html</a>-file presently comes closest:
                    it has a number (upper two-digit) of IRPs, however, often not even
                    syntactically confirming to the <a
                        href="#Specification_of_IRP_Notation">specification</a>, and often
                    with the description of the protocol at least partially in prose ("C
                    is the number of ..."), parseable only by humans, not by programs. </p>
                <p>
                    Possibly as an intermediate solution, I invented the
                    <code>IrpProtocols.ini</code> file. This file
                    has a format similar to ini-files under Windows. For every protocol, it
                    contains name and an IRP-string, possibly also a documentation string.
                    The latter can, in principle, contain HTML elements, i.e. it can be an
                    HTML fragment. </p>
            </section>
            <section>
                <title>Syntax and semantics of the <code>IrpProtocols.xml</code> file</title>
                <p>
                    Every protocol is described in a section starting with the key
                    <code>[protocol]</code>. Then there are a few keywords describing different
                    properties:</p>
                <ul>
                    <li>
                        <code>name</code> The name of the protocol. This is folded to lowercase
                        for searches  and  comparisons.  </li>
                    <li>
                        <code>irp</code> The IRP string representation. This may continue over
                        several lines if the line feeds are escaped by a backslash ("\"), i.e. having
                        the backspace as last character on the line.</li>
                </ul>
                <p>
                    Other keywords are allowed, but ignored. Then, optionally, there may be
                    a section <code>[documentation]</code>, that, in principle, could contain
                    e.g. an HTML-fragment. The documentation section continues until the next
                    <code>[protocol]</code> is encountered.</p>
            </section>
            <!--section>
                <title>Requirements for an IRP data base</title>
                <p>
                    I have created the present <code>IrpProtocols.ini</code> by hand editing the
                    DecodeIR.html-file.
                    I would welcome if the community can settle for one endorsed format for
                    such a data base. It can be one file, or many files: One file per
                    protocol is easier for the developer, in particular if several
                    developers are using a version management system (with or without file
                    locking), but less convenient for the user.</p>
                <p>
                    It would be highly desirable in the future to be able just to maintain
                    one file (or set of files). Some possibilities for this are:</p>
                <ol>
                    <li>Have one master file, for example in XML format, that after
                        preprocessing <em>generates</em> both DecodeIR.html, and a protocol description
                        file. There is also the possibility of having a program like IrpMaster parsing the master file directly.</li>
                    <li>Extend <code>protocol.ini</code>("belonging to RemoteMaster")
                        with the IRP information. Leaves the problem of duplicated
                        "documentation" between DecodeIR.html and protocols.ini.</li>
                    <li>Formalizing the IRP-Strings within <a
                            href="#DecodeIR.html">DecodeIR.html</a>, e.g. by using div or span elements
                        with class-attributes, (and formatting with, for example, better CSS style
                        sheets) so that the IRP information can be unambiguously read out.</li>
                </ol>
            </section-->
        </section>

        <section>
            <title>The API</title>
            <!--p>
                The Java programmer can access the functionality through a number of
                API functions. </p>
            <p>
                The class <code>IrpMaster</code> is the data base manager. The class
                is immutable, constructed from a file name (or an InputStream), and can
                deliver assorted pieces of information from the data base. Most
                interesting is the <code>newProtocol()</code>-function that generates
                a Protocol-object from parsing the IRP-string associated with the
                requested protocol name. It contains a very elaborate
                <code>main()</code>-function for command line use &mdash; strictly speaking
                this is "the program" that is described herein. Actually, that
                <code>main()</code>-function does not necessarily belong to the <code>IrpMaster</code> class, but could be located
                somewhere else.</p>
            <p>
                Instances of the Protocol class are constructed (essentially) from a
                String, containing the IRP representation to be parsed. Once
                constructed (and IRP-String parsed), the Protocol instances can render
                IrSignals and IrSequences for many different parameter values. This is
                done with the <code>render(...)</code> and <code>renderIrSignal(...)</code>
                functions, producing <code>IrSequences</code> and <code>IrSignals</code>
                respectively:</p>
            <p>
                An <code>IrSequence</code> is a sequence of pulse pairs. It does not know
                weather it is supposed to repeat or not. In contrast, an <code>IrSignal</code>
                has one introductory <code>IrSequence</code>, one repetition
                <code>IrSequence</code> (either, but not both, of these can be empty), and an
                (in most cases empty) ending <code>IrSequence</code>. </p-->
            <p>
                The API is documented in standard Javadoc style, which can be installed
                from the source package, just like any other Java package. For the
                convenience of the reader, the Javadoc API documentation is also
                available <a href="https://bengtmartensson.github.io/IrpTransmogrifier/">here</a>
                (development version only).</p>

 <!--a href="apidocs/index.html?org/harctoolbox/IrpMaster/package-summary.html">here</a></p-->
        </section>
      <!--section>
          <title>References</title>
          <ol>
              <li id="IrScrutinizer">
                  <a href="IrScrutinizer.html">IrScrutinizer.</a>
                  A program, also by myself, than, among other things, provides a user friendly GUI for IrpMaster.</li>
              <li id="IrMaster">
                  <a href="IrMaster.html">IrMaster.</a> A program, also
                  by myself, than, among other things, provides a user friendly GUI for IrpMaster.</li>
              <li id="Specification_of_IRP_Notation">
                  <a
                      href="http://www.hifi-remote.com/wiki/index.php?title=IRP_Notation">Specification of IRP Notation</a>, Graham Dixon. Also in <a
                      href="http://www.hifi-remote.com/forums/dload.php?action=file&amp;file_id=7926">PDF
                      version for download</a>. A very thorough specification.</li>
              <li>
                  <a
                      href="http://www.hifi-remote.com/forums/viewtopic.php?t=11850">Discussion
                      thread on the IRP documentation</a>
              </li>
              <li>
                  <a href="http://www.hifi-remote.com/wiki/index.php?title=DecodeIR">DecodeIR.html</a>. (The
                  link points to a slightly nicer formatted wiki page, though).
                  Contained within the <a
                      href="http://www.hifi-remote.com/forums/dload.php?action=file&amp;file_id=13104">current distribution of DecodeIR</a>.
                  <a href="https://sourceforge.net/p/controlremote/code/HEAD/tree/trunk/decodeir/">Subversion repository</a>.
              </li>
              <li id="MakeHex">Makehex. <a
                      href="http://www.hifi-remote.com/forums/dload.php?action=file&amp;file_id=8501">Source</a>, <a
                      href="http://www.hifi-remote.com/forums/dload.php?action=file&amp;file_id=5209">binary</a>. A
                  functional predecessor of the present program. Operates on a predecessor of the
                  current version of the IRP. Written in C++, also available as DLL (within the
                  first link). <a
                      href="https://sourceforge.net/p/controlremote/code/HEAD/tree/trunk/makehex/src/com/hifiremote/makehex/Makehex.java">Java
                      translation</a> by myself.</li>
          </ol>
      </section-->
    </body>
</document>
