<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="xdoc2html.xsl"?>
<!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V2.0//EN" "http://forrest.apache.org/dtd/document-v20.dtd">
<document xmlns:xi="http://www.w3.org/2001/XInclude">
    <header>
        <title>IrpTransmogrifier: Parser for IRP notation protocols, with rendering, code generation, and recognition applications.</title>
    </header>
    <body>
        <note>Possibly you should not read this document! If your are
            looking for a user friendly GUI program for generating, decoding, and analyzing IR signals etc,
            please try the GUI program <a href="IrScrutinizer.html">IrScrutinizer</a>, and get
            back here if (and only if) you want to know the details on IR signal
            generation and analysis.
        </note>
        <table>
            <caption>Revision history</caption>
            <tr>
                <th>Date</th>
                <th>Description</th>
            </tr>
            <tr>
                <td>2019-08-06</td>
                <td>Initial version, for IrpTransmogrifier Version 1.0.0.</td>
            </tr>
            <tr>
                <td>2019-08-11</td>
                <td>Minor tweaks for version 1.0.1.</td>
            </tr>
            <tr>
                <td>2019-12-27</td>
                <td>Update for version 1.2.4.</td>
            </tr>
            <tr>
                <td>2020-05-19</td>
                <td>Update for version 1.2.6.
                    More of an improvement and clarification than a description of new features.</td>
            </tr>
            <tr>
                <td>2020-06-27</td>
                <td>Update for version 1.2.7: IRP database maintenance.</td>
            </tr>
            <tr>
                <td>2021-06-03</td>
                <td>Update for version 1.2.10: Minor improvements.</td>
            </tr>
            <tr>
                <td>2022-05-07</td>
                <td>Update for version 1.2.11: Spelling fixes etc.</td>
            </tr>
            <tr>
                <td>2024-01-08</td>
                <td>Minor clarifications: Described predicates in prefer-overs and non-emptyness requirement for repeats.</td>
            </tr>
        </table>

        <section>
            <title>Release notes</title>
            <p>
                <a href="IrpTransmogrifier.releasenotes.txt">Release notes for the current version</a>
            </p>
        </section>
        <section>
            <title>Introduction</title>
            <!--p>IrTransmogrifier is a software that, with the use of a data base of IR protocols,
            can generate, decode, and analyze IR signals. It can be used as am interactive command line program,
            and through its API, be embedded in a larger GUI program, like <a href="IrScrutinizer.html">IrScrutinizer</a>.</p-->
            <p>The <em>IRP notation</em> is a domain specific language for describing IR
                protocols, i.e. ways of mapping a number of parameters to infrared
                signals. It is a very powerful, slightly cryptic, way of describing
                IR protocols, that was first developed by John Fine in 2003.
                In early 2010, Graham Dixon (mathdon in the <a
                    href="http://www.hifi-remote.com/forums">JP1-Forum</a>) wrote a <a
                    href="http://www.hifi-remote.com/wiki/index.php?title=IRP_Notation">specification</a>.
            </p>
            <p>This project contains a parser, a number of basic classes, and utilities for IRP protocols.
                It does not contain a graphical user interface (GUI). See <a
                    href="#Main+principles">Main principles</a> for a background. Instead, the
                accompanying program <a href="IrScrutinizer.html">IrScrutinizer</a> provides GUI access to most of the functionality described here.
            </p>

            <p>This is a new program, written from scratch, that is intended to replace <a href="Glossary.html#IrpMaster">IrpMaster</a>,
            <a href="Glossary.html#DecodeIR">DecodeIR</a>, and <a href="Glossary.html#ExchangeIr">ExchangeIR</a>,
                and much more, like potentially replacing hand written decoders/renders.
                The project consists of an API library that is also callable from the command line as a command line program.
            </p>

            <p>The name indicates that the program transforms ("transmogrifies") IRP form protocols to and from all sort of different things.</p>

            <p>For understanding this document and program, a basic understanding
                of IR protocol is assumed. However, the program
                can be successfully used just by understanding that an "IRP protocol"
                is a
                "program" in a particular domain specific language for turning a
                number of parameters into an IR signal, and the
                present program is a compiler/interpreter/decompiler of that language. Some parts
                of this document requires more IRP knowledge, however.
            </p>
            <section>
                <title>Background</title>
                <p>
                    This program can be considered as a successor of <a href="Glossary.html#IrpMaster">IrpMaster</a>.
                    The IRP parser therein is based upon a <a href="http://www.antlr.org">ANTLR</a>, using the now obsolete version 3.
                    The "new version"
                    ANTLR4 is really not a new version, but a completely different tool, fixing most of the quirks that were irritating
                    in IrpMaster (like the "ugliness" of embedding actions within the grammar and no left recursion).
                    Unfortunately, this means that using version 4 instead of version 3 is not like updating a compiler or such,
                    but necessitates a complete rewrite of the grammar and the actions.</p>

                <p>It turned out that IrScrutinizer version 1 (i.e. the version based upon IrpMaster for generating and
                    <a href="Glossary.html#DecodeIR">DecodeIR</a> for decoding)
                    had a fundamental problem: Although DecodeIR and IrpMaster (the latter through the data base <code>IrpProtocols.ini</code>)
                    agree on most (but not all) protocols, they relied upon two different, dis-coupled sources of protocol information.
                    If the data base for the sending protocols were changed or extended, this affected sending only,
                    while decoding was not changed, and potentially conflicted with the sending protocols.
                    Also, both DecodeIR and the IR Analyzer, used in IrScrutinizer versions before 1.3, have shown to be
                    essentially impossible to maintain and extend.
                </p>
            </section>
            <section>
                <title>Dependencies</title>
                <p>
                    The program is written entirely in Java, using no native libraries.
                    Therefore, it runs on anything for which Java (presently at least version 8) is available.
                    Except for building (using Maven and a number of its plugins), testing of the program (using TestNG),
                    and of course the Java framework,
                    it depends on <a href="https://www.antlr.org/">ANTLR4</a>,  <a href="https://www.stringtemplate.org/">StringTemplate</a>,
                    and the command line decoder <a href="http://jcommander.org/">JCommander</a>.
                </p>
                <p>
                    In order to avoid circular dependencies,
                    it is prohibited to use any other <a href="https://www.harctoolbox.org">Harctoolbox software</a>.
                </p>
            </section>

            <section>
                <title>Documentation principles</title>
                <p>The role of program documentation has changed considerably the last few decades.
                    Ideally, a program does not need any documentation at all, if its operation is entirely obvious.
                    Unfortunately, as non-trivial problems almost never have trivial solutions,
                    so some sort of documentation is almost always necessary for programs solving
                    complex programs.
                    The next best thing is that the program contains its own documentation,
                    for GUI programs through tool-tips, info-popups etc, for command line programs
                    through help texts. This can contain precise information over the syntax and semantic
                    of, for example, commands. Since they are integrated in the program and maintained
                    together with the program source, it is less likely that it lacks behind the actual program behavior,
                    than in the traditional program manual like this.
                    They may also change faster than reference manual.
                </p>
                <p>
                    Documentation for API, and structures like XML Schemas should preferably be integrated into the source itself,
                    using technologies like Javadoc, Doxygen, and, for XML documents, including Schemas etc,
                    be documented using the available documentation elements.
                </p>

                <p>
                    Separate program documentation, on paper or electronically (like the present document),
                    should then play another role
                    than in the last century. It should be centered around explaining the concepts
                    of the program, the "why", and not the "how". Some details that cannot in a natural way be explained
                    within the program with a few sentences can also be covered.
                </p>

                <p>
                    The present document is written in that spirit. We do not explain
                    all commands and parameters, at least not the ones that are (more-or-less) obvious.
                    Also, since the program changes more often than the manual,
                    it is written to be a "nice" document, not to exactly document a particular version of the program.
                </p>
                <p>
                    Since a text like this is unlikely to be read sequentially from start to finish,
                    redundancy and repetitions are not considered evil and a sign of stylistic inaptitude,
                    like in other type of documents.
                </p>
                <p>
                    All sort of suggestions for improving the documentation are always welcome.
                    Also, reports of useless or misleading error messages, as well as suggestion on improving them, are solicited.
                </p>

                <p>One or more tutorial Youtube videos are planned, explaining the program and its principles more informally.</p>
            </section>

            <section>
                <title>Acknowledgement</title>
                <p>
                    I would like to acknowledge the influence of the <a href="http://hifi-remote.com/forums/index.php">JP1 forum</a>, both the programs
                    (in particular of course <a href="http://www.hifi-remote.com/wiki/index.php?title=DecodeIR">DecodeIR</a>, and the discussions
                    (in particular with Dave Reed ("3FG") and Graham Dixon ("mathdon")). This work surely would not exist without the JP1 forum.
                </p>
            </section>

            <section>
                <title>Copyright and License</title>
                <p>
                    The program, as well as this document, is copyright by myself. Of
                    course, it is
                    based upon the <a href="http://www.hifi-remote.com/wiki/index.php?title=IRP_Notation">IRP
                        specification</a>, but is to be considered original work. The "database
                    file" <code>IrpProtocols.xml</code> is derived from many sources, in particular <a
                        href="http://www.hifi-remote.com/wiki/index.php/DecodeIR">DecodeIR.html</a> (which is public domain), so I do not claim copyright,
                        but place it in the public domain.</p>

                <p>The program uses some third-party project. It depends on <a
                        href="http://www.antlr.org/">ANTLR4</a> (<a href="https://github.com/antlr/antlr4/blob/master/LICENSE.txt">license</a>),
                    and  <a href="https://www.stringtemplate.org/">Stringtemplate</a>
                    (<a href="https://github.com/antlr/stringtemplate4/blob/master/LICENSE.txt">license</a>) by Terence Parr.
                    It also uses the command argumend decoder <a href="http://jcommander.org/">JCommander</a>
                    by Cédric Beust. This is free software released under the
                    <a href="https://github.com/cbeust/jcommander/blob/master/license.txt">Apache 2.0 license</a>.
                </p>

                <p>The program and its documentation are licensed under the <a
                        href="http://www.gnu.org/licenses/gpl.html">GNU General Public License version
                        3</a>, making everyone free to use, study, improve, etc., under certain
                    conditions.</p>

                    <p>Should the wish arise to use the program in a way not allowed by the GPL, please contact me for discussing a dual license agreement.</p>

                    <p>Data and code generated by the program can be used without any copyright restrictions.</p>
            </section>
        </section>

        <section>
            <title>Main principles</title>
            <section>
                <title>Design principles</title>
                <p>It is
                    easier and more logical to put a GUI on top of a sane API, then to try to
                    extract API functionality from a program that was never designed
                    for this but built around and into the GUI.
                    The goal of <em>this</em> project is an API and a command line program.
                </p>
                <section>
                    <title>Performance considerations</title>
                    <p>
                        Performance consideration, both time and space, were given secondary priorities.
                        Also, the decoding mechanism is intrinsically much slower that DecodeIR.
                        A single decode can take several hundred milli-seconds.
                        However, in normal interactive use from the command line or through IrScrutinizer, this does not introduced
                        any noticeable delays.
                    </p>
                </section>
                <section>
                    <title>IR signal formats</title>
                    <p>The current program reads raw format, and
                        <a href="Glossary.html#ProntoHex">Pronto Hex format</a> IR signals.
                        These formats can also be output. Although many more formats exist, it is not planned
                        to extend this. The "conversion expert" is IrScrutinizer
                        (which is even symbolized by its icon,
                        the Babel fish).</p>
                </section>
                <section>
                    <title>Data types</title>
                    <p>
                        Everything that is a physical quantity
                        (durations and frequency), are real numbers (in the Java code <code>double</code>),
                    </p>
                    <p>Durations are always given in micro seconds. Unless in a context where the
                        IRP says otherwise, all others quantities are given
                        in (pure) SI units without prefix. So are duty cycle and relative tolerance both a real
                        number between 0 and 1, not a number of percents. Modulation frequency is given in Hz, not it kHz
                        (with the exception of the <code>GeneralSpec</code>, since this is defined in the specification).
                    </p>
                    <p>Integer literals can be given in base 16 (using prefix "0x"), base 8 (using prefix "0"),
                        base 2 (using prefix "0b"), as well as in base 10 (no prefix, omitting leading zeros).</p>
                    <p>
                        Integer quantities are in principle arbitrarily large, but in most cases limited to 63 bits,
                        since the implementation uses Java's <code>long</code>, 64 bits long, amounting to 63 bits plus sign.
                        (Work is ongoing to remove this restriction, by, alternatively using Java's <code>BigInteger</code>.)
                    </p>
                </section>
                <section>
                    <title>Internationalization</title>
                    <p>
                        Being a command line program and API library, this project is not a
                        a candidate for internationalization.
                    </p>
                </section>
            </section>
        </section>

        <section>
            <title>Theory and general concepts</title>
            <section>
                <title>Main concepts</title>
                <section>
                    <title>IrSequence</title>
                    <p>
                        Sequence of time durations, in general expressed in microseconds,
                        together with a modulation frequency.
                        The even numbered entries normally denote times when the IR light is on (disregarding modulation),
                        called "flashes" or sometimes "marks",
                        the other denote off-periods, "gaps" or "spaces". They always start with a flash, and end with a gap.
                    </p>
                    <note>
                        In some communities (Lirc and Linux, IRremote),
                        the ending gap is not considered to be a part of the IrSequence/IrSignal.
                        This must be taken into consideration if importing signals from these communities.
                    </note>
                </section>

                <section>
                    <title>IrSignal</title>
                    <p>Consists of three <a href="#IrSequence">IR sequences</a>, called</p>
                    <ol>
                        <li>
                            <em>start sequence</em> (or "intro", or
                            "beginning sequence"), sent exactly once at the beginning of the transmission
                            of the IR signal,</li>
                        <li>
                            <em>repeat  sequence</em>, sent "while the
                            button is held down", i.e. zero or more times during the transmission
                            of the IR signal (although some protocols may require at least one copy to be transmitted),</li>
                        <li>
                            <em>ending sequence</em>, sent exactly once at
                            the end of the transmission of the IR signal, "when the button has been
                            released". Only present in a few protocols.</li>
                    </ol>
                    <p>
                        Any of these can be empty, but not both the intro and the repeat. A
                        non-empty ending sequence is only meaningful with a non-empty repeat.
                    </p>
                    <p>
                        By "sending an IrSignal <em>n</em> times" we shall mean sending an IrSequence consisting
                        of one copy of the intro sequence, <em>n</em> - 1 copies of the repeat sequence,
                        and one copy of the ending sequence, unless the intro sequence is empty, in which case
                        the IrSequence has <em>n</em> repeats, followed by the ending sequence.
                    </p>
                </section>

                <section id="NumEqDurations">
                    <title>Numerical equality between durations</title>
                    <p>Two durations <em>d1</em> and <em>d2</em> are considered numerically equal,
                        if <em>either</em> the difference is absolute less or equal than <code>absolute-tolerance</code>
                        <em>or</em> the difference divided by the largest is less than or equal than <code>relative-tolerance</code>.
                        (see <code>IrCoreUtils.approximatelyEquals</code>).
                    </p>
                </section>

                <section>
                    <title>Parsing of IR signals as text</title>
                    <p>We need a new simple text format for raw IR signals:</p>
                    <section id="BracketedRawFormat">
                        <title>Bracketed raw format</title>
                        <p>Simple text format for formatting of a raw IR signal, introduced
                            with the current program.
                            Intro-, repeat, and (optionally) ending sequences are enclosed by brackets ("[]", sometimes called "square brackets"
                            or "square parenthesis"). Signs ("+" for flashes, "-" for gaps), as well as interleaved commands or semicolons,
                            are accepted, but ignored (even if they are not interleaved). Optionally, the beginning sequence can be preceeded by
                            <code>Freq=</code><em>frequency_in_Hz</em><code>Hz</code>
                            giving the modulation frequency. If not explicitly given,
                            a default value (dependent on the reading program, but in general 38000Hz) is assumed.</p>
                                <p>Example (an RC5-signal):</p>
                                <source>Freq=36000Hz[][+889,-889,+1778,-889,+889,-889,+889,-889,+889,-889,+889,-889,+889,-889,+889,-889,+889,-889,+889,-889,+889,-889,+889,-889,+889,-90886][]</source>
                    </section>

                    <p>
                        Although we only consider the Pronto Hex and the raw form,
                        parsing of text representation is a non-trivial task.
                        IrpTransmogrifier presently contains three different parsers,
                        tried in order until one succeeds.
                        These are classes implementing the interface <code>IrSignalParser</code>,
                        namely:
                    </p>
                    <dl>
                        <dt>ProntoParser</dt>
                        <dd>Tries to interpret its argument as <a href="Glossary.html#ProntoHex">Pronto Hex</a>,
                            possibly after concatenating all lines of its argument.</dd>
                        <dt>BracketedIrSignalParser</dt>
                        <dd>Tries to parse an IrSignal in the <a href="#BracketedRawFormat">bracketed text format</a>,
                            as defined above.</dd>
                        <dt>MultilineIrSignalParser</dt>
                        <dd>
                            If the number of lines is 1, 2, or 3, these are considered intro-,
                            repeat-, and ending sequence respectively. If there are more lines, these
                            are concatenated, and considered an intro-sequence,
                            without repeat-, and ending sequence.
                        </dd>
                    </dl>
                    <p>
                        Programs can add other formats and their corresponding parsers using the API.
                        For an example, in IrScrutinizer, a parser for the <a href="Glossary.html#sendir">Global Caché sendir format</a> is added,
                        see <code>org.harctoolbox.irscrutinizer.Interpretstring.interpretString()</code>.
                    </p>
                </section>

                <section>
                    <title>Cleaner</title>
                    <p>
                        Physically measured IR signals/sequences are in general <a href="Glossary.html#DirtySignal">"dirty"</a>,
                        consisting of a number of close, but not quite equal, measured durations. To be useful for further processing,
                        the signal/sequence needs to be <a href="Glossary.html#CleansedSignal">cleaned</a>.
                        The naive way to implementing such a cleaning algorithm is to round off all durations to a multiple of an
                        (more ore less arbitrarily selected) time unit. The cleaner in IrpTransmogrifier takes a more sophisticatedly
                        approach:
                        The collected durations found in the sequence(s)
                        are bundled into "bins" (disjoint intervals), according to
                        <a href="#NumEqDurations">this closeness concept</a>.
                        Every duration belonging to a bin is "close" (determined by those parameters) to the bin
                        middle. All the durations within the bin are then replaced by the average of its
                        members. It is thus not guaranteed that the distance between a duration and its replacement
                        will be consistent with <code>absolute-tolerance</code> and <code>relative-tolerance</code>.
                    </p>
                    <p>
                        If invoked on a number of IR signals/sequences, the histogram is formed over all sequences, and the corresponding
                        "cleaning" then applied to the individual signals/sequences.
                    </p>
                    <p>
                        The cleaner is not a separate function in the command line program,
                        but can be invoked together with the <code>decode</code> and <code>analyze</code> commands.
                    </p>
                </section>

                <section>
                    <title>Repeat finder</title>
                    <p>
                        A repeat finder is a program that, when fed with an IrSequence,
                        tries to identify a repeating subsequence in it,
                        returning an IrSignal containing intro-, repeat-, and ending sequence,
                        compatible with the given input data.
                        IrpTransmogrifier can optionally run its data for the decode and analyze command
                        though its built-in repeat finder. The repeat finder is configurable using the following parameters:
                    </p>
                    <dl>
                        <dt>
                            <code>absolute.tolerance</code>
                        </dt>
                        <dd>See <a href="#NumEqDurations">Numerical equality between durations</a>. Current default: 100.0.</dd>

                        <dt>
                            <code>relative-tolerance</code>
                        </dt>
                        <dd>See <a href="#NumEqDurations">Numerical equality between durations</a>. Current default: 0.3.</dd>
                        <dt>
                            <code>minrepeatgap</code>
                        </dt>
                        <dd>To be recognized as a repeat sequence, the final gap must be at least this long. Default: 5000.0.</dd>
                    </dl>
                    <note>In some cases, the repeat finder is doing a "too good" job and
                        may squash a signal so that the decoder does not produce the expected result.
                        For example, a <code>JVC</code> signal is reduced beyond the <code>JVC</code> IRP.
                        (To handle this case, the relaxed protocol <code>JVC_squashed</code> was entered into the IRP data base.)
                    </note>

                </section>

                <section>
                    <title>The Configuration file/IRP protocol database</title>
                    <p>
                        The configuration file <code>IrpProtocols.ini</code> of IrpMaster has been replaced by an XML file,
                        called <code>IrpProtocols.xml</code>. The XML format
                        is defined by a <a href="Glossary.html#XMLSchema">W3C schema</a>, named
                        <a href="https://www.harctoolbox.org/schemas/irp-protocols.xsd">irp-protocols</a>,
                        having the XML name space <code>http://www.harctoolbox.org/irp-protocols</code>.
                        This format has many advantages over
                        the previous, simpler, format, as it gives access to different XML technologies,
                        for example for formatting and transforming.
                        It can contain embedded (X)HTLM fragments,
                        useful for for writing documentation fragments.
                        The file is to be thought of as a data base of protocols and their properties and parameters,
                        not as a configuration file for the present program.
                        It can contain different parameters that can be used by different programs, for example, tolerance parameters
                        for decoding.
                        For this, arbitrary string-valued parameters are permitted. It is up to an interpreting program to determine the semantic.
                        Within IrpTransmogrifier, this is used for providing protocol-specific values to the parameters.
                    </p>

                    <p>
                        If setting the attribute <code>type="xml"</code>, the element's content is considered an XML document fragment, i.e.,
                        arbitrary (well-formed) xml content can be present.
                    </p>

                    <p>
                        There is also an XSLT stylesheet <code>IrpProtocols2html.xsl</code>,
                        which translates this file to readable HTML, for reading in a HTML browser.
                        This makes it possible to browse the said file in an XSLT-enabled browser just by opening it.
                        Unfortunately, this very practical mechanism is since recently considered a security problem.
                        Firefox (and possibly other browsers) therefore unfortunately disables it for local files (URIs using <code>file:</code> scheme).)
                    </p>

                    <p>
                        More than one protocol data base file ("<code>IrpProtocols.xml</code>") can be deployed.
                        This gives a user or a program the possibility to strictly divide his/her/its own entries from the official ones.
                        A "small" file modifying and/or adding a few protocols is often called a "patch file",
                        although there is actually no difference between the first and subsequent files, and the semantics is identical.
                        All files are required to be valid XML, and should be valid with respect to the given XML schema.
                    </p>
                    <p>
                        From the command line, the option <code>--configfile</code> can be given several times,
                        or several files can be given as argument, separated by commas (",").
                        From the API, see the function <code>IrpDatabase.patch(File)</code> (and others).
                    </p>
                    <p>
                        The content of the patch file is basically merged into the data base,
                        amending the information already there, with the exception that an empty entry deletes the original one.
                        The exact rules are as follows:</p>
                        <ul>
                            <li>If a patch file contains an empty protocol element,
                                the protocol with the same name will be (if present) removed from the data base.
                                Otherwise, its content is amended into the present one.</li>
                            <li>For the protocol properties (both the XML properties and the normal ones) similar rules apply:
                                An empty property element removes that property from the protocol.
                                A non-empty property in a protocol in the patch file is added
                                to the end of the list that is the value of that property in the protocol
                                (unless it is already present).</li>
                            <li>However, the "properties" irp and documentation are different,
                                since there can only be one of those in a protocol.
                                For these, an entry in the patch file overwrites the original entry. </li>
                        </ul>

                        <p>Syntax and semantics of the file is believed to be essentially self explaing.
                            The exact syntax is given by <a href="https://www.harctoolbox.org/schemas/irp-protocols.xsd">the schema</a>,
                            and is therefore not repeated here.</p>

                        <p>Note that the program contains some functions for the
                        <a href="#IRP+database+maintenance">maintenance of the data base</a>.</p>
                    <section>
                        <title>Protocol parameters</title>
                        <p>Most protocol parameters are given as the <code>parameter</code> element. However, the protocol name, its IRP, and its
                        documentation are handled differently:</p>
                        <dl>
                            <dt>
                                <code>name</code>
                            </dt>
                            <dd>The name of the protocol. It is specified in the mandatory attribute <code>name</code> in the <code>protocol</code> element.
                            The name is folded to lowercase for searches  and  comparisons, which are therefore done case insensitively.</dd>

                            <dt>
                                <code>irp</code>
                            </dt>
                            <dd>The IRP form of the protocol, as text.</dd>

                            <dt><code>documentation</code></dt>
                            <dd>Also a separate, but optional, element. Any textual information can be put here.
                                Arbitrary (valid) (X)HTML code can be included here, for example formatting instructions, tables, or links.
                                A processing program may select to render the HTML content, pass it through, or just to ignore it.
                                (For example the current version of the command line program will, using the command option <code>list --documentation</code>
                                produce an "dumb" version, while <code>list --html</code> will give the original text, enclosed in a HTML
                                <code>div</code> element.
                            </dd>
                        </dl>

                        <p>The following parameters may be given for any protocol in the data base.
                            They override the global values for the current protocol.</p>
                        <dl>
                            <dt id="absolute-tolerance">
                                <code>absolute-tolerance</code>
                            </dt>
                            <dd>See <a href="#NumEqDurations">Numerical equality between durations</a>. Current default: 100.0.</dd>

                            <dt id="relative-tolerance">
                                <code>relative-tolerance</code>
                            </dt>
                            <dd>See <a href="#NumEqDurations">Numerical equality between durations</a>. Current default: 0.3.</dd>

                            <dt id="frequency-tolerance">
                                <code>frequency-tolerance</code>
                            </dt>
                            <dd>Tolerance in Hz for frequency comparisons. Set to -1 to disable frequency check. Current default: 2000.0.</dd>

                            <dt id="minimum-leadout">
                                <code>minimum-leadout</code>
                            </dt>
                            <dd>Minimal duration in micro seconds that is accepted as final duration. Current default: 20000.0.</dd>

                            <dt id="prefer-over">
                                <code>prefer-over</code>
                            </dt>
                            <dd>If a signal has multiple decodes,
                                the present protocol is preferred over the one mentioned as <code>prefer-over</code>.
                                May be given several times.
                                Alternatively, the content of the element may have two parts: a predicate and a protocol name,
                                separated by a semi colon ("<code>;</code>").
                                The predicate is evaluated for the current, to be preferred, protocol and its parameters.
                                Only if the predicate (which is an <code>expression</code> in the sense of IRP) evaluates to non-zero,
                                the preferance takes effect.
                                (See the protocol <code>Pioneer</code> for an example.)
                                (Normally, a special protol should be preferred over a more general one.)
                            </dd>

                            <dt id="alt_name">
                                <code>alt_name</code>
                            </dt>
                            <dd>Alternative name, ("alias", "synonym") for the present protocol.</dd>

                            <dt id="reject-repeatless">
                                <code>reject-repeatless</code>
                            </dt>
                            <dd>When decoding, normally the repeat sequence may match 0 times, i.e. not at all.
                                If this parameter is <code>true</code>  at least one repeat must be present for a match to be recognized.
                                (Strictly speaking, this would have been possible to achieve by using "+" instead of "*" for the repeat indicator,
                                but this would have other disadvantages.)
                            </dd>
                            <dt id="decodable">
                                <code>decodable</code>
                            </dt>
                            <dd>Setting this to <code>false</code> prohibits the program from trying to use this protocol for <a href="#Decoding">decoding</a>.
                                Normally, this is only used for portocols that are so involved that protocol decoding is impossible or not feasible.
                            </dd>
                            <dt id="decode-only">
                                <code>decode-only</code>
                            </dt>
                            <dd>Setting this to <code>true</code> makes the program refuse to render the protocol.
                                Should be used only for "protocols" that denote incomplete or otherwise flawed decodes ("relaxed" protocols),
                                for example with missing parts or non-matching checksums.
                            </dd>
                            <!--dt>minrepeatgap</dt>
                            <dd>Minumum gap at end of repetition. Default: 5000.0.</dd-->
                        </dl>
                        <p>
                            Other parameters are allowed, but ignored by IrpTransmogrifier. They may be used by another program.
                            Also, new parameters may be introduced in the future.
                        </p>
                        <p>
                            Some more commands and hints are given as comments in the file itself.
                        </p>

                    </section>
                </section>
            </section>
        </section>

        <section>
            <title>Use cases</title>
            <p>In this section, we will discuss the different use cases from a high-level, theoretical standpoint,
                without delving into the usage of the program.
                The subsequent section <a href="#Subcommands">Subcommands</a>,
                which to a certain degree mirrors the present, will cover the usage of the program.</p>
            <section>
                <title>Rendering</title>
                <p>
                    Given a protocol name, present in the protocol data base
                    (alternatively, an IRP protocol given explicitly with the <code>--irp</code> option),
                    and a set of valid parameter values,
                    an IrSignal is computed. This use case corresponds to IrpMaster (or <a href="Glossary.html#MakeHex">MakeHex</a>).
                </p>
                <p>
                    In earlier versions of IrScrutinizer, the word "generate" was used instead of "render". These words can be considered as synonyms.
                </p>
            </section>

            <section>
                <title>Decoding</title>
                <section>
                    <title>General</title>
                    <p>
                        This use case corresponds to DecodeIR: given a numerical IR signal/sequence,
                        find one (or more) parameter/protocol combination(s) that could have generated the given signal.
                        This is implemented by trying to parse the given signal with respect to a number of candidate protocols, per default all.
                        It is thus very robust, systematic, and customizable, but comparatively slow.
                    </p>

                    <p>While every conforming IRP form with only one repeat also can be usable for rendering,
                        the same is unfortunately not true for decoding. A few protocols cannot be used for decoding.
                        Non-recognizable protocols are marked by setting the <code>decodable</code> parameter to <code>false</code>.
                        To be useful for decoding, the IRP protocol should adhere to some additional rules:
                    </p>
                    <ul>
                        <li>Non-deterministic grammars (like, for example, "A? A*") must be avoided.</li>
                        <li>The "+" form of repetitions is discouraged in favor of the "*" form.</li>
                        <li>The width and shift of a Bitfield must be constant (i.e. not dependent on protocol parameter).</li>
                        <li>The decoder is capable of <em>simple</em> equation solving (e.g. <code>Arctech</code>),
                            but not of complicated equation solving (e.g. <code>Fujitsu_Aircon_old</code>).</li>
                    </ul>

                    <p>
                        Presently all but the protocols <code>zenith</code>, <code>nec1-shirrif</code>, (non-constant bitfield width);
                        <code>RTI_Relay_alt</code>, <code>fujitsu_aircon_old</code>
                        (would require non-trivial equation solving))
                        are decodable. (Note how the non-decodable protocols <code>RTI_Relay_alt</code> and <code>fujitsu_aircond_old</code>
                        was made decodable (<code>RTI_Relay</code> and <code>fujitsu_aircon</code>) by a changed parameterization.)
                    </p>
                </section>
                <section>
                    <title>Multiple decodes</title>
                    <p>In many cases, a signal produces more than one decode. This is not necessarily an error nor a deficiency of the decoder.
                        However, many protocols are effectively a special case of another protocol, for example,
                        an signal that decodes to the Apple protocol by mathematical necessity is also a valid  NEC1-f16 signal.
                        It thus makes sense for the decoder to have an Apple decode to "override" a NEC1-f16 decode.
                        This is specified by the <code>prefer-over</code> parameter.
                        With this mechanism, the preferences are under control of the configuration file,
                        not hard soldered into the program code as in DecodeIR.
                    </p>
                </section>

                <section>
                    <title>Loose matches, "Guessing"</title>
                    <p>
                        Many captured signals do not quite match the protocol they are supposed to match.
                        However, in order to give the user of a device maximal comfort,
                        the firmware in a receiving device is in general quite "forgiving",
                        and accepts slightly flawed signals. The degree of "forgiveness" should be balanced against the
                        possibility of "false positives": that the device erroneously considers "noise" of some form
                        (often commands for a different device) as one of its commands.
                        It is thus desirable for a program of this type to find a near match, "guess", when an proper match fails.
                    </p>

                    <p>Generally speaking, it is my principle to "make everything as simple as possible, <em>but not simpler</em>".
                        Sometimes a signal has several decodes, or none at all. Sometimes only a part of the data is used for the match.
                        In these cases, the program always prefer to tell the truth (and the full truth) to the user,
                        instead of, in the name of user friendlyness, to perform questionable simplifications.
                        Unfortunately, a badly informed user tend to prefer a program delivering exactly one answer to
                        every question over a program presenting the full truth.
                    </p>

                    <p>There are a few different issues:</p>

                    <section>
                        <title>Matching of durations, non-leadouts</title>
                        <p>Non-ending durations are matched according to
                            <a href="#NumEqDurations">the numeric equality criterion</a>,
                        using the parameters <code>absolutetolerance</code> and <code>relativetolerance</code>.</p>
                    </section>

                    <section>
                        <title>Matching of ending durations</title>
                        <p>The ending duration has a slightly different role.
                            When capturing, the ending duration is the time you have verified that nothing more is coming,
                            not a real measurement.
                            (Some "communities", like Lirc and IrRemote, do not consider an ending duration at all.)
                            For this reason, it does not make sense to check the ending duration the same way as the other,
                            non-ending durations. There is instead a parameter <code>minimum-leadout</code>
                            (possibly protocol dependent); the ending duration is considered as passed if it is longer or equal to
                            <code>minimum-leadout</code>.
                        </p>
                    </section>

                    <section>
                        <title>Matching of modulation frequency</title>
                        <p>There is a parameter <code>frequencytolerance</code>, which defaults to 2000. The frequency test is considered
                        passed if the absolute difference between measured and expected frequency is less or equal to
                        <code>frequencytolerance</code>. Setting <code>frequencytolerance</code> negative disables the
                        frequency test, i.e., all values pass the test.
                        </p>
                        <p>If an asymmetric interval is needed, instead the parameters
                            <code>frequency-lower</code> and <code>frequency-upper</code> can instead be used, specifying the
                            lowest and highest frequency that is to be accepted.</p>
                            <p>All of these parameters are to be given in Hz, not kHz.</p>
                    </section>
                    <p>
                        It turns out that decoding of IrSignals and IrSequences are two fairly different use cases:</p>
                    <section>
                        <title>Matching of IR Signals (Intro-, Repeat and Ending sequence)</title>
                        <p>
                            The task is to match an IR signal (with intro-, repeat- and ending sequence) to a protocol,
                            turn out, "practically", to be more involved than just matching the different sequence to each other.
                            The to-be-matched signal is often empirically measured, and its decomposition into sequences the result
                            of entering a measured signal into a <a href="#Repeat+finder">repeat finder</a>.
                            For a short measured sequence, the repeat part may not be identified as such.
                            For a decoding program to be considered practically usable, this problem, and related problems,
                            must be addressed and handled correctly.
                        </p>
                        <p>For "strict" matching of a given IR signal, the intro-, repeat-, and ending sequences are required to match their
                            theoretical counterparts (<a href="#NumEqDurations">within numerical tolerances</a>). If this fails, it may be sensible to convert the signal to an IrSequence
                            (normally by concatenating the intro, repeat and ending sequences), and try to decode as IrSequence, as described in the next section.</p>

                            <p>A strict decode result of an IrSignal is a number (ideally exactly one) of decodes,
                            each one containing a protocol and a set of corresponding parameters.
                                (Technically, the function <code>Decoder.decodeIrSignal(IrSignal)</code> returns a <code>Decoder.SimpleDecodeSet</code>,
                                being an <code>Iterable&lt;Decoder.Decode></code>).</p>
                    </section>

                    <section>
                        <title>Matching  of IR Sequences</title>
                        <p>
                            A completely faithful decoding an IR Sequence is theoretically a more complicated undertaking.
                            Starting at position 0, in general several decodes can start there &mdash; although of course "normally" only one.
                            Such a decode matches an intro sequence, zero or more repeat sequences, and the ending sequence.
                            It thus matches a certain number of durations, less than or equal to the duration of the input IrSequence.
                            In the case that the decode is shorter than the input signal, the process repeats with the IrSequence that is remaining,
                            leading to an exponential growth of decodes &mdash; at least in the general case.
                            (Technically, the function <code>Decoder.decode(ModulatedIrSequence)</code> returns a <code>Decoder.DecodeTree</code>,
                            which is an <code>Iterable&lt;Decoder.TrunkDecodeTree></code>,
                            where each <code>Decoder.TrunkDecodeTree</code> consists of one decode
                            (with a variable number of repeat-matches) ("trunk") followed by another <code>Decoder.DecodeTree</code>.)
                        </p>
                    </section>
                </section>
            </section>

            <section>
                <title>Code generation for rendering and/or decoding</title>
                <p>
                    The task is: For a particular protocol and a particular target (C, C++, Java, Python,...),
                    generate target code that can render or decode signals
                    with the selected protocol. As opposed to the previous use cases, efficency (memory, execution time) (for the generated code) is potentially
                    an issue.
                </p>
                <p>
                    Two mechanisms are available, XML and StringTemplate, described in the following two sections.
                </p>
                <section>
                    <title>Code generation with XML</title>
                    <p>The program generates basically an XML version of <code>IrpProtocols.xml</code>
                        (with the IRP protocol replaced by a much more "parsed" XML version).
                        It is the task of the user to supply am XML transformation, for example using XSLT,
                        that transfers the XML file to the expected target format.
                        The program does not come with an XSLT engine, so this has to be invoked independently on the XML export.
                        It is recommended to use XSLT version 2 for writing the transformation.
                    </p>
                    <p>
                        This is presently used for generating the <a href="IrScrutinizer.html#Lirc-N10691">Lirc export format</a>
                        (which is basically another XSLT transformation) of IrScrutinizer.
                    </p>
                </section>
                <section>
                    <title>Code generation using StringTemplate</title>
                    <p>
                        For code generation, the template engine <a href="http://www.stringtemplate.org/">StringTemplate</a>
                        can also be used. As opposed to the XML case, the program contains the transformation engine.
                    </p>
                    <p>
                    Target dependent code is not considered a part of this project,
                    but is found in a <a href="https://github.com/bengtmartensson/IrProtocolCodeGeneration">separate project</a>.
                </p>
                </section>
            </section>
<!--
            just invokes the template, without caring what it does; if it generates a renderer or decoder.
                </p>
                    The user is instead governs this by invoking the style sheets or templates (s)he want using the <code>- -target</code> (<code>-t</code>) option to the <code>code</code> sub subcommand.
                    (For this reason, there is no <code>- -renderer</code> or <code>- -decoder</code> option to the <code>code</code> sub command.)
                    It is also possible to pass
                    target-specific parameters to the code generators using the <code>- -parameter</code> (<code>-p</code>) argument.
                </p>

                    This should be able to generate protocol renders for e.g. the Arduino libraries IrRemote, and AGirs.
                    At least in the first version, not all protocols describable by IRPs need to be supported. Not implemented in the first phase: Protocols with hierarchical bitspecs
                    (rc6*, replay, arctech, entone), protocols with bitspec lenght as parameter (zenith, nec1-shirrif). Also default are not implemented, e.g. NEC1 has to be
                    called with 3 parameters.</p>


                <p>Targets:</p>
                <dl>
                    <dt>Lircd.conf(http://lirc.org/html/lircd.conf.html)</dt>
                    <dd>generation from IrScrutinizer. This is based on an XSLT-transformation (<code>lirc.xsd</code>) and generates
                        [an XSLT (version 1) file that can work with IrScrutinizer](https://github.com/bengtmartensson/harctoolboxbundle/blob/master/IrScrutinizer/src/main/config/exportformats.d/lirc.xml).
                        Handling of definitions as well as expressions as bitfields not implemented, as well as a few other things (search for "omitted" in the above file),
                        otherwise works. "90% complete", see [this issue](https://github.com/bengtmartensson/IrpTransmogrifier/issues/6).
                        To create: see (or execute) the shell script <code>tools/generate-lirc.sh</code>. In short, this generates the xml export, and then invokes
                        xslt transformations on that xml file.</dd>
                    <dt>Java</dt>
                    <dd>Essentially for testing. This is essentially working both for rendering and decoding, including a generated test rig
                        (see the [test project](https://github.com/bengtmartensson/JavaIrpProtocolTest)). Targets: <code>java-decoder java-decoder-test java-renderer java-renderer-test</code>.
                        Not quite finished, see [this issue](https://github.com/bengtmartensson/IrpTransmogrifier/issues/25).</dd>
                </dl>

                <p>Some possible future targets:</p>
                <ul>
                    <li>[Infrared4Arduino](https://github.com/bengtmartensson/Infrared4Arduino).</li>
                    <li>[IRremote](https://github.com/z3t0/Arduino-IRremote)</li>
                    <li>Linux kernel modules in [linux/drivers/media/rc](https://github.com/torvalds/linux/tree/master/drivers/media/rc) (decoding only).</li>
                </ul>
            </section-->

            <section>
                <title>General code analysis</title>
                <p>
                    This use case is not really connected to parsing IRP, but fits in the general framework.
                    This has been inspired by to the Analyzer and the RepeatFinder in
                    <a href="http://www.hifi-remote.com/forums/dload.php?action=file&amp;file_id=8460">Graham Dixon's ExchangeIR</a>.
                </p>
                <p>
                    Theoretically speaking, this is an <a href="https://en.wikipedia.org/wiki/Inverse_problem">Inverse problem</a>.
                    Given one or many IR signals/sequences, the problem is to find out what could have generated it, in the form of an IRP protocol.
                    This problem in general does not have a unique solution; instead the "simplest" one is selected out of the possible solutions.
                </p>

                <p>
                    In a way, this is a more abstracted version of the decoding problem.
                    There are around 10 different "template IRP" (for example, different forms of bi-phase and PWM modulation) that are tried.
                    For every of those templates, a quantity, "weight" is computed, quantifying (in a somewhat arbitrary manner)
                    how "complicated" the answer is. The template that produces the "simplest" answer, i.e. the one with the least weight, is selected.
                </p>
                <p>
                    The form of the final answer can be influenced by a number of different parameters, use the command
                    <code>irptransmogrifier analyze --help</code> to list them.
                </p>

            </section>

            <section>
                <title>IRP database maintenance</title>
                <p>
                    The command line program also contains some functions for maintenance of the IRP database, described next.</p>
                <section>
                    <title>Validation</title>
                    <p>An IRP database is required to be <a href="#The+Configuration+file%2FIRP+protocol+database">valid with respect to the a W3C schema</a>.
                        For this, the common option <code>--validate</code> makes the program's XML parser read all files in validating mode,
                        and stops if the input is not conforming.
                    </p>
                </section>

                <section>
                    <title>Output of parsed database</title>
                    <p>The parsed database (possibly after merging of several files) can be output using the <code>list --dump</code> command.
                        This option generate an XML file on the output. All other output is suppressed.
                        This output can be, possibly after minimal hand editing (update version?) used as new <code>IrpProtocols.xml</code>.
                    </p>
                    <p>The option <code>--xml</code> does the same as <code>--dump</code>, except that the XML comments in the original files are suppressed.</p>
                </section>

                <section>
                    <title>Other options</title>
                    <p>With the command <code>list --prefer-overs</code>, the protocol's <code>prefer-over</code>s are printed, transitively.
                    The option <code>--check-sorted</code> checks the correct (alphabetic) sorting of the commands (with respect to their names).
                    There are also a number of other options listing properties of the individual protocols,
                    for example <code>--classify, --display, --warning, --weight</code>.</p>
                    </section>
            </section>
        </section>

      <section>
            <title>Extensions to, and deviation from, IRP semantic and syntax</title>
            <p>This implementation of the IRP has a number of extensions, and a few deviations to the <a
                    href="http://www.hifi-remote.com/wiki/index.php?title=IRP_Notation">current
                    specification version 2</a>.
                These will be described in detail next.</p>
            <p>For the complete syntax, see
                <a href="#Appendix%3A+ANTLR4+Grammar">the ANTLR grammar</a>.
            </p>
            <section>
                <title>Data types</title>
                <p>While the original specification uses exclusively unsigned integers,
                    here numbers that are intrinsically "physical" (modulation frequency,
                    durations, duty cycle) are floating numbers, in the code <code>double</code>.
                </p>
                <p>Integer numbers are in general implemented with Java's <code>long</code>,
                effectively limiting the number of bits to 63. In the future,
                it is <a href="https://github.com/bengtmartensson/IrpTransmogrifier/issues/38">planned</a>
                to remove this restriction, using Java's
                <a href="https://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html">BigInteger</a>.</p>
            </section>
            <section>
                <title>Repetitions</title>
                <p>Possibly the major difficulty in turning the IRP Specification into
                    programming code was how to make sense of its
                    <a href="http://www.hifi-remote.com/wiki/index.php?title=IRP_Notation#Repeat_markers">repetition concept</a>.
                    Most formalisms on IR signals (for example the Pronto format) considers an IR
                    signal as an introduction sequence (corresponding to pressing a button
                    on a remote control once), followed by a repeating signal,
                    corresponding to holding down a repeating button. Any, but not both of
                    these may be empty. In a few relatively rare cases, there is also an
                    ending sequence, send after a repeating button has been released.
                    Probably 99% of all IR signals fit into the intro/repetition scheme,
                    allowing ending sequence in addition should leave very few practically
                    used IR signals left. In "abstract" IRP notation, these are of the form
                    A,(B)*,C with A, B, and C being (possibly empty) <code>bare irstream</code>s.
                    Not all three may be empty; if B is empty, then C must also be empty.
                </p>
                <p>
                    In contrast, the IRP notation reminds of they syntax and
                    semantics of regular expressions: There may be any numbers of (infinite) repeats, and they
                    can even be hierarchical (repetitions within repetitions). There does not appear to be a
                    consensus on how this extremely general notation should be
                    practically thought of as a generator of IR signals.</p>
                <p>
                    The predecessor program IrpMaster tried to be very smart here, by trying to
                    implement all aspects, with the exception of hierarchical repetitions (repetitions within repetitions).
                    This never turned out to be useful.
                    The present program takes a simpler approach, by simply prohibiting multiple (infinite) repetitions.
                </p>
            </section>
            <section>
                <title>Parameter Specifications</title>
                <p>
                    In the first, now obsolete, version 1 of the IRP notation the parameters
                    of a protocol had to be declared with the allowed max- and min-value. This is
                    not present in the current specification version. I
                    have re-introduced this, using the name <code>parameter_spec</code>. For example, the
                    well known NEC1 protocol, the Parameter Spec reads:
                    <code>[D:0..255,S:0..255=255-D,F:0..255]</code>. (D, S, and F have the
                    semantics of device, sub-device, and function or
                    command number.) This defines the three variables D, S, and F, having
                    the allowed domain the integers between 0 and 255 inclusive. D and F must be
                    given, however, S has a default value that is used if the user does not
                    supply a value. The software enforces that all values without default
                    values are supplied, and within the stated limits. If, and only
                    if, the parameter specs is incomplete, there may occur run-time errors
                    concerning not assigned values. It is the duty of the IRP author to
                    ensure that all variables that are referenced within the main
                    body of the IRP are defined either within the parameter specs, defined
                    with "definitions" (<a href="http://www.hifi-remote.com/wiki/index.php?title=IRP_Notation#Definitions">Chapter 10</a>
                    of the specification), or assigned in
                    assignments before usage, otherwise a run-time error will occur
                    (in the code, a <code>NameUnassignedException</code> will be thrown). </p>
                <p>
                    The preferred ordering of the parameters is: D, S (if present), F, T
                    (if present), then the rest in alphabetical order,</p>
                <p>
                    The formal syntax is as follows, where the semantic of the '@' will be
                    explained in a <a href="#Persistency+of+variables">following section</a>:</p>
                  <source>
parameter_specs:
    '[' parameter_spec (',' parameter_spec )* ']'
    | '['  ']'

parameter_spec:
      name     ':' number '..' number ('=' expression)?
    | name '@' ':' number '..' number  '=' expression
                  </source>
            </section>
            <section>
                <title>GeneralSpec</title>
                <p>
                    For the implementation, I allow the four parts
                    (three in the <a href="http://www.hifi-remote.com/wiki/index.php?title=IRP_Notation#The_GeneralSpec_section">original
                    specification</a>) to be given in any order, if at all, but I do not
                    disallow multiple occurrences &#x2014; it is quite hard to implement cleanly and
                    simply not worth it. (For example, ANTLR does not implement exclusions. The only
                    language/grammar I know with that property is SGML, which is probably
                    one of the reasons why it was considered so difficult (in comparison
                    to XML) to write a complete parser.)
                </p>
                <p>
                    The default frequency is 38kHz, not 0kHz as in the specification.
                    For the cases of modulation frequency not "really" known, but "sufficiently close" to 38kHz,
                    it is recommended to rely on the default, not to state "38k" explicitly,
                </p>
                <section>
                    <title>GeneralSpecs, duty cycle</title>
                    <p>
                        Without any very good use case, I allow a duty cycle in percent to be
                        given within the <code>GeneralSpec</code>, for example as <code>{37k,123,msb,33%}</code>.
                        It is currently not used for anything, but preserved through the processing and
                        can be retrieved using API-functions. If some, possibly future, hardware needs
                        it, it is there.</p>
                </section>
            </section>
            <section>
                <title>Persistency of variables</title>
                <p>
                    In the specification and in forum contributions,
                    all variables in a IRP description appear to be consider as intrinsically
                    persistent: They do not need explicit initialization, if they are not,
                    they are initialized to an undefined, random value. This may be a
                    reasonable model for a particular physical remote control, however,
                    from a scientific standpoint it is less attractive.
                    In the current work, there is a way of
                    denoting a variable, typically a toggle of some sort, as persistent by
                    appending an "@" to its name in the parameter specs. An initial value
                    (with syntax as default value in the parameter spec) is here mandatory.
                    For example, a toggle is typically declared as <code>[T@:0..1=0]
                    </code>in the parameter specs.
                    It is set to its
                    initial value the first time the protocol is used. Rendering
                    such a protocol typically
                    updates the value, as given in an assignment, a 0-1 toggle goes like
                    T=1-T). As opposed to variables that has not been declared as
                    persistent, it retains its value between the invocations.
                </p>
                <p>
                    An instance of the <code>Protocol</code> class keeps the corresponding protocols's persistence variables
                    values between invocations, unless explicitly changed by parameter assignments.
                    In the command line program, this makes no sense, however.
                </p>
            </section>
            <section>
                <title>Comments</title>
                <p>
                    Comments in the C syntax (starting with <code>/*</code> and ended by
                    <code>*/</code>) are allowed, and ignored.
                    Also, C++-style comments ("//", extending to (and including) the end of line) are accepted.
                    (In the specifications, embedded comments in the IRP are not present.)
                </p>
                <p>The function <code>list --irp</code> lists the IRP as given in the data base (preserving comments and whitespace),
                while <code>list --parsedirp</code> list the parsed version.
                The latter has comments and whitespace removed, and observes the <code>--radix</code> argument.
                </p>
            </section>
            <section>
                <title>Whitespace</title>
                <p>
                    All white space, including line breaks, are ignored when parsing.
                    (In the original spec, the IRP form had to be on one line.)
                </p>
                <p>The function <code>list --irp</code> lists the IRP as given in the data base (preserving comments and whitespace),
                    while <code>list --parsedirp</code> list the parsed version (with comments and whitespace removed).
                </p>
            </section>

            <section>
                <title>Extents</title>
                <p>The <a href="http://www.hifi-remote.com/wiki/index.php?title=IRP_Notation#Description_3">specification</a>
                writes ``<em>An extent has a scope which consists of a
                        consecutive range of items that immediately precede the extent in the order of
                        transmission in the signal. ... The precise scope of an extent has to be
                        defined in the context in which it is used.</em>'', and, to my best knowledge,
                    nothing more. I consider it as
                    specification hole.
                    I have effectively implemented this interpretation:
                    “An extent has a scope which consists of a consecutive range of all non-extent items
                    that immediately precede the extent in the order of transmission in the signal,
                    starting with the first element after the last preceding extent, or from the start if there is no preceding extent.”
                    Differently put: Every extent encountered resets the duration count.
                </p>
            </section>
            <section>
                <title>Multiple definitions allowed</title>
                <p>
                    It turned out that the <a
                        href="#Preprocessing+and+inheritance">preprocessing/inheritance
                        concept</a> necessitated allowing several
                        <a href="http://www.hifi-remote.com/wiki/index.php?title=IRP_Notation#Definitions">definition objects</a>. These are
                    simply evaluated in the order they are encountered, possibly
                    overwriting previous content. </p>
            </section>
            <section>
                <title>Names</title>
                <p>
                    The
                    <a href="http://www.hifi-remote.com/wiki/index.php?title=IRP_Notation#Formal_syntax_13">IRP documentation defines a name</a>
                    as starting with an uppercase letter,
                    followed by an arbitrary number of uppercase letters and digits.
                    I have, admittedly somewhat arbitrarily, extended it to the
                    C-name syntax: Letters (both upper and lower cases) and digits allowed,
                    starting with letter. Underscore "_" counts as letter. Case is
                    significant.</p>
            </section>
            <section>
                <title>Name spaces</title>
                <p>
                    There is a difference in between the IRP documentation and the
                    implementation of the Makehex program, in that the former has one name
                    space for both <em>assignments</em> and <em>definitions</em>, while the
                    latter has two different name spaces. IrpTransmogrifier (just as the precessor IrpMaster) has one name space, as
                    in the documentation. (This is implemented with the <code>NameEngine</code>
                    class.)</p>
            </section>
            <section>
                <title>Expressions</title>
                <p>
                    Several extensions to the <a href="http://www.hifi-remote.com/wiki/index.php?title=IRP_Notation#Expressions">expressions</a>
                    have been made. Note that, informally speaking,
                    an expression is an integer, that, in different contexts is differently interpreted: as integer value,
                    (potentially infinite) bit pattern (using 2-complement representation),
                    and logical (0 is <code>false</code>, everything else is <code>true</code>).
                </p>
                <p>For a summary of the complete syntax of <code>expression</code>, see
                <a href="#Appendix%3A+ANTLR4+Grammar">the grammar</a>.
                </p>
                <section>
                    <title>Terminology</title>
                    <p>
                        In this project, we use the terms <em>para_expression</em>
                        (denoting an <em>expression</em> enclosed within parentheses) and <em>expression</em>
                        instead of the specification's <em>expression</em> and <em>bare_expression</em>,
                        since it was felt that the latter was wieldy and incompatible with normal-day usage.
                    </p>
                </section>
                <section>
                    <title>Literals</title>
                    <p>
                        Numerical literals can be given not only on base 10 (as in the
                        <a href="http://www.hifi-remote.com/wiki/index.php?title=IRP_Notation#Formal_syntax_13">specification</a>), but also in bases
                        2 (with prefix <code>0b</code>), base 8 (prefix <code>0</code>), as well as base 16 (prefix <code>0x</code>).
                    </p>
                    <p>A few pre-defined literals are introduced for convenience and readability.
                        These are:</p>
                    <ul>
                        <li>
                            <code>UINT8_MAX</code> = 2^8 - 1 = 0xFF = 255,
                        </li>
                        <li>
                            <code>UINT16_MAX</code> = 2^16 - 1 = 0xFFFF = 65535,</li>
                        <li>
                            <code>UINT24_MAX</code> = 2^24 - 1 = 0xFFFFFF = 16777215,</li>
                        <li>
                            <code>UINT32_MAX</code> = 2^32 - 1 = 0xFFFFFFFF = 4294967295, and</li>
                        <li>
                            <code>UINT64_MAX</code> = 2^64 - 1 = 0xFFFFFFFFFFFFFFFF = 18446744073709551615.</li>
                    </ul>
                </section>
                <section>
                    <title>Unary operators</title>
                    <p>In addition to the specification's unary minus ("-"),
                        some additional unary operators have been implemented, described next.</p>
                    <section>
                        <title>Logical NOT, "!"</title>
                        <p>The exclamation point, logical not, acts like in C:
                            it turns everything that evaluates to 0 (zero, <code>false</code>) into 1 (<code>true</code>),
                        everything else to 0 (<code>false</code>).</p>
                    </section>
                    <section>
                        <title>Bit inversion, "~"</title>
                        <p>
                            This operator turns all 0 to 1 and all 1 to 0 in the binary representation.
                        </p>
                    </section>
                    <section>
                        <title>BitCount Function "#"</title>
                        <p>
                            IrpMaster introduced the BitCount function as a unitary operator, denoted by "#".
                            This is useful in many situations,
                            for example, odd parity of <code>F</code>
                            can be expressed as <code>#F%2</code>, even parity as <code>1-#F%2</code>. It is
                            implemented through the <a
                                href="http://download.oracle.com/javase/6/docs/api/java/lang/Long.html#bitCount%28long%29">Java Long.bitCount</a>-function.
                        </p>
                    </section>
                </section>

                <section>
                    <title>Binary operators</title>
                    <p>There are also some added binary operators, which will be described next.</p>
                    <p>The specification contains the <em>bitwise</em> operators "&amp;", "|", and "^", having the
                        syntax and semantics of C. In addition, the current implementation adds the following two <em>logical</em> operators.</p>
                    <section>
                        <title>Logical AND, "&amp;&amp;"</title>
                        <p>The logical operator &amp;&amp; (with short-circuiting as in C and Perl) works as follows:
                            To evaluate the expression <code>A &amp;&amp; B</code>, first <code>A</code> is checked for being 0 or
                            not. If 0, then A (which happens to be 0) (<code>false</code>) is returned, <em>without evaluating</em>
                            <code>B</code>. If
                            however, <code>A</code> is nonzero, <code>B</code> is evaluated, and the resulting value is returned.</p>
                    </section>
                    <section>
                        <title>Logical OR, "||"</title>
                        <p>The logical operator || (with short-circuiting as in C and Perl) works as follows:
                            To evaluate expression <code>A || B</code>, first <code>A</code> is checked for being 0 or
                            not. If non-zero, then A is returned, <em>without evaluating</em>
                            <code>B</code>. If
                            however, <code>A</code> is 0, <code>B</code> is evaluated, and the resulting value is returned.</p>
                    </section>
                    <section>
                        <title>Left shift "&lt;&lt;"</title>
                        <p>
                            The left shift operators "&lt;&lt;" is implemented,
                            with syntax and semantics as in the C and Java programming languages.
                            (See <a
                                href="http://www.hifi-remote.com/forums/viewtopic.php?t=11850">this
                                discussion</a>.)</p>
                    </section>
                    <section>
                        <title>Right shift "&gt;&gt;"</title>
                        <p>
                            The (arithmetic) right shift operator "&gt;&gt;" with syntax and semantics as "&gt;&gt;"
                            (<em>not</em> "&gt;&gt;&gt;", denoting logical shift) in the Java programming language.
                            (Differently put, it preserves the leading bit, not shifting in 0.)</p>
                    </section>
                    <section>
                        <title>Numerical comparison operators, "&lt;", "&lt;=",  "&gt;", "&gt;=", "==", "!="</title>
                        <p>
                            The comparison operators have been added. They have the same syntax and semantics as in C,
                            taking two numerical operators to 0 (false) or 1 (true).
                        </p>
                    </section>
                </section>
                <section>
                    <title>Ternary operator</title>
                    <section>
                        <title>Conditional operator ?:</title>
                        <p>Similarly, the ternary operator <code>A ? B : C</code>, returning B if A is true (non-zero),
                            otherwise C, has been implemented.
                            As opposed to other operators (with the exception of exponentiation "**"), it is right associative.
                        </p>
                    </section>
                </section>
            </section>

            <section>
                <title>Preprocessing and inheritance</title>
                <p>
                    Reading through the protocols, the
                    reader is struck by the observation that there are a few general
                    abstract "families", and many concrete protocol are "special cases".
                    For example all the variants of the NEC* protocols, the Kaseikyo-protocols,
                    or the rc6-families. Would it not be elegant, theoretically as well as
                    practically, to be able to express this, for example as a kind of
                    inheritance, or sub-classing?</p>
                <p>
                    For a problem like this, it is easily suggested to invoke a general
                    purpose macro preprocessor, like the <a
                        href="http://en.wikipedia.org/wiki/C_preprocessor">C preprocessor</a>
                    or <a href="http://en.wikipedia.org/wiki/M4_%28computer_language%29">m4</a>.
                    I have successfully resisted that temptation, and am instead offering
                    the following solution: If the IRP notation does not start with
                    "{" (as they all have to do to confirm with the specification), the
                    string up until the first "{" is taken as an "ancestor protocol", that
                    has hopefully been defined at some other place in the configuration
                    file. Its name is replaced by its IRP string, with a possible parameter
                    spec removed &#x2014; parameter specs are not sensible to inherit. The
                    process is then repeated up until, currently, 5 times. </p>
                <p>
                    The preprocessing takes place in the class <code>IrpDatabase</code>, in its role as
                    data base manager for IRP protocols.</p>
                <section>
                    <title>Example</title>
                    <p>
                        This shows excepts from an example configuration file. Let
                        us define the "abstract" protocol <code>metanec</code> by</p>
                    <source>
                        [protocol]
                        name=metanec
                        irp={38.4k,564}&lt;1,-1|1,-3&gt;(16,-8,A:32,1,-78,(16,-4,1,-173)*)[A:0..UINT32_MAX]
                    </source>
                    <p>
                        having an unspecified 32 bit payload, to be subdivided by its "inherited
                        protocols". Now we can define, for example, the NEC1 protocol as</p>
                    <source>
                        [protocol]
                        name=NEC1
                        irp=metanec{A = D | 2**8*S | 2**16*F | 2**24*(~F:8)}[D:0..255,S:0..255=255-D,F:0..255]
                    </source>
                    <p>
                        As can be seen, this definition does nothing else than to stuff the
                        unstructured payload with D, S, and F, and to supply a corresponding
                        parameter spec. The IrpMaster class replaces "<code>metanec</code>"
                        by <code>{38.4k,564}&lt;1,-1|1,-3&gt;(16,-8,A:32,1,-78,(16,-4,1,-173)*)</code>"
                        (note that the parameter spec was stripped), resulting in an IRP string
                        corresponding to the familiar NEC1 protocol. Also, the "Apple protocol"
                        can now be formulated as
                    </p>
                    <source>
                        [protocol]
                        name=Apple
                        irp=metanec{A=D | 2**8*S | 2**16*C:1 | 2**17*F | 2**24*PairID} \
                        {C=1-(#F+#PairID)%2,S=135} \
                        [D:0..255=238,F:0..127,PairID:0..255]
                    </source>
                    <p>
                        The design is not cast in iron, and I am open to suggestions for
                        improvements. For example, it seems reasonable that protocols that only
                        differ in carrier frequency should be possible to express in a concise
                        manner. </p>
                </section>
            </section>
        </section>

        <section>
            <title>Installation</title>
            <section>
                <title>Installation of binaries</title>
                <p>
                    The most convenient way to install the program is to <a href="IrScrutinizer.html#Installation">install IrScrutinizer</a>,
                    version 2.0.0 or later.
                    For the Windows and the generic binary distribution,
                    this will install a wrapper for IrpTransmogrifier too.
                    The AppImage will start IrpTransmogrifier instead of IrScrutinizer,
                    if called with the last component of the name equals to
                    <code>irptransmogrifier</code> (for example, through a link ending with that name).
                    (However, the MacOS installation presently does not support command line IrpTransmogrifier.)
                    <!--(However the st- and xslt-files, <!- - TODO Link - ->
                    are not included.)-->
                </p>
                <p>Also <a href="Glossary.html#RemoteMaster">RemoteMaster</a> comes with IrpTransmogrifier and a wrapper
                (<code>irptransmogrifier.sh</code> or <code>irptransmogrifier.bat</code>) to start it as command line program.</p>
                <p>
                    IrpTransmogrifier can of course be installed separately.
                    The latest released version can be found
                    <a href="https://github.com/bengtmartensson/IrpTransmogrifier/releases/latest">here</a>.
                    The program is basically just an executable jar-file.
                    There is no "installer". Instead,
                    unpack the binary distribution in a preferably empty directory. Start the program by invoking the wrapper
                    (<code>irptransmobrifier.bat</code> on Windows, <code>irptransmogrifier.sh</code> on Unix-like systems like Linux and MacOS.)
                    from the command line.
                    Modify and/or relocate the wrapper(s) if desired or necessary.
                    Do not double click the wrappers, since this program runs only from the command line.
                    (Do not use the wrapper <code>irptransmogrifier</code> in the top directory of the source tree:
                    it is intended only for development in the source tree; and is not intended for deployment.)
                </p>

                <p>The program runs can be installed in a read-only location.</p>
                <p>The Macintosh app for IrScrutinizer presently does not come with support for running IrpTransmogrifier as command line program.</p>
                <p>The program presently requires Java 8 JRE or later to run. Some distributions of IrScrutinizer
                    come with their own Java installations, that can run IrpTransmogrifier.</p>
            </section>

            <section>
                <title>Building from sources</title>
                <p>
                    On Github, the
                    <a href="https://github.com/bengtmartensson/IrpTransmogrifier/releases/latest">latest official source- and binary distribution</a>
                    is found. Also, the <a href="https://github.com/bengtmartensson/IrpTransmogrifier/releases/tag/ci-build">built development version</a> can be found.
                </p>

                <p>
                    The project uses <a href="https://maven.apache.org/">Maven</a> as its build system.
                    Any modern IDE should be able to open/import and build it as Maven project.
                    Of course, Maven can also be run from the command line, like</p>
                <source>
                    mvn install
                </source>
                <section>
                    <title>Third-party Java dependencies (jars)</title>
                    <p>
                        The program depends on <a href="https://www.antlr.org">ANTLR4</a>,
                        <a href="https://www.stringtemplate.org/">Stringtemplate</a>,
                        as well as the command line decoder <a href="http://jcommander.org/">JCommander</a>.
                        When using Maven for building, these are automatically downloaded and installed to a local repository.
                    </p>
                </section>
            </section>
        </section>

        <section>
            <title>Usage of the program from the command line</title>
            <p>
                Next it will be described how to invoke the program from the command line.
                The reader is assumed to possess an elementary command of the command line usage.
            </p>

            <p>
                The usage message from <code>irptransmogrifier help --short</code> gives an extremely brief summary:
            </p>
            <source><![CDATA[
Usage: IrpTransmogrifier [options] <command> [command_options]
Commands:
   analyze         Analyze signal: tries to find an IRP form with parameters
   bitfield        Evaluate bitfield given as argument.
   code            Generate code for the given target(s)
   decode          Decode IR signal given as argument
   expression      Evaluate expression given as argument.
   help            Describe the syntax of program and commands.
   lirc            Convert Lirc configuration files to IRP form.
   list            List protocols and their properties
   render          Render signal from parameters
   version         Report version

Use
    "IrpTransmogrifier help" for the full syntax,
    "IrpTransmogrifier help <command>" for a particular command.
    "IrpTransmogrifier <command> --describe" for a description,
    "IrpTransmogrifier help --common" for the common options.
    "IrpTransmogrifier help --logging" for the logging related options.

]]></source>
<p>
    Using from the command line, this is a program with sub commands. Before the sub command,
    common options can be given. After the command, command-specific options can be specified.
    Commands and option names can be abbreviated, as long as the abbreviation is unique.
    They are matched case sensitively, and can be abbreviated as long as the abbreviation is unambiguous.
</p>
<p>
    All options have a long form, starting with two dashes, like <code>--sort</code>.
    (In rare cases, there might be more than one long name.)
    They can be abbreviated as long as the abbreviation remains unique. Most options also
    have a short, one letter form, starting with a single dash (like <code>-s</code>).
    For brevity, this document will not mention the short form. This information, if required,
    can instead be easily found using the <code>help</code> command.
</p>
<p>Note that <code>help</code> and <code>version</code> are commands, not options, as in most other command line programs.
(For compatibility reasons, also the options form works.)</p>
<p>
    The commands are briefly described next. Since the program contains its own
    documentation facility, the description is not aimed at being complete, but more
    to to comment upon the general idea behind.
</p>
<section>
    <title>analyze</title>
    <p>The <code>analyze</code> command takes as input one or several sequences or signals,
and computes an IRP form that corresponds to the given input (within
the specified tolerances). The input can be given either as Pronto
Hex or in raw form, optionally with signs (ignored). Several raw
format input sequences can be given by enclosing the individual sequences
    in brackets ("[]"). However, if using the <code>--intro-repeat-ending</code> option,
the sequences are instead interpreted as intro-, repeat-, and (optionally)
        ending sequences of an IR signal. </p>

<p>
For raw sequences, an explicit modulation frequency can be given with
    the <code>--frequency</code> option. Otherwise the default frequency, 38000Hz,
will be assumed.
</p>

<p>
    Using the option <code>--input</code>, instead the content of a file can be taken
as input, containing sequences to be analyzed, one per line, blank
    lines ignored. Using the option <code>--namedinput</code>, the sequences may have
names, immediately preceeding the signal. </p>

<p>
    Input sequences can be pre-processed using the options <code>--chop</code>, <code>--clean</code>,
    and <code>--repeatfinder</code>. </p>

<p>
The input sequence(s) are matched using different "decoders". Normally
    the "best" decoder match is output. With the <code>--all</code> option, all decoder
    matches are output. Using the <code>--decode</code> option, the used decoders
can be further limited. The presently available decoders are: <code>TrivialDecoder,
Pwm2Decoder, Pwm4Decoder, Pwm4AltDecoder, XmpDecoder, BiphaseDecoder,
BiphaseInvertDecoder, BiphaseWithStartbitDecoder, BiphaseWithStartbitInvertDecoder,
BiphaseWithDoubleToggleDecoder, SerialDecoder</code>.</p>

<p>
    The options <code>--statistics</code> and <code>--dump-repeatfinder</code> (the latter forces
the repeatfinder to be invoked) can be used to print extra information.
    The common options <code>--absolutetolerance, --relativetolerance, --minrepeatgap</code>
determine how the repeat finder breaks the input data. The options
<code>--extent, --invert, --lsb, --maxmicroseconds, --maxparameterwidth,
    --maxroundingerror, --maxunits, --parameterwidths, --radix</code>, and <code>--timebase</code>
determine how the computed IRP is displayed.
</p>
<p>Using the <code>--girr</code> option, a <a href="Girr.html">Girr</a> file can be produced.
This <a href="Girr.html#Embedded+protocols">embeds the generated IRP protocol</a> in the file.</p>

                </section>
<!--
            just invokes the template, without caring what it does; if it generates a renderer or decoder.
                </p>
                    The user is instead governs this by invoking the style sheets or templates (s)he want using the <code>- -target</code> (<code>-t</code>) option to the <code>code</code> sub subcommand.
                    (For this reason, there is no <code>- -renderer</code> or <code>- -decoder</code> option to the <code>code</code> sub command.)
                    It is also possible to pass
                    target-specific parameters to the code generators using the <code>- -parameter</code> (<code>-p</code>) argument.
                </p>

                    This should be able to generate protocol renders for e.g. the Arduino libraries IrRemote, and AGirs.
                    At least in the first version, not all protocols describable by IRPs need to be supported. Not implemented in the first phase: Protocols with hierarchical bitspecs
                    (rc6*, replay, arctech, entone), protocols with bitspec lenght as parameter (zenith, nec1-shirrif). Also default are not implemented, e.g. NEC1 has to be
                    called with 3 parameters.</p>


                <p>Targets:</p>
                <dl>
                    <dt>Lircd.conf(http://lirc.org/html/lircd.conf.html)</dt>
                    <dd>generation from IrScrutinizer. This is based on an XSLT-transformation (<code>lirc.xsd</code>) and generates
                        [an XSLT (version 1) file that can work with IrScrutinizer](https://github.com/bengtmartensson/harctoolboxbundle/blob/master/IrScrutinizer/src/main/config/exportformats.d/lirc.xml).
                        Handling of definitions as well as expressions as bitfields not implemented, as well as a few other things (search for "omitted" in the above file),
                        otherwise works. "90% complete", see [this issue](https://github.com/bengtmartensson/IrpTransmogrifier/issues/6).
                        To create: see (or execute) the shell script <code>tools/generate-lirc.sh</code>. In short, this generates the xml export, and then invokes
                        xslt transformations on that xml file.</dd>
                    <dt>Java</dt>
                    <dd>Essentially for testing. This is essentially working both for rendering and decoding, including a generated test rig
                        (see the [test project](https://github.com/bengtmartensson/JavaIrpProtocolTest)). Targets: <code>java-decoder java-decoder-test java-renderer java-renderer-test</code>.
                        Not quite finished, see [this issue](https://github.com/bengtmartensson/IrpTransmogrifier/issues/25).</dd>
                </dl>

                <p>Some possible future targets:</p>
                <ul>
                    <li>[Infrared4Arduino](https://github.com/bengtmartensson/Infrared4Arduino).</li>
                    <li>[IRremote](https://github.com/z3t0/Arduino-IRremote)</li>
                    <li>Linux kernel modules in [linux/drivers/media/rc](https://github.com/torvalds/linux/tree/master/drivers/media/rc) (decoding only).</li>
                </ul>
            </section-->
            <section>
                <title>
                    <code>bitfield</code>
                </title>
                <p>
                    The <code>bitfield</code> command computes the value and the binary form corresponding
                    to the bitfield given as input. Using the <code>--nameengine</code> argument,
                    the bitfield can also refer to names.
                </p>
                <p>
                    As an alternatively, the <code>expression</code> command sometimes may be used. However, a bitfield has a length,
                    which an expression, evaluating to an integer value, does not.
                </p>
            </section>

            <section>
                <title>
                    <code>code</code>
                </title>
                <p>
                    Used for generating code for different targets.
                </p>
            </section>

            <section>
                <title>
                    <code>decode</code>
                </title>
                <p>
                    The <code>decode</code> command takes as input one or several sequences or signals,
                    and output one or many protocol/parameter combinations that corresponds
                    to the given input (within the specified tolerances). The input can
                    be given either as Pronto Hex or in raw form, optionally with signs
                    (ignored). Several raw format input sequences can be given by enclosing
                    the individual sequences in brackets ("[]").</p>

                <p>
                    For raw sequences, an explicit modulation frequency can be given with
                    the <code>--frequency</code> option. Otherwise the default frequency, 38000Hz,
                    will be assumed.</p>

                <p>
                    Using the option <code>--input</code>, instead the content of a file can be taken
                    as input, containing sequences to be analyzed, one per line, blank
                    lines ignored. Using the option <code>--namedinput</code>, the sequences may have
                    names, immediately preceeding the signal.</p>

                <p>
                    In the Harctoolbox world, IR sequences start with a flash (mark) and ends with a
                    non-zero gap (space). In some other "worlds", the last gap is omitted. These signal
                    are in general rejected. The option <code>--trailinggap duration</code> adds a dummy duration
                    to the end of each IR sequence lacking a final gap.</p>

                <p>
                    Input sequences can be pre-processed using the options <code>--clean</code>, and
                    <code>--repeatfinder</code>.</p>

                <p>
                    The common options <code>--absolutetolerance</code>, <code>--relativetolerance</code>, <code>--minrepeatgap</code>
                    determine how the repeat finder breaks the input data.</p>
                    <section>
                        <title>Debugging</title>
                <p>
                    To debug why a certain signal/sequence does not decode the way expected,
                    the <a href="#Debugging%2Flogging+possibilities">logging facility</a> and the <code>--protocol</code>
                    argument (to reduce the logging output) can be useful to pinpoint the decoding process.
                </p>
                    </section>

            </section>
            <section>
                <title>demodulate</title>
                <p>
                    This command demodulates its argument IrSequence, emulating the use
                    of a demodulating IR receiver. This means that all gaps less than
                    or equal to the threshold are squeezed into the preceeding flash.
                    Typically the threshold is taken around the period of the expected
                    modulation frequency.
                </p>
            </section>
            <section>
                <title>
                    <code>help</code>
                </title>
                <p>This command list the syntax for the command(s) given as argument,
                    default all. Also see the option <code>--describe</code> of the individual commands.</p>

            </section>
            <section>
                <title>
                    <code>lirc</code>
                </title>
                <p>
                    This command reads a Lirc configuration, from a file, directory, or
                    an URL, and computes a corresponding IRP form. No attempt is made
                    to clean up, for example by rounding times or finding a largest common
                    divider.
                </p>
            </section>
            <section>
                <title>
                    <code>list</code>
                </title>
                <p>
                    This command list miscellaneous properties of the protocol(s) given
                    as arguments.
                There are a large number of options for enabling or suppressing certain kind of output;
                    use the command <code>irptransmogrifier list --help</code> for a list.</p>
            </section>
            <section>
                <title>
                    <code>render</code>
                </title>
                <p>
                    This command is used to compute an IR signal from one or more protocols,
                    "render" it. The protocol can be given either by name(s) (or regular
                    expression if using the <code>--regexp</code> option), or, using the <code>--irp</code> options,
                    given explicitly as an IRP form. The parameters can be either given
                    directly with the <code>--nameengine</code> option,
                    or the <code>--random</code> option can be used to
                    generate random, but valid parameters.
                    (This is essentially a developer's and tester's option.)
                    With the <code>--count</code> or <code>--number-repeats</code>
                    option, instead an IR sequence is computed, containing the desired
                    number of repeats.
                </p>
                <p>
                    The syntax of the name engine is as in the IRP specification, for example: <code>--nameengine {D=12,F=34}</code>.
                    For convenience, the braces may be left out. Spaces around the equal sign "=" and
                    around the comma "," are allowed, as long as the name engine is still only one argument in the sense of the shell
                        &mdash; it may need to be enclosed within single or double quotes.
                </p>
            </section>

            <section>
                <title>
                    <code>version</code>
                </title>
                <p>
                    Reports version number and license.
                </p>
            </section>
        </section>

        <section>
            <title>Debugging/logging possibilities</title>
            <p>
                The project contains quite powerful logging facilities, based on Java's <code>java.util.logging</code> framework.
                "Logging" is somewhat of a mis-normer for a program that runs only seconds, instead it is a form of debugging.
                Logging takes place according to the different levels: from highest to lowest <code>OFF, SEVERE, WARNING, INFO, CONFIG, FINE, FINER, FINEST, ALL</code>.
                Default level is <code>WARNING</code>.</p>
            <p>The reader is assumed to know the basic principles for logging.
                Ideally, setting a lower and lower level should reveal more and more details on the inner workings of the program.
                Unfortunately, this is (at least presently) not always the case.
                Still, it may be useful for finding out why a particular signal did not decode as expected.</p>

            <p>There are command line options, not only for setting the general log level,
                but also for changing the logging format, the logging file, for generating the log in XML format,
                and for setting the log level individually for different classes.
                See <code>help --logging</code> for the full list of these options.</p>
        </section>

        <section>
            <title>The API</title>
            <p>
                A Java programmer can access the functionality through a number of
                API functions.
            </p>
            <p>
                The API is documented in standard Javadoc style, which can be installed
                from the source package, just like any other Java package. For the
                convenience of the user, the Javadoc API documentation is also
                available <a href="https://bengtmartensson.github.io/IrpTransmogrifier/">here</a>
                current, released version only).</p>

                <p>The released versions of project is available in the Maven central repository, and can easily be integrated
                    into other Maven projects. For this, include the lines</p>
                    <source><![CDATA[
        <dependency>
            <groupId>org.harctoolbox</groupId>
            <artifactId>IrpTransmogrifier</artifactId>
            <version>1.2.10</version>  <!-- or another supported version -->
        </dependency>
]]></source><p> in the <code>pom.xml</code> of the importing project.</p>
            <!--a href="apidocs/index.html?org/harctoolbox/IrpMaster/package-summary.html">here</a></p-->
        </section>
        <!--section>
            <title>References</title>
            <ol>
                <li id="IrScrutinizer">
                    <a href="IrScrutinizer.html">IrScrutinizer.</a>
                    A program, also by myself, than, among other things, provides a user friendly GUI for IrpMaster.</li>
                <li id="IrMaster">
                    <a href="IrMaster.html">IrMaster.</a> A program, also
                    by myself, than, among other things, provides a user friendly GUI for IrpMaster.</li>
                <li id="Specification_of_IRP_Notation">
                    <a
                        href="http://www.hifi-remote.com/wiki/index.php?title=IRP_Notation">Specification of IRP Notation</a>, Graham Dixon. Also in <a
                        href="http://www.hifi-remote.com/forums/dload.php?action=file&amp;file_id=7926">PDF
                        version for download</a>. A very thorough specification.</li>
                <li>
                    <a
                        href="http://www.hifi-remote.com/forums/viewtopic.php?t=11850">Discussion
                        thread on the IRP documentation</a>
                </li>
                <li>
                    <a href="http://www.hifi-remote.com/wiki/index.php?title=DecodeIR">DecodeIR.html</a>. (The
                    link points to a slightly nicer formatted wiki page, though).
                    Contained within the <a
                        href="http://www.hifi-remote.com/forums/dload.php?action=file&amp;file_id=13104">current distribution of DecodeIR</a>.
                    <a href="https://sourceforge.net/p/controlremote/code/HEAD/tree/trunk/decodeir/">Subversion repository</a>.
                </li>
                <li id="MakeHex">Makehex. <a
                        href="http://www.hifi-remote.com/forums/dload.php?action=file&amp;file_id=8501">Source</a>, <a
                        href="http://www.hifi-remote.com/forums/dload.php?action=file&amp;file_id=5209">binary</a>. A
                    functional predecessor of the present program. Operates on a predecessor of the
                    current version of the IRP. Written in C++, also available as DLL (within the
                    first link). <a
                        href="https://sourceforge.net/p/controlremote/code/HEAD/tree/trunk/makehex/src/com/hifiremote/makehex/Makehex.java">Java
                        translation</a> by myself.</li>
            </ol>
        </section-->
        <section>
            <title>Appendix: ANTLR4 Grammar</title>
            <p>
                This appendix shows the grammar file for IRP. It is used to generate the Java code for the IRP parser.
                It is also (in contrast to the ANTLR3 grammar used in IrpMaster) quite readable for humans.
            </p>
            <source>
<xi:include href="../../../../IrpTransmogrifier/src/main/antlr4/org/harctoolbox/irp/Irp.g4" parse="text"/>
            </source>
        </section>
    </body>
</document>
