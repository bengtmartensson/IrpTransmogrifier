<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!-- Copying and distribution of this file, with or without modification,
     are permitted in any medium without royalty provided the copyright
     notice and this notice are preserved.  This file is offered as-is,
     without any warranty.
-->

<!-- Author: Bengt Martensson -->

<xsl:stylesheet
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:java="http://xml.apache.org/xalan/java"
    xmlns:math="http://exslt.org/math"
    extension-element-prefixes="math"
    version="2.0">
    <xsl:output method="text" />

    <xsl:param name="frequencyType" select="'frequency_t'"/>
    <xsl:param name="microsecondsType" select="'unsigned int'"/>
    <xsl:param name="parameterType" select="'unsigned int'"/>
    <xsl:param name="returnType" select="'void'"/>

    <!--xsl:variable name="protocolName" select="/abstract-code/protocol/@name"/>
    <xsl:variable name="timeUnit" select="number(/abstract-code/protocol/@timeUnit)"/>
    <xsl:variable name="frequency" select="number(/abstract-code/protocol/@frequency)"/>
    <xsl:variable name="bitdirection" select="/abstract-code/protocol/@bitDirection"/-->

    <!-- default template for elements is to just ignore -->
    <xsl:template match="*"/>

    <xsl:template match="/">
        <xsl:text>// Automatically generated by IrpTransmogrifier
// This code is intened to be put through a code beautifier, like indent.

#include "IRremote.h"

</xsl:text>

        <xsl:apply-templates select="NamedProtocols/NamedProtocol"/>
    </xsl:template>

    <xsl:template match="NamedProtocol">
        <xsl:text>
#if SEND_</xsl:text>
        <xsl:value-of select="upper-case(@name)"/>
        <xsl:text xml:space="preserve">&#10;</xsl:text>
        <xsl:apply-templates select="Protocol" mode="send"/>
    <xsl:text>
#endif // SEND_</xsl:text>
        <xsl:value-of select="upper-case(@name)"/>
        <xsl:text>

#if DECODE_</xsl:text>
        <xsl:value-of select="upper-case(@name)"/>
        <xsl:text>

</xsl:text>
    <xsl:apply-templates select="protocol"/>
    <xsl:text>
#endif // DECODE_</xsl:text>
        <xsl:value-of select="upper-case(@name)"/>
        <xsl:text>
</xsl:text>
    </xsl:template>

    <xsl:template match="Protocol[@standardPwm='true']" mode="send">
        <xsl:value-of select="$returnType"/>
        <xsl:text> IRsend::send</xsl:text>
        <xsl:value-of select="upper-case(@name)"/>
        <xsl:apply-templates select="ParameterSpecs" mode="prototypeWithoutDefaults"/>
        <xsl:text>&#10;{&#10;</xsl:text>
        <xsl:apply-templates select="GeneralSpec/@frequency" mode="enableIROut"/>
        <xsl:apply-templates select="BitspecIrstream" mode="send"/>
        <xsl:text>&#10;}</xsl:text>
    </xsl:template>

    <xsl:template match="BitspecIrstream" mode="send">
        <xsl:apply-templates select="Intro[*]" mode="send"/>
        <xsl:if test="not(Intro[*])">
            <xsl:apply-templates select="Repeat" mode="send"/>
        </xsl:if>
    </xsl:template>

    <xsl:template match="Intro|Repeat" mode="send">
        <xsl:apply-templates select="*"/>
    </xsl:template>



    <xsl:template match="@frequency" mode="enableIROut">
        <xsl:text>    enableIROut(</xsl:text>
        <xsl:value-of select="round(. div 1000)"/>
        <xsl:text>);&#10;</xsl:text>
    </xsl:template>

    <xsl:template match="ParameterSpecs" mode="prototypeWithoutDefaults">
        <xsl:text>(</xsl:text>
        <xsl:apply-templates select="*" mode="prototypeWithoutDefaults"/>
        <xsl:text>)</xsl:text>
    </xsl:template>

    <xsl:template match="ParameterSpec" mode="prototypeWithoutDefaults">
        <xsl:value-of select="$parameterType"/>
        <xsl:text> </xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:if test="position() != last()">
            <xsl:text>, </xsl:text>
        </xsl:if>
    </xsl:template>


    <xsl:template match="Protocol">
        <xsl:apply-templates select="function[@name='intro']"/>
    </xsl:template>

    <xsl:template match="function[@name='intro']">
        <xsl:value-of select="$returnType"/>
        <xsl:text> IRsend::send</xsl:text>
        <xsl:value-of select="../@name"/>
        <xsl:apply-templates select="parameters"/>
        <xsl:apply-templates select="body"/>
    </xsl:template>

    <xsl:template match="body">
        <xsl:text>{
        </xsl:text>
        <xsl:text>enableIROut(</xsl:text>
        <xsl:value-of select="floor(number(@frequency) div number(1000))"/>
        <xsl:text>);
        </xsl:text>
        <xsl:apply-templates select="*"/>
        <xsl:text>}
        </xsl:text>

    </xsl:template>

    <xsl:template match="parameters">
        <xsl:text>(</xsl:text>
        <xsl:apply-templates select="parameter"/>
        <xsl:text>)</xsl:text>
    </xsl:template>

    <xsl:template match="parameter">
        <xsl:value-of select="$parameterType"/>
        <xsl:text> </xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:if test="not(position()=last())">
            <xsl:text>, </xsl:text>
        </xsl:if>
    </xsl:template>

    <xsl:template match="implementation" mode="render">
        <xsl:text>
</xsl:text>
        <xsl:apply-templates select="(.//extent)[1]" mode="declare_funcs"/>
        <xsl:apply-templates select="bitspec_irstream/bitspec" mode="declare_funcs"/>
        <xsl:text>void IRsend::send</xsl:text>
        <xsl:value-of select="@protocolName"/>
        <xsl:apply-templates select="parameters"/>
        <xsl:text>
{
</xsl:text>

        <xsl:text>enableIROut(</xsl:text>
        <xsl:value-of select="floor(number(@frequency) div number(1000))"/>
        <xsl:text>);
</xsl:text>
        <xsl:apply-templates select="bitspec_irstream/irstream/intro"/>

    <xsl:text>
};
</xsl:text>

    </xsl:template>

    <xsl:template match="extent" mode="declare_funcs">
        <xsl:text>// This function "should" generate an ending silence, long enough so that
// the total signal has the length indicated by the argument. "Should".
// Since IRremote just ignores ending silence, so we do so too,
// at least for now.
static void extent(</xsl:text>
        <xsl:value-of select="$microsecondsType"/>
        <xsl:text> wait_for) {
            (void) wait_for; // suppress warnings on unused variable
            space(0U);
}
        </xsl:text>
    </xsl:template>

    <xsl:template match="bitspec" mode="declare_funcs">
        <xsl:text>static void finite_bitfield(</xsl:text>
        <xsl:value-of select="$parameterType"/>
        <xsl:text> data, </xsl:text>
        <xsl:value-of select="$parameterType"/>
        <xsl:text> width)
{
</xsl:text>

        <xsl:if test="@bitdirection='lsb'">
            <xsl:text>for (unsigned int i = 0U; i &lt; width; i += </xsl:text>
        </xsl:if>
        <xsl:if test="@bitdirection='msb'">
            <xsl:text>for (unsigned int i = width - 1U; i &gt;= 0U; i -= </xsl:text>
        </xsl:if>
        <xsl:value-of select="@chunksize"/>
        <xsl:text>)
</xsl:text>

        <xsl:text>{
</xsl:text>


        <xsl:text>unsigned int mask = </xsl:text>
        <xsl:apply-templates select="@chunksize"/>
        <xsl:text>U &lt;&lt; </xsl:text>
        <xsl:if test="@bitdirection='msb'">
            <xsl:text>width - 1 -</xsl:text>
        </xsl:if>
        <xsl:text>i*</xsl:text>
        <xsl:value-of select="@chunksize"/>
        <xsl:text>;</xsl:text>


        <xsl:text>unsigned int chunk = data &amp; mask;
</xsl:text>
        <xsl:apply-templates select="."/>


        <xsl:text>}
}

</xsl:text>
    </xsl:template>

    <xsl:template match="@chunksize[.='1']">
        <xsl:text>1</xsl:text>
    </xsl:template>

    <xsl:template match="@chunksize[.='2']">
        <xsl:text>3</xsl:text>
    </xsl:template>

    <xsl:template match="@chunksize[.='3']">
        <xsl:text>7</xsl:text>
    </xsl:template>


    <xsl:template match="bitspec[count(./*)=2]">


        <xsl:text>if (chunk == 0) {
</xsl:text>
        <xsl:apply-templates select="bare_irstream[1]"/>


        <xsl:text>} else {
</xsl:text>
        <xsl:apply-templates select="bare_irstream[2]"/>


        <xsl:text>}
</xsl:text>
    </xsl:template>

    <!--xsl:template match="parameters">
        <xsl:text>(</xsl:text>
    <xsl:apply-templates select="parameter"/>
    <xsl:text>)</xsl:text>
    </xsl:template-->

    <xsl:template match="parameters" mode="definition">
        <xsl:text>IrSignal *</xsl:text>
        <xsl:value-of select="@protocolName"/>
    <xsl:text>Renderer::newIrSignal(</xsl:text>
    <xsl:apply-templates select="parameter"/>
    <xsl:text>);</xsl:text>
    </xsl:template>

    <!--xsl:template match="parameter">
        <xsl:value-of select="$parameterType"/>
        <xsl:text> </xsl:text>
        <xsl:value-of select="@name"/>
        <xsl:if test="not(position()=last())">
            <xsl:text>, </xsl:text>
        </xsl:if>
    </xsl:template-->

    <xsl:template match="bitspec_irstream">
        <xsl:text> {
</xsl:text>

<xsl:apply-templates select="irstream"/>
<xsl:text>}
</xsl:text>
    </xsl:template>

    <xsl:template match="irstream">
        <xsl:apply-templates select="intro[*]" mode="call"/>
        <xsl:apply-templates select="repeat[*]" mode="call"/>
        <xsl:apply-templates select="ending[*]" mode="call"/>
    </xsl:template>

    <xsl:template match="intro|repeat|ending" mode="call">
        <xsl:text>do</xsl:text>
        <xsl:value-of select="name(.)"/>
        <xsl:text>();
</xsl:text>
    </xsl:template>

    <xsl:template match="intro|repeat|ending" mode="definition">
        <xsl:value-of select="@protocolName"/><xsl:text>Renderer::do</xsl:text>
        <xsl:value-of select="name(.)"/>
        <xsl:text>() {
</xsl:text>
        <xsl:apply-templates select="*"/>


<xsl:text>};
</xsl:text>
    </xsl:template>


    <xsl:template match="Number">
        <xsl:apply-templates select="node()"/>
    </xsl:template>

    <xsl:template match="NameOrNumber">
        <xsl:apply-templates select="*"/>
    </xsl:template>

    <xsl:template match="NumberWithDecimals">
        <xsl:apply-templates select="node()"/>
    </xsl:template>



    <xsl:template xml:space="skip" name="duration">
        <xsl:param name="func"/>
        <xsl:param name="time"/>
        <xsl:param name="multiplier"/>
        <xsl:text xml:space="preserve">    </xsl:text>
        <xsl:value-of select="$func"/>
        <xsl:text>(</xsl:text>
        <xsl:value-of select="round(number($time)*number($multiplier))"/>
        <xsl:text>);&#10;</xsl:text>
    </xsl:template>

    <xsl:template match="Flash[@unit='']">
        <xsl:call-template name="duration">
            <xsl:with-param name="func" select="'mark'"/>
            <xsl:with-param name="time">
                <xsl:apply-templates select="*"/>
            </xsl:with-param>
            <xsl:with-param name="multiplier">
                <xsl:value-of select="number(ancestor::Protocol/GeneralSpec/@unit)"/>
            </xsl:with-param>
        </xsl:call-template>
    </xsl:template>

    <xsl:template match="Gap[@unit='']">
        <xsl:call-template name="duration">
            <xsl:with-param name="func" select="'space'"/>
            <xsl:with-param name="time">
                <xsl:apply-templates select="*"/>
            </xsl:with-param>
            <xsl:with-param name="multiplier">
                <xsl:value-of select="number(ancestor::Protocol/GeneralSpec/@unit)"/>
            </xsl:with-param>
        </xsl:call-template>
    </xsl:template>

    <xsl:template match="Extent[@unit='m']">
        <xsl:call-template name="duration">
            <xsl:with-param name="func" select="'extent'"/>
            <xsl:with-param name="time">
                <xsl:apply-templates select="*"/>
            </xsl:with-param>
            <xsl:with-param name="multiplier" select="1000"/>
        </xsl:call-template>
    </xsl:template>

    <!--xsl:template match="Flash[@unit='m']|Gap[@unit='m']">
        <xsl:text>&#9;</xsl:text>
        <xsl:call-template name="duration">
            <xsl:with-param name="x">
                <xsl:apply-templates select="*"/>
            </xsl:with-param>
            <xsl:with-param name="y" select="1000"/>
        </xsl:call-template>
        <xsl:value-of select="1000 * @time"/>
    </xsl:template>

    <xsl:template match="Extent[@unit='m']" mode="gap">
        <xsl:text>&#9;</xsl:text>
        <xsl:call-template name="duration">
            <xsl:with-param name="x">
                <xsl:apply-templates select="*"/>
            </xsl:with-param>
            <xsl:with-param name="y" select="1000"/>
        </xsl:call-template>
    </xsl:template-->

    <!--xsl:template match="Flash">xxxxxxxxxxxxxxxxx
        <xsl:call-template name="duration">
            <xsl:with-param name="func" select="'mark'"/>
            <xsl:with-param name="time">
                <xsl:apply-templates select="*"/>
            </xsl:with-param>
            <xsl:with-param name="multiplier">
                <xsl:apply-templates select="@unit"/>
            </xsl:with-param>
        </xsl:call-template>
    </xsl:template-->

    <xsl:template match="Gap" mode="send">
        <xsl:call-template name="duration">
            <xsl:with-param name="func" select="'space'"/>
            <xsl:with-param name="time" select="@time"/>
            <xsl:with-param name="multiplier">
                <xsl:apply-templates select="@unit"/>
            </xsl:with-param>
        </xsl:call-template>
    </xsl:template>

    <xsl:template match="Extent" mode="send">
        <xsl:call-template name="duration">
            <xsl:with-param name="func" select="'extent'"/>
            <xsl:with-param name="time" select="@time"/>
            <xsl:with-param name="multiplier">
                <xsl:apply-templates select="@unit"/>
            </xsl:with-param>
        </xsl:call-template>
    </xsl:template>

    <xsl:template match="@unit[.='']">
        <xsl:text>*</xsl:text>
        <xsl:value-of select="@timeUnit"/>
    </xsl:template>

    <xsl:template match="@unit[.='m']">
        <xsl:text>*</xsl:text>
        <xsl:value-of select="1000"/>
    </xsl:template>

    <xsl:template match="@unit[.='u']">

    </xsl:template>

    <xsl:template match="@unit[.='p']">
        <xsl:text>*1000000/</xsl:text>
        <xsl:value-of select="@frequency"/>
    </xsl:template>

    <xsl:template match="extent[@unit='1']">

        <xsl:text>extent(</xsl:text>
        <xsl:apply-templates select="*"/>
        <xsl:text>*</xsl:text>
        <xsl:value-of select="@timeUnit"/>
        <xsl:text>);
</xsl:text>
    </xsl:template>

    <!--xsl:template name="duration">
        <xsl:param name="funcName"/>
        <xsl:param name="multiplier"/>
        <xsl:param name="time"/>
        <xsl:value-of select="$funcName"/>
        <xsl:text>(</xsl:text>
        <xsl:value-of select="$time"/>
        <!- -xsl:apply-templates select="*"/- ->
        <xsl:value-of select="$multiplier"/>
        <xsl:text>);
</xsl:text>
    </xsl:template-->

    <!--xsl:template match="name_or_number">
        <xsl:apply-templates select="*"/>
    </xsl:template>

    <xsl:template match="number_with_decimals">
        <xsl:value-of select="."/>
    </xsl:template>

    <xsl:template match="finite_bitfield[@reverse='true']">
        <xsl:call-template name="finite_bitfield">
            <xsl:with-param name="funcName" select="'finite_bitfield_reverse'"/>
        </xsl:call-template>
    </xsl:template>

    <xsl:template match="finite_bitfield[not(@reverse='true')]">
        <xsl:call-template name="finite_bitfield">
            <xsl:with-param name="funcName" select="'finite_bitfield'"/>
        </xsl:call-template>
    </xsl:template>

    <xsl:template name="finite_bitfield">
        <xsl:param name="funcName"/>

        <xsl:value-of select="$funcName"/>
        <xsl:text>(</xsl:text>
        <xsl:if test="@complement='true'">
            <xsl:text>~</xsl:text>
        </xsl:if>
        <xsl:apply-templates select="data"/>
        <xsl:text>, </xsl:text>
        <xsl:apply-templates select="width"/>
        <xsl:apply-templates select="chop"/>
        <xsl:text>);
</xsl:text>
    </xsl:template-->

    <xsl:template match="data">
        <xsl:apply-templates select="*"/>
    </xsl:template>

    <xsl:template match="name">
        <xsl:value-of select="@name"/>
    </xsl:template>

    <xsl:template match="width|chop">
        <xsl:apply-templates select="*"/>
    </xsl:template>

    <xsl:template match="number">
        <xsl:value-of select="."/>
    </xsl:template>

</xsl:stylesheet>